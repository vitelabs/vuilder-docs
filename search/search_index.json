{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What Is Vite And What Makes Vite Different","text":"<p>Blockchain is a technology that allows users to trust that the Internet computer programs they interact with will operate \"as is.\" This means the blockchain gives assurance that the programs will be executed according to the associated open source code. This is made possible due to the tamper-resistant nature of the data and code instructions (\"smart contracts\") stored on the blockchain. Any attacker will have a hard time altering said data and smart contracts once they have been added to the blockchain.</p> <p>There are many approaches to designing a blockchain. In general, a practically usable blockchain should have the following features:</p> <ul> <li>Scalability: The chain should be able to process large number of transactions per unit of time to accommodate real-world applications.</li> <li>Fast finality: It doesn't take too long for a transaction to be considered irreversable, otherwise crippling practical commerce.</li> <li>Affordability: The fees for using a blockchain should not be prohibitively expensive.</li> <li>Security: The potential power to reverse transactions should be distributed widely to avoid attacks by a small group of colluders.</li> </ul> <p>Vite was designed to take all the above features into account. In particular, Vite shines in facilitating fast-finality transactions at exactly zero fees. Vite is able to accomplish this with the following designs:</p> <ul> <li>Token locking model: Instead of requiring fees (e.g., gas for Ethereum), Vite users lock VITE tokens to secure the resources needed for transactions.</li> <li>Asynchronous architecture: Allow parallel processing for both payment transactions and smart contract calls. De-couple a send from a receive for payment transactions. De-couple invocation and execution for smart contract calls.</li> <li>Directed Acyclic Graph ledger: Each account has its own blockchain, and transactions are confirmed as they are appended to the respective individual chains.</li> <li>Hierarchical Delegated Proof of Stake: The basic version of Delegated Proof Of Stake (DPOS) lets a set of voted-in validators take turns validating the network. \"Hierarchical\" allows each contract to specify its own group of such validators (aka \"consensus group\"), which defaults to the global consensus group (or snapshot consensus group)</li> </ul> <p>Read the Whitepaper for more details.</p> <p>Now that you have a basic idea for what Vite does and how it's different, you may want to learn more about various components of the Vite stack. You can also begin developing on the Vite chain by checking out Solidity++, the front-end, common patterns, and Vite Express.</p>"},{"location":"SDK/","title":"Index","text":"<p>order: false parent:     title: SDK     order: 3</p>"},{"location":"SDK/vite-connect/","title":"How to Use ViteConnect","text":"<p>ViteConnect allows you to connect the Vite iOS / Android Wallet app (hereinafter referred to as Wallet) to your web application (hereinafter referred to as Web App).</p> <p>This package generates URIs that you can embed in a QR code for a user to scan with their Wallet. After the connection is established, transactions initiated by your Web App are relayed to the connected Wallet where the user can confirm or cancel it. This process ensures that the Web App you are interacting with never sees your private keys as the signing process happens on your phone.</p> <p>See here for more introduction about ViteConnect.</p>"},{"location":"SDK/vite-connect/#installation","title":"Installation","text":"<pre><code>npm install @vite/connector\n</code></pre>"},{"location":"SDK/vite-connect/#connector-class","title":"<code>Connector</code> Class","text":"<p>Instances of <code>Connector</code> represent a user's ViteConnect session. - Constructor:      - <code>opts: IWalletConnectOptions</code>         - <code>bridge?: string</code> - URL of a ViteConnect Server         - <code>uri?: string</code> - ViteConnect URI. This can be attained from <code>new Connector().uri</code>         - <code>session?: IWalletConnectSession</code> - Instance of an existing ViteConnect session. This can be attained from <code>new Connector().session</code>         &gt; Note: Despite all three fields being optional, at least one must be present.     - <code>meta?: IClientMeta</code> Optional Web App info that can be shown in the Wallet         - <code>bridgeVersion: number</code>         - <code>description: string</code>         - <code>url: string</code>         - <code>icons: string[]</code>         - <code>name: string</code>         - <code>lastAccount?: string</code> - Example <pre><code>import Connector from '@vite/connector';\nconst bridge = 'wss://biforst.vite.net';\nconst vcInstance = new Connector({ bridge });\n</code></pre></p>"},{"location":"SDK/vite-connect/#properties","title":"Properties","text":"Name Type Description bridge <code>string</code> URL of a ViteConnect server key <code>string</code> AES encryption key used to encrypt messages clientId <code>string</code> Unique Web App id peerId <code>string</code> Unique Wallet id clientMeta <code>IClientMeta</code> Web App info peerMeta <code>IClientMeta</code> Wallet info handshakeTopic <code>string</code> Handshake topic handshakeId <code>number</code> Handshake id uri <code>string</code> The ViteConnect URI that can be embedded in the QR code chainId <code>number</code> Chain id accounts <code>string[]</code> The list of connected accounts connected <code>boolean</code> If <code>true</code>, a Wallet has been connected session <code>object</code> An object that wraps all above properties except for <code>uri</code>"},{"location":"SDK/vite-connect/#methods","title":"Methods","text":""},{"location":"SDK/vite-connect/#createsession","title":"<code>createSession</code>","text":"<p>Creates a new ViteConnect session. After this method is called, it will wait until a Wallet approves or rejects the request. You can get the URI after the request is approved. - Parameters:      - <code>opts?: { chainId: number }</code> Optional chain id - Returns:     - <code>Promise&lt;void&gt;</code> - Example <pre><code>await vcInstance.createSession();\nconst qrCodeData = vcInstance.uri;\n// renderQRCode(qrCodeData);\n</code></pre></p> <p>Important</p> <p>It is crucial that you call <code>createSession</code> before using <code>vcInstance.uri</code> otherwise the Vite Wallet will not be able to connect.</p> <p>Tip</p> <p>To persist a session after your Web App stops, you can store the <code>session</code> data in <code>localStorage</code> and add it to the config object when instantiating <code>Connector</code> to restore the session.</p> <pre><code>localStorage.setItem('vcSession', vcInstance.session);\nconst vcInstance = new Connector({ session: localStorage.getItem('vcSession') });\n// vcInstance can now be used to sign transactions without needing the user to connect again\n</code></pre>"},{"location":"SDK/vite-connect/#sendcustomrequest","title":"<code>sendCustomRequest</code>","text":"<p>Send various requests to the ViteConnect server. A common request is sending an unsigned transaction so that it will be signed in the Wallet. - Parameters:      - <code>request: Partial&lt;IJsonRpcRequest&gt;</code>         - <code>id?: number</code> Unique request id. Use if you need to respond to a specific request, otherwise leave it empty.          - <code>jsonrpc?: string</code> JsonRpc version, default '2.0'         - <code>method: string</code>             - <code>'vc_sessionRequest'</code>                  - Create a new session             - <code>'vc_sessionUpdate'</code>                  - Update current session info             - <code>'vc_peerPing'</code>                  - Send 'keepalive' message             - <code>'vite_signAndSendTx'</code>                 - Request for signing a transaction and send             - <code>'vite_signMessage'</code>                  - Request for signing a transaction         - <code>params: any[]</code> Input arguments - Returns:     - <code>Promise&lt;Any&gt;</code> - Example <pre><code>// @vite/vitejs is a separate package you need to install for this example\nimport { accountBlock } from '@vite/vitejs';\n\nconst sendVcTx = () =&gt; {\n    const block = accountBlock.createAccountBlock('callContract', {\n        address: fromViteAddress,\n        abi: contractABI,\n        toAddress: toViteAddress,\n        params: [],\n        tokenId: viteTokenId,\n        // This equals 1 VITE since VITE has 18 decimals\n        amount: \"1\" + \"0\".repeat(18),\n    }).accountBlock;\n\n    vcInstance\n        .sendCustomRequest({ method: 'vite_signAndSendTx', params: { block } })\n        .then((signedBlock: Block) =&gt; signedBlock);\n}\n</code></pre></p>"},{"location":"SDK/vite-connect/#killsession","title":"<code>killSession</code>","text":"<p>Disconnect the Wallet and close the session - Parameters:      - <code>sessionError?: ISessionError</code>         - <code>message?: string</code> Optional message - Returns:     - <code>Promise&lt;void&gt;</code> - Example <pre><code>vcInstance.killSession();\n</code></pre></p>"},{"location":"SDK/vite-connect/#startbizheartbeat","title":"<code>startBizHeartBeat</code>","text":"<p>Start sending heartbeat messages - Parameters:      - None - Returns:     - void - Example <pre><code>vcInstance.startBizHeartBeat();\n</code></pre></p> <p>Heartbeat</p> <p>If the Web App hasn't sent a message for more than 10s after the connection is established, the session could be closed because the Wallet will send a disconnect message for not receiving your messages within 10s. You do not need to call this method - it will be called automatically when a session is created or updated.</p>"},{"location":"SDK/vite-connect/#stopbizheartbeat","title":"<code>stopBizHeartBeat</code>","text":"<p>Stop sending heartbeat messages - Parameters:      - None - Returns:     - void - Example <pre><code>vcInstance.stopBizHeartBeat();\n</code></pre></p> <p>Note: if this method is called, the session will be closed after idle for 10s.</p>"},{"location":"SDK/vite-connect/#destroy","title":"<code>destroy</code>","text":"<p>Stop sending heartbeat message, kill the current session and close socket. The ViteConnect server will recycle the related topics - Parameters:      - None - Returns:     - void - Example <pre><code>vcInstance.destroy();\n</code></pre></p>"},{"location":"SDK/vite-connect/#approverequest","title":"<code>approveRequest</code>","text":"<p>Notify the Web App that an RPC request has been approved with response - Parameters:      - <code>response: Partial&lt;IJsonRpcResponseSuccess&gt;</code>         - <code>id: number</code> Response id which corresponds to an RPC request         - <code>jsonrpc: string</code>         - <code>result: any</code> Result - Returns:     - <code>void</code> - Example <pre><code>vcInstance.approveRequest(response);\n</code></pre></p>"},{"location":"SDK/vite-connect/#rejectrequest","title":"<code>rejectRequest</code>","text":"<p>Notify the Web App that an RPC request has been rejected with error - Parameters:      - <code>response: Partial&lt;IJsonRpcResponseError&gt;</code>         - <code>id: number</code> Response id which corresponds to a RPC request         - <code>jsonrpc: string</code>         - <code>error: IJsonRpcErrorMessage</code> Error message - Returns:     - <code>void</code> - Example <pre><code>vcInstance.approveRequest(response);\n</code></pre></p>"},{"location":"SDK/vite-connect/#approvesession","title":"<code>approveSession</code>","text":"<p>When the Web App sends a new session or session update request, it will wait for the response. The Wallet should call <code>approveSession</code> to approve the request or reject it with <code>rejectSession</code> - Parameters:      - <code>sessionStatus: ISessionStatus</code>         - <code>chainId: number</code> Chain id         - <code>accounts: string[]</code> Connected accounts - Returns:     - <code>void</code> - Example <pre><code>vcInstance.approveSession(sessionStatus);\n</code></pre></p>"},{"location":"SDK/vite-connect/#rejectsession","title":"<code>rejectSession</code>","text":"<p>When the Web App sends a new session or session update request, it will wait for the response. The Wallet should call <code>approveSession</code> to approve the request or reject it with <code>rejectSession</code> - Parameters:      - <code>sessionError?: ISessionError</code>         - <code>message?: string</code> Error message - Returns:     - <code>void</code> - Example <pre><code>vcInstance.rejectSession(sessionError);\n</code></pre></p>"},{"location":"SDK/vite-connect/#updatesession","title":"<code>updateSession</code>","text":"<p>Update the current session with new chain id or connected account is changed. </p> <p>Note: For the time being only the first account of the array works - Parameters:      - <code>sessionStatus: ISessionStatus</code>         - <code>chainId: number</code> Chain id         - <code>accounts: string[]</code> Connected accounts - Returns:     - <code>void</code> - Example <pre><code>vcInstance.updateSession(sessionStatus);\n</code></pre></p>"},{"location":"SDK/vite-connect/#on","title":"<code>on</code>","text":"<p>Trigger callback functions for various events. - Parameters:      - <code>event: string</code>     - <code>'connect'</code> When <code>approveSession</code> is called for a new session request or the user connects his Wallet     - <code>'disconnect'</code> When <code>killSession</code> or <code>rejectSession</code> is called or the user logs out from his Wallet     - <code>'session_request'</code> When <code>createSession</code> request is received      - <code>'session_update'</code> When <code>updateSession</code> is called or <code>approveSession</code> is called for a session update request     - <code>'vc_peerPing'</code> When a heartbeat message is received     - <code>'error'</code> When <code>vc_sessionRequest</code> or <code>connect</code> returns error     - <code>callback: (error: Error | null, payload: any | null) =&gt; void</code> The callback function to call when the <code>event</code> is triggered - Returns:     - <code>void</code></p> <p>Example</p> <pre><code>vcInstance.on('connect', (err, payload) =&gt; {\n    // vcInstance can start prompting transactions on the user's Vite Wallet app\n});\nvcInstance.on('disconnect', (err, payload) =&gt; {\n    // User's Vite Wallet app is no longer connected\n})\n</code></pre>"},{"location":"SDK/vitej/","title":"Overview","text":"<p>ViteJ is a collection of Java libraries that allows you to interact with a local or remote Vite node using HTTP, IPC or WebSocket.</p>"},{"location":"SDK/vitej/#source-code","title":"Source Code","text":"<p>Source code: ViteJ </p>"},{"location":"SDK/vitej/#dependencies","title":"Dependencies","text":""},{"location":"SDK/vitej/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.vite&lt;/groupId&gt;\n  &lt;artifactId&gt;vitej&lt;/artifactId&gt;\n  &lt;version&gt;1.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.vite&lt;/groupId&gt;\n  &lt;artifactId&gt;vitej-dependencies&lt;/artifactId&gt;\n  &lt;version&gt;1.1.0&lt;/version&gt;\n  &lt;type&gt;pom&lt;/type&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"SDK/vitej/#gradle","title":"Gradle","text":"<pre><code>implementation 'org.vite:vitej:1.1.0'\nimplementation 'org.vite:vitej-dependencies:1.1.0'\n</code></pre>"},{"location":"SDK/vitej/#a-simple-example","title":"A Simple Example","text":"<pre><code>import com.alibaba.fastjson.JSON;\nimport org.vitej.core.protocol.HttpService;\nimport org.vitej.core.protocol.Vitej;\nimport org.vitej.core.protocol.methods.response.SnapshotChainHeightResponse;\n\nimport java.io.IOException;\n\npublic class QuickStart {\n    public static void main(String[] args) {\n        try {\n            // Create a Vitej client\n            Vitej vitej = new Vitej(new HttpService());\n            // Look up the latest snapshot block height\n            SnapshotChainHeightResponse response = vitej.getSnapshotChainHeight().send();\n            System.out.println(JSON.toJSONString(response));\n            Long latestSnapshotHeight = response.getHeight();\n            System.out.println(latestSnapshotHeight);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <p>See ViteJ Demo for more examples and usages</p>"},{"location":"SDK/vitej/modules/","title":"Modules","text":""},{"location":"SDK/vitej/modules/asset/","title":"Asset &amp; Token Issuance API","text":""},{"location":"SDK/vitej/modules/asset/#issue-new-token","title":"Issue New Token","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.issueToken(keyPair,\n        new IssueTokenParams()\n                .setReIssuable(true)\n                .setTokenName(\"Test Token\")\n                .setTokenSymbol(\"TT\")\n                .setTotalSupply(BigInteger.valueOf(10000L))\n                .setMaxSupply(BigInteger.valueOf(20000L))\n                .setDecimals(1)\n                .setOwnerBurnOnly(false));\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/asset/#re-issue-token","title":"Re-issue Token","text":"<p>Mint an additional amount of token and increase token's total supply</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.reIssue(keyPair, new TokenId(\"tti_10b56995f5d6a6e1f9a60441\"), BigInteger.valueOf(100), keyPair.getAddress());\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/asset/#burn-token","title":"Burn Token","text":"<p>Burn an amount of token and decrease token's total supply</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.burn(keyPair, new TokenId(\"tti_10b56995f5d6a6e1f9a60441\"), BigInteger.valueOf(100));\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/asset/#transfer-token-ownership","title":"Transfer Token Ownership","text":"<p>Ownership of token can be transferred to another address. When a token is firstly issued, the token owner is the issuer. </p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.transferOwnership(keyPair, new TokenId(\"tti_10b56995f5d6a6e1f9a60441\"), new Address(\"vite_098dfae02679a4ca05a4c8bf5dd00a8757f0c622bfccce7d68\"));\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/asset/#disable-token-re-issuance","title":"Disable Token Re-issuance","text":"<p>Change a re-issuable token to non-reissuable. </p> <p>One-way Operation</p> <p>Be careful with this method. The operation can not be reversed.</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.disableReIssue(keyPair, new TokenId(\"tti_10b56995f5d6a6e1f9a60441\"));\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/asset/#get-token-list","title":"Get Token List","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nTokenInfoListWithTotalResponse response = vitej.getTokenInfoList(\n        // page index. start at 0\n        0,\n        // page size\n        10\n).send();\n// total token nunmber\nInteger count = response.getResult().getTotalCount();\n// token list\nList&lt;TokenInfo&gt; tokenInfoList = response.getResult().getTokenInfoList();\n</code></pre>"},{"location":"SDK/vitej/modules/asset/#get-token-summary","title":"Get Token Summary","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nTokenInfoResponse response = vitej.getTokenInfoById(\n        // token id\n        new TokenId(\"tti_5649544520544f4b454e6e40\")\n).send();\nTokenInfo tokenInfo = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/asset/#get-token-list-by-owner","title":"Get Token List (by owner)","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nTokenInfoListResponse response = vitej.getTokenInfoListByOwner(\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\")\n).send();\nList&lt;TokenInfo&gt; tokenInfo = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/quota/","title":"Quota API","text":""},{"location":"SDK/vitej/modules/quota/#stake-for-quota","title":"Stake for Quota","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.stakeForQuota(keyPair, keyPair.getAddress(), org.vitej.core.constants.BuiltinContracts.MINIMUM_STAKE_FOR_QUOTA_AMOUNT);\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/quota/#cancel-quota-staking","title":"Cancel Quota Staking","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.cancelQuotaStaking(keyPair, new Hash(\"874aeae0389118ade5f81371041a45bb39a85630b3eb463c3329dfef89618d36\"));\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/quota/#get-account-quota-summary","title":"Get Account Quota Summary","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nQuotaResponse response = vitej.getQuotaByAccount(\n        // address of account\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\")\n).send();\n// quota available\nLong currentQuota = response.getResult().getCurrentQuota();\n// max quota\nLong maxQuota = response.getResult().getMaxQuota();\n// total staking amount \nBigInteger stakeAmount = response.getResult().getStakeAmount();\n</code></pre>"},{"location":"SDK/vitej/modules/quota/#get-account-staking-list","title":"Get Account Staking List","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nStakeListResponse response = vitej.getStakeList(\n        // staking address\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\"),\n        // page index. start at 0\n        0,\n        // page size\n        10\n).send();\n// total staking amount\nBigInteger totalStakeAmount = response.getResult().getTotalStakeAmount();\n// total staking records\nInteger totalStakeCount = response.getResult().getTotalStakeCount();\n// staking list\nList&lt;StakeListResponse.StakeInfo&gt; stakeInfoList = response.getResult().getStakeList();\n</code></pre>"},{"location":"SDK/vitej/modules/quota/#calculate-expected-staking-amount","title":"Calculate Expected Staking Amount","text":"<p>The input parameter is estimated quota consumption per second. For example, if you need send a basic transaction (no comment) in every second, you should input 21000.</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nStakeAmountResponse response = vitej.getRequiredStakeAmount(21000L).send();\nBigInteger stakeAmount = response.getStakeAmount();\n</code></pre>"},{"location":"SDK/vitej/modules/quota/#calculate-quota-consumption","title":"Calculate Quota Consumption","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nRequiredQuotaResponse response = vitej.getRequiredQuota(\n        // transaction parameters\n        new TransactionParams()\n                // block type. default is SEND_CALL\n                .setBlockType(EBlockType.SEND_CALL.getValue())\n                // sender address\n                .setAddress(new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\"))\n                // recipient address\n                .setToAddress(new Address(\"vite_098dfae02679a4ca05a4c8bf5dd00a8757f0c622bfccce7d68\"))\n                // comment\n                .setData(\"Hello\".getBytes())).send();\nLong requiredQuota = response.getRequiredQuota();\n</code></pre>"},{"location":"SDK/vitej/modules/quota/#calculate-expected-pow-difficulty","title":"Calculate Expected PoW Difficulty","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nPoWDifficultyResponse response = vitej.getPoWDifficulty(\n        // transaction parameters\n        new TransactionParams()\n                // block type. default is SEND_CALL\n                .setBlockType(EBlockType.SEND_CALL.getValue())\n                // sender address\n                .setAddress(new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\"))\n                // recipient address\n                .setToAddress(new Address(\"vite_098dfae02679a4ca05a4c8bf5dd00a8757f0c622bfccce7d68\"))\n                // comment\n                .setData(\"Hello\".getBytes())).send();\n// estimated quota consumption for sending this transaction\nLong requiredQuota = response.getResult().getRequiredQuota();\n// network jam flag. when Vite network is jammed, expect more quota to be consumed than usual. In this case, you need more quota or wait for a while to send the transaction\nboolean isCongested = response.getResult().getCongestion();\n// expected pow difficulty for sending this transaction\nBigInteger difficulty = response.getResult().getDifficulty();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/","title":"Quick Start","text":""},{"location":"SDK/vitej/modules/rpc/#how-to-call-rpc-api","title":"How to Call RPC API","text":""},{"location":"SDK/vitej/modules/rpc/#create-vitej-object","title":"Create ViteJ Object","text":"<p>At beginning, you should create a ViteJ object and choose how to connect to a node. </p> <p>Use HTTP:</p> <pre><code>// default url is http://127.0.0.1:48132\nVitej vitej0 = new Vitej(new HttpService());\n// but you can specify a different one\nVitej vitej1 = new Vitej(new HttpService(\"http://127.0.0.1:48132\"));\n// specify http url and http client\nVitej vitej2 = new Vitej(new HttpService(\"http://127.0.0.1:48132\", new OkHttpClient.Builder().build()));\n// use given private key\nKeyPair keyPair = new Wallet(Arrays.asList(\"network\",\"north\",\"tell\",\"potato\",\"predict\",\"almost\",\"wonder\",\"spirit\",\"wheel\",\"smile\",\"disease\",\"bonus\",\"round\",\"flock\",\"pole\",\"review\",\"music\",\"oven\",\"clarify\",\"exclude\",\"loyal\",\"episode\",\"image\",\"notable\")).deriveKeyPair();\nVitej vitej3 = new Vitej(new HttpService(), keyPair);\n</code></pre> <p>Use WebSocket: <pre><code>// default url is ws://127.0.0.1:41420\nWebSocketService ws0 = new WebSocketService();\nws.connect();\nVitej vitej = new Vitej(ws);\n// but you can specify a different one\nWebSocketService ws1 = new WebSocketService(\"ws://127.0.0.1:41420\");\nws.connect();\nVitej vitej = new Vitej(ws);\n// specify websocket url and http client\nWebSocketService ws2 = new WebSocketService(\"ws://127.0.0.1:41420\", new OkHttpClient.Builder().build());\nws.connect();\nVitej vitej = new Vitej(ws);\n// use given private key\nWebSocketService ws3 = new WebSocketService();\nws.connect();\nKeyPair keyPair = new Wallet(Arrays.asList(\"network\",\"north\",\"tell\",\"potato\",\"predict\",\"almost\",\"wonder\",\"spirit\",\"wheel\",\"smile\",\"disease\",\"bonus\",\"round\",\"flock\",\"pole\",\"review\",\"music\",\"oven\",\"clarify\",\"exclude\",\"loyal\",\"episode\",\"image\",\"notable\")).deriveKeyPair();\nVitej vitej = new Vitej(ws, keyPair);\n</code></pre></p>"},{"location":"SDK/vitej/modules/rpc/#call-rpc-api","title":"Call RPC API","text":""},{"location":"SDK/vitej/modules/rpc/#rpc-request","title":"RPC Request","text":"<p>Request JSON object (JSON-RPC 2.0)</p> <ul> <li><code>jsonrpc</code>: <code>String</code> Version id. must be '2.0'</li> <li><code>id</code>: <code>long</code> Request id</li> <li><code>method</code>: <code>String</code> Method name</li> <li><code>params</code>: <code>List&lt;Object&gt;</code> Parameter list</li> </ul> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ledger_getLatestSnapshotHash\",\n    \"params\": []\n}\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#rpc-response","title":"RPC Response","text":"<p>Response JSON object (JSON-RPC 2.0)</p> <ul> <li><code>id</code>: <code>long</code> Response ID, have the same value with request id</li> <li><code>jsonrpc</code>: <code>String</code> Version id. must be '2.0'</li> <li><code>result</code>: <code>Object</code> Response result</li> <li><code>error</code>: Error message</li> <li><code>code</code>: <code>int</code> Error code</li> <li><code>message</code>: <code>String</code> Description</li> </ul> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"67f7ee751968a832d7d776aad6de3ca9b58f37c8c4bf8442a935f891a850d8b1\"\n}\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#make-the-call","title":"Make the Call","text":"<p>Synchronous method</p> <pre><code>AccountBlocksResponse response = vitej.getAccountBlocksByAddress(\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\"), 0, 10\n    ).send();\nList&lt;AccountBlock&gt; accountBlockList = response.getResult();\n</code></pre> <p>Asynchronous method</p> <pre><code>CompletableFuture&lt;AccountBlocksResponse&gt; future = vitej.getAccountBlocksByAddress(\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\"), 0, 10\n).sendAsync();\nAccountBlocksResponse response = future.get();\nList&lt;AccountBlock&gt; accountBlockList = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#rpc-api-wrapper","title":"RPC API Wrapper","text":""},{"location":"SDK/vitej/modules/rpc/#send-transaction","title":"Send Transaction","text":"<p>Sending a transaction (by <code>sendTransaction</code> method) includes the following steps : 1. Check transaction object. Fill in default value if required parameters are not present; 2. Calculate quota consumption. If the available quota of the account is insufficient and having <code>autoPoW</code>=<code>true</code>, do a PoW puzzle to get temporary quota; 3. Create transaction hash, then sign the transaction.</p> <p>Module Required</p> <p>Make sure <code>util</code> is configured in <code>PublicModules</code> in <code>node_config.json</code> on your node when <code>autoPoW</code>=<code>true</code>.</p>"},{"location":"SDK/vitej/modules/rpc/#send-a-transfer","title":"Send a Transfer","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nKeyPair keyPair = new Wallet(Arrays.asList(\"network\", \"north\", \"tell\", \"potato\", \"predict\", \"almost\", \"wonder\", \"spirit\", \"wheel\", \"smile\", \"disease\", \"bonus\", \"round\", \"flock\", \"pole\", \"review\", \"music\", \"oven\", \"clarify\", \"exclude\", \"loyal\", \"episode\", \"image\", \"notable\")).deriveKeyPair();\nRequest&lt;?, EmptyResponse&gt; request = vitej.sendTransaction(\n        // key used to sign the transaction\n        keyPair,\n        // transaction information\n        new TransactionParams()\n                // transaction type, optional. Default is SEND_CALL\n                .setBlockType(EBlockType.SEND_CALL.getValue())\n                // recipient address. must present\n                .setToAddress(new Address(\"vite_098dfae02679a4ca05a4c8bf5dd00a8757f0c622bfccce7d68\"))\n                // transfer amount, optional. Default is 0\n                .setAmount(BigInteger.valueOf(1))\n                // transfer token id, optional. Default token is VITE\n                .setTokenId(CommonConstants.VITE_TOKEN_ID)\n                // transaction comment, optional\n                .setData(\"Hello\".getBytes()),\n        // enable/disable pow\n        false);\nHash sendBlockHash = ((TransactionParams) request.getParams().get(0)).getHashRaw();\nEmptyResponse response = request.send();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#receive","title":"Receive","text":"<p>In Vite, you must explicitly send out a 'Receive' transaction to receive a 'pending' transaction that was sent to you.</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nKeyPair keyPair = new Wallet(Arrays.asList(\"network\", \"north\", \"tell\", \"potato\", \"predict\", \"almost\", \"wonder\", \"spirit\", \"wheel\", \"smile\", \"disease\", \"bonus\", \"round\", \"flock\", \"pole\", \"review\", \"music\", \"oven\", \"clarify\", \"exclude\", \"loyal\", \"episode\", \"image\", \"notable\")).deriveKeyPair();\nRequest&lt;?, EmptyResponse&gt; request = vitej.sendTransaction(keyPair,\n        new TransactionParams()\n                // transaction type. must be RECEIVE\n                .setBlockType(EBlockType.RECEIVE.getValue())\n                // request transaction hash. must present\n                .setSendBlockHash(new Hash(\"ef5dccd73a6ef6370bc72b56b686362fd095152e2746f21113c2015e243b5056\")),\n        false);\nHash receiveBlockHash = ((TransactionParams) request.getParams().get(0)).getHashRaw();\nEmptyResponse response = request.send();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#call-smart-contract","title":"Call Smart Contract","text":"<p>See Call Contract for detailed information</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nKeyPair keyPair = new Wallet(Arrays.asList(\"network\", \"north\", \"tell\", \"potato\", \"predict\", \"almost\", \"wonder\", \"spirit\", \"wheel\", \"smile\", \"disease\", \"bonus\", \"round\", \"flock\", \"pole\", \"review\", \"music\", \"oven\", \"clarify\", \"exclude\", \"loyal\", \"episode\", \"image\", \"notable\")).deriveKeyPair();\n// use abi to generate binary data to call a method on contract\nAbi abi = Abi.fromJson(\"[{\\\"type\\\":\\\"function\\\",\\\"name\\\":\\\"VoteForSBP\\\", \\\"inputs\\\":[{\\\"name\\\":\\\"sbpName\\\",\\\"type\\\":\\\"string\\\"}]}]\");\nbyte[] callContractData = abi.encodeFunction(\"VoteForSBP\", \"Vite_SBP01\");\nRequest&lt;?, EmptyResponse&gt; request = vitej.sendTransaction(\n        keyPair,\n        new TransactionParams()\n                // transaction type. must be SEND_CALL\n                .setBlockType(EBlockType.SEND_CALL.getValue())\n                // smart contract address. must present\n                .setToAddress(new Address(\"vite_0000000000000000000000000000000000000004d28108e76b\"))\n                // transfer amount, optional. Default is 0\n                .setAmount(new BigInteger(\"0\"))\n                // transfer token id, optional. Default token is VITE\n                .setTokenId(CommonConstants.VITE_TOKEN_ID)\n                // data generated in above step to call contain method. If not present, no method will be called\n                .setData(callContractData),\n        false);\nHash sendBlockHash = ((TransactionParams) request.getParams().get(0)).getHashRaw();\nEmptyResponse response = request.send();\n// check result\nboolean callSuccess = ProtocolUtils.checkCallContractResult(vitej, sendBlockHash);\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#create-smart-contract","title":"Create Smart Contract","text":"<p>See Create Contract for detailed information</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nKeyPair keyPair = new Wallet(Arrays.asList(\"network\", \"north\", \"tell\", \"potato\", \"predict\", \"almost\", \"wonder\", \"spirit\", \"wheel\", \"smile\", \"disease\", \"bonus\", \"round\", \"flock\", \"pole\", \"review\", \"music\", \"oven\", \"clarify\", \"exclude\", \"loyal\", \"episode\", \"image\", \"notable\")).deriveKeyPair();\n// specify binary code of the contract. tips: use --bin to generate binary when compiling soliditypp source code\nbyte[] bytecode = BytesUtils.hexStringToBytes(\"6080604052348015600f57600080fd5b50604051602080608183398101806040526020811015602d57600080fd5b810190808051906020019092919050505050603580604c6000396000f3fe6080604052600080fdfea165627a7a723058208602dc0b6a1bf2e56f2160299868dc8c3f435c9af6d384858722a21906c7c0740029\");\n// use abi to load constructor\nAbi abi = Abi.fromJson(\"[{\\\"inputs\\\":[{\\\"name\\\":\\\"i\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"payable\\\":false,\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"constructor\\\"}]\");\nbyte[] callConstructorData = abi.encodeConstructor(BigInteger.valueOf(1));\n// generate binary data. pass in 5 parameters (binary code, constructor data, response latency, random degree, quota multiplier)\nbyte[] createContractData = ContractUtils.getCreateContractData(bytecode, callConstructorData, 2, 1, 10);\nRequest&lt;?, EmptyResponse&gt; request = vitej.sendTransaction(\n        keyPair,\n        new TransactionParams()\n                // transaction type. must be SEND_CREATE\n                .setBlockType(EBlockType.SEND_CREATE.getValue())\n                // transfer amount, optional. Default is 0\n                .setAmount(new BigInteger(\"0\"))\n                // transfer token id, optional. Default token is VITE\n                .setTokenId(CommonConstants.VITE_TOKEN_ID)\n                // 10 VITE contract creation fee, optional. Default is 10 VITE\n                .setFee(CommonConstants.CREATE_CONTRACT_FEE)\n                // data generated in above step to create smart contract. must present\n                .setData(createContractData),\n        false);\nHash sendBlockHash = ((TransactionParams) request.getParams().get(0)).getHashRaw();\nEmptyResponse response = request.send();\nboolean callSuccess = ProtocolUtils.checkCallContractResult(vitej, sendBlockHash);\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#calculate-pow","title":"Calculate PoW","text":"<p>'PoW' is used when obtaining temporary quota for sending one transaction. However, we highly recommend to get quota for your account by staking. See Quota API.</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nPoWNonceResponse response = vitej.getPoWNonce(\n        // PoW difficulty\n        BigInteger.valueOf(67108863),\n        // hash value. can be obtained through BlockUtils.getPoWData\n        new Hash(\"d517e8d4dc9c676876b72ad0cbb4c45890804aa438edd1f171ffc66276202a95\")\n).send();\nbyte[] nonce = response.getNonce();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-account-block-list","title":"Get Account Block List","text":"<p>Get a list of account blocks in descending order of block height, starting from the latest block</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nAccountBlocksResponse response = vitej.getAccountBlocksByAddress(\n        // address of account\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\"),\n        // page index. start at 0\n        0,\n        // page size\n        10).send();\nList&lt;AccountBlock&gt; accountBlockList = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-account-block-by-height","title":"Get Account Block (by height)","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nAccountBlockResponse response = vitej.getAccountBlockByHeight(\n        // address of account\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\"),\n        // block height\n        1L).send();\nAccountBlock accountBlock = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-account-block-by-hash","title":"Get Account Block (by hash)","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nAccountBlockResponse response = vitej.getAccountBlockByHash(\n        // hash of account block\n        new Hash(\"c4b11ff481c5476945000993816794fbc21a315901aaecb523b503c19c133154\")).send();\nAccountBlock accountBlock = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-account-block-full-block","title":"Get Account Block (full block)","text":"<p>This method can be also used to return a full RS (Receive-Send) block by specifying RS block hash</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nAccountBlockResponse response = vitej.getCompleteAccountBlockByHash(\n        // hash of account block\n        new Hash(\"c4b11ff481c5476945000993816794fbc21a315901aaecb523b503c19c133154\")).send();\nAccountBlock accountBlock = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-the-latest-account-block","title":"Get the Latest Account Block","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nAccountBlockResponse response = vitej.getLatestAccountBlock(\n        // address of account\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\")).send();\nAccountBlock accountBlock = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-account-block-list-by-token-id","title":"Get Account Block List (by token id)","text":"<p>Get a list of account blocks in which the transfers are processed in certain token</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nAccountBlocksResponse response = vitej.getAccountBlocks(\n        // account address. must present\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\"),\n        // hash of account block to start from. If not present, use the latest account block\n        new Hash(\"c4b11ff481c5476945000993816794fbc21a315901aaecb523b503c19c133154\"),\n        // token id\n        CommonConstants.VITE_TOKEN_ID,\n        // number of item returned. must present\n        10\n).send();\nList&lt;AccountBlock&gt; accountBlockList = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-account-info","title":"Get Account Info","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nAccountInfoResponse response = vitej.getAccountInfoByAddress(\n        // address of account\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\")\n).send();\n// total transaction number\nLong blockCount = response.getResult().getBlockCount();\n// token-balance summary\nMap&lt;TokenId, AccountInfoResponse.BalanceInfo&gt; balanceInfoMap = response.getResult().getBalanceInfoMap();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-unreceived-transaction-list","title":"Get Unreceived Transaction List","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nAccountBlocksResponse response = vitej.getUnreceivedBlocksByAddress(\n        // account address\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\"),\n        // page index. start at 0\n        0,\n        // page size\n        10\n).send();\n// unreceived transaction list\nList&lt;AccountBlock&gt; accountBlockList = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-unreceived-transaction-summary","title":"Get Unreceived Transaction Summary","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nAccountInfoResponse response = vitej.getUnreceivedTransactionSummaryByAddress(\n        // account address\n        new Address(\"vite_098dfae02679a4ca05a4c8bf5dd00a8757f0c622bfccce7d68\")\n).send();\n// number of unreceived transaction\nLong blockCount = response.getResult().getBlockCount();\n// unreceived token-balance summary\nMap&lt;TokenId, AccountInfoResponse.BalanceInfo&gt; balanceInfoMap = response.getResult().getBalanceInfoMap();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-the-latest-snapshot-block-hash","title":"Get the Latest Snapshot Block Hash","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nLatestSnapshotHashResponse response = vitej.getLatestSnapshotHash().send();\nHash latestSnapshotHash = response.getHash();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-the-latest-snapshot-block-height","title":"Get the Latest Snapshot Block Height","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nSnapshotChainHeightResponse response = vitej.getSnapshotChainHeight().send();\nLong latestSnapshotHeight = response.getHeight();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-the-latest-snapshot-block","title":"Get the Latest Snapshot Block","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nSnapshotBlockResponse response = vitej.getLatestSnapshotBlock().send();\nSnapshotBlock snapshotBlock = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-snapshot-block-list","title":"Get Snapshot Block List","text":"<p>Get a list of snapshot blocks in descending order, starting at specified height</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nSnapshotBlocksResponse response = vitej.getSnapshotBlocks(\n        // height to start from\n        100L,\n        // number of item returned\n        10\n).send();\nList&lt;SnapshotBlock&gt; snapshotBlock = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-smart-contract-event-log","title":"Get Smart Contract Event Log","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nVmlogsResponse response = vitej.getVmlogs(\n        // hash of smart contract response block\n        new Hash(\"d519bd49599df00b6a5992a50065af7945c4b6af269af8791cca5688f3277e37\")\n).send();\nList&lt;Vmlog&gt; vmLogList = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-smart-contract-event-log-by-filter","title":"Get Smart Contract Event Log (by filter)","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\n// only get event log from account block height 1-10 on smart contract vite_000000000000000000000000000000000000000595292d996d\nVmLogFilter filter = new VmLogFilter(new Address(\"vite_000000000000000000000000000000000000000595292d996d\"),\n        1L, 10L);\n// define a topic to get event log which has two indexed fields as the value specified\nfilter.setTopics(Arrays.asList(\n        Collections.emptyList(),\n        Arrays.asList(new Hash(\"000000000000000000000000000000000000000000005649544520544f4b454e\"), new Hash(\"00000000000000000000000000000000000000000000564954455820434f494e\")),\n        Collections.emptyList()\n));\nVmlogInfosResponse response = vitej.getVmlogsByFilter(\n        filter\n).send();\nList&lt;VmLogInfo&gt; vmLogInfoList = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-smart-contract-info","title":"Get Smart Contract Info","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nContractInfoResponse response = vitej.getContractInfo(\n        new Address(\"vite_000000000000000000000000000000000000000595292d996d\")\n).send();\nContractInfo contractInfo = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#call-offchain-method","title":"Call Offchain Method","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\n// load abi of offchain method\nAbi abi = Abi.fromJson(\"[{\\\"inputs\\\":[],\\\"name\\\":\\\"getData\\\",\\\"outputs\\\":[{\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"type\\\":\\\"offchain\\\"}]\");\nString methodName = \"getData\";\n// call offchain method\nCallOffChainMethodResponse response = vitej.callOffChainMethod(\n        // contract address\n        new Address(\"vite_da0e4189f8155035d5b373f8f1328e43d7d70980f4fb69ff18\"),\n        // specify binary code of the offchain method. tips: use --bin to generate offchain binary when compiling soliditypp source code\n        BytesUtils.hexStringToBytes(\"6080604052600436106042576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063c1a34865146044576042565b005b604a6060565b6040518082815260200191505060405180910390f35b60006000600050549050606e565b9056fea165627a7a7230582098acc939ef119097e24d6b599d9dd18bb2061a9fab6ec77401def1c0a7e52ecd0029\"),\n        abi.encodeOffchain(methodName)\n).send();\n// use abi to decode result\nList&lt;?&gt; outputList = abi.decodeOffchainOutput(methodName, response.getReturnData());\nBigInteger output = ((BigInteger) outputList.get(0));\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-node-status","title":"Get Node Status","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nNetNodeInfoResponse response = vitej.netNodeInfo().send();\nNetNodeInfoResponse.Result nodeInfo = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-sync-status","title":"Get Sync Status","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nNetSyncInfoResponse response = vitej.netSyncInfo().send();\nNetSyncInfoResponse.Result nodeInfo = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#get-sync-detail","title":"Get Sync Detail","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nNetSyncDetailResponse response = vitej.netSyncDetail().send();\nNetSyncDetailResponse.Result nodeInfo = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/rpc/#call-raw-rpc-method","title":"Call Raw RPC Method","text":"<p>Instead of calling a wrapped method as listed above, you can also call a raw RPC method. Below code shows an example of calling RPC method <code>ledger_getAccountBlocksByAddress</code>. For more information about raw RPC API, see RPC API Documentation.</p> <pre><code>Vitej vitej = new Vitej(new HttpService());\nCommonResponse response = vitej.commonMethod(\"ledger_getAccountBlocksByAddress\", \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\",0,10).send();\nObject result = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/","title":"SBP &amp; Voting API","text":""},{"location":"SDK/vitej/modules/sbp/#register-new-sbp","title":"Register New SBP","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.registerSBP(keyPair, \"test_sbp\", keyPair.getAddress(), keyPair.getAddress());\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#update-block-producing-address","title":"Update Block Producing Address","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.updateSBPBlockProducingAddress(keyPair, \"test_sbp\", new Address(\"vite_098dfae02679a4ca05a4c8bf5dd00a8757f0c622bfccce7d68\"));\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#update-reward-withdrawal-address","title":"Update Reward Withdrawal Address","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.updateSBPRewardWithdrawAddress(keyPair, \"test_sbp\", new Address(\"vite_098dfae02679a4ca05a4c8bf5dd00a8757f0c622bfccce7d68\"));\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#withdraw-reward","title":"Withdraw Reward","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.withdrawSBPReward(keyPair, \"test_sbp\", new Address(\"vite_098dfae02679a4ca05a4c8bf5dd00a8757f0c622bfccce7d68\"));\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#cancel-sbp-registration","title":"Cancel SBP Registration","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.revokeSBP(keyPair, \"test_sbp\");\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#vote-for-sbp","title":"Vote for SBP","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.voteForSBP(keyPair, \"s1\");\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#cancel-voting","title":"Cancel Voting","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nRequest&lt;?, EmptyResponse&gt; request = vitej.cancelSBPVoting(keyPair);\nEmptyResponse response = request.send();\nPreconditions.checkArgument(response.getError() == null);\nPreconditions.checkArgument(ProtocolUtils.checkCallContractResult(vitej, ((TransactionParams) request.getParams().get(0)).getHashRaw()));\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#get-sbp-summary-by-registration-address","title":"Get SBP Summary (by registration address)","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nSBPListResponse response = vitej.getSBPList(\n        // registration address\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\")\n).send();\n// return summary of sbp nodes registered by the address \nList&lt;SBPInfo&gt; sbpInfoList = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#query-available-reward-for-withdrawal","title":"Query Available Reward for Withdrawal","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nSBPRewardResponse response = vitej.getSBPRewardPendingWithdrawal(\n        // sbp name\n        \"Vite_SBP01\"\n).send();\nSBPRewardResponse.Result reward = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#get-sbp-summary-by-name","title":"Get SBP Summary (by name)","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nSBPResponse response = vitej.getSBP(\n        // sbp name\n        \"Vite_SBP01\"\n).send();\nSBPInfo sbpInfo = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#query-reward-details-in-cycle","title":"Query Reward Details in Cycle","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nSBPRewardDetailResponse response = vitej.getSBPRewardByCycle(\n        // cycle index. the first cycle (cycle 0) is from 20190521T12:00:00+08:00 to 20190522T12:00:00+08:00\n        1L\n).send();\nSBPRewardDetailResponse.Result rewardDetail = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#query-voting-details-in-cycle","title":"Query Voting Details in Cycle","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nSBPVoteDetailsResponse response = vitej.getSBPVoteDetailsByCycle(\n        // cycle index. the first cycle (cycle 0) is from 20190521T12:00:00+08:00 to 20190522T12:00:00+08:00\n        0L\n).send();\nList&lt;SBPVoteDetailsResponse.Result&gt; voteDetail = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/sbp/#get-voting-summary-by-address","title":"Get Voting Summary (by address)","text":"<pre><code>Vitej vitej = new Vitej(new HttpService());\nVotedSBPResponse response = vitej.getVotedSBP(\n        new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\")\n).send();\nVotedSBPResponse.Result votedSBP = response.getResult();\n</code></pre>"},{"location":"SDK/vitej/modules/subscribe/","title":"Subscription API","text":"<p>You must enable WebSocket service (default port 41420) on the node in order to use subscription API. </p>"},{"location":"SDK/vitej/modules/subscribe/#listen-to-new-snapshot-block","title":"Listen to New Snapshot Block","text":"<pre><code>WebSocketService ws = new WebSocketService();\nws.connect();\nVitej vitej = new Vitej(ws);\nvitej.snapshotBlockFlowable().subscribe(msg -&gt; {\n    System.out.println(\"snapshotBlock: \" + JSON.toJSONString(msg));\n});\n</code></pre>"},{"location":"SDK/vitej/modules/subscribe/#listen-to-new-account-block","title":"Listen to New Account Block","text":"<pre><code>WebSocketService ws = new WebSocketService();\nws.connect();\nVitej vitej = new Vitej(ws);\nvitej.accountBlockFlowable().subscribe(msg -&gt; {\n    System.out.println(\"accountBlock: \" + JSON.toJSONString(msg));\n});\n</code></pre>"},{"location":"SDK/vitej/modules/subscribe/#listen-to-new-account-block-by-address","title":"Listen to New Account Block (by address)","text":"<pre><code>WebSocketService ws = new WebSocketService();\nws.connect();\nVitej vitej = new Vitej(ws);\nvitej.accountBlockByAddressFlowable(new Address(\"vite_000000000000000000000000000000000000000595292d996d\")).subscribe(msg -&gt; {\n    System.out.println(\"accountBlockByAddress: \" + JSON.toJSONString(msg));\n});\n</code></pre>"},{"location":"SDK/vitej/modules/subscribe/#listen-to-new-unreceived-transaction","title":"Listen to New Unreceived Transaction","text":"<pre><code>WebSocketService ws = new WebSocketService();\nws.connect();\nVitej vitej = new Vitej(ws);\nvitej.unreceivedBlockFlowable(new Address(\"vite_000000000000000000000000000000000000000595292d996d\")).subscribe(msg -&gt; {\n    System.out.println(\"unreceivedBlock: \" + JSON.toJSONString(msg));\n});\n</code></pre>"},{"location":"SDK/vitej/modules/subscribe/#listen-to-new-smart-contract-event","title":"Listen to New Smart Contract Event","text":"<pre><code>WebSocketService ws = new WebSocketService();\nws.connect();\nVitej vitej = new Vitej(ws);\nvitej.vmlogFlowable(new VmLogFilter(new Address(\"vite_000000000000000000000000000000000000000595292d996d\"))).subscribe(msg -&gt; {\n    System.out.println(\"vmlog: \" + JSON.toJSONString(msg));\n});\n</code></pre>"},{"location":"SDK/vitej/modules/utils/","title":"Utility API","text":""},{"location":"SDK/vitej/modules/utils/#determine-block-type","title":"Determine Block Type","text":"<pre><code>// determine block type based on 'blockType' field\nBoolean isSendBlock = BlockUtils.isSendBlock(EBlockType.SEND_CALL.getValue());\nBoolean isReceiveBlock = BlockUtils.isReceiveBlock(EBlockType.RECEIVE.getValue());\n// determine block type directly\nAccountBlock accountBlock = ...;\nBoolean isSendBlock = accountBlock.isSendBlock();\nBoolean isReceiveBlock = accountBlock.isReceiveBlock();\n</code></pre>"},{"location":"SDK/vitej/modules/utils/#check-contract-execution-result","title":"Check Contract Execution Result","text":"<p>The method consists of the following steps:</p> <ol> <li>Look up for the account block that <code>sendBlockHash</code> refers to. If it doesn't exist, return <code>false</code>;</li> <li>Verify if the request transaction contained in send block is valid contract call transaction (<code>toAddress</code> is contract address and block type is <code>SEND_CALL</code> or <code>SEND_CREATE</code>). Return <code>false</code> if no;</li> <li>Check if the request has been accepted by smart contract (valid <code>receiveBlockHash</code> is contained in send block). If no, loop for up to 10 times retry by default until correct <code>receiveBlockHash</code> is set. If maximum retry is reached and <code>receiveBlockHash</code> is still not set, return <code>false</code>; </li> </ol> <p>Tip</p> <p>The possible reason could be contract is short of quota, or <code>ResponseLatency</code>/<code>randomDegree</code> for the contract is too high so that in-coming request can only be accepted after certain waiting number is reached.</p> <ol> <li>Confirm the smart contract is executed as expected (value of the 33th byte of data field of response transaction should be <code>0</code>; any non-zero value indicates execution failure). If the value is not zero, return <code>false</code>;</li> <li>Confirm all in-contract request transactions (RS blocks) are executed successfully, if any. Then return <code>true</code>.</li> </ol> <pre><code>Vitej vitej = new Vitej(new HttpService());\nHash sendBlockHash = new Hash(\"7683bbc8be1391172ed21cc1fe0843ac3b1311109aa329601b73f717e6a93b53\");\n// use default retry times (=10)\nboolean success = ProtocolUtils.checkCallContractResult(vitej, sendBlockHash);\n// use retry times 15\nboolean success = ProtocolUtils.checkCallContractResult(vitej, sendBlockHash, 15);\n</code></pre>"},{"location":"SDK/vitej/modules/utils/#abi-encoding-decoding","title":"ABI Encoding / Decoding","text":"<pre><code>// parse from JSON string\nAbi abi = Abi.fromJson(\"[\" +\n        \"{\\\"type\\\":\\\"function\\\",\\\"name\\\":\\\"voteForSBP\\\", \\\"inputs\\\":[{\\\"name\\\":\\\"sbpName\\\",\\\"type\\\":\\\"string\\\"}]},\" +\n        \"{\\\"type\\\":\\\"offchain\\\",\\\"name\\\":\\\"getVotes\\\", \\\"inputs\\\":[{\\\"name\\\":\\\"voteAddress\\\",\\\"type\\\":\\\"address\\\"}], \\\"outputs\\\":[{\\\"name\\\":\\\"sbpName\\\",\\\"type\\\":\\\"string\\\"}]},\" +\n        \"{\\\"type\\\":\\\"event\\\",\\\"name\\\":\\\"VoteForSBP\\\", \\\"inputs\\\":[{\\\"name\\\":\\\"sbpName\\\",\\\"type\\\":\\\"string\\\"},{\\\"name\\\":\\\"voteAddress\\\",\\\"type\\\":\\\"address\\\"}]}\" +\n        \"]\");\n// select function by name\nAbi.Function functionByName = abi.findFunctionByName(\"voteForSBP\");\n// encode function call, passing in one parameter 'Vite_SBP01'\nbyte[] encodedFunctionData1 = functionByName.encode(\"Vite_SBP01\");\nbyte[] encodedFunctionData2 = abi.encodeFunction(\"voteForSBP\", \"Vite_SBP01\");\n// select function by encoded data\nAbi.Function functionByData = abi.findFunctionByData(encodedFunctionData1);\n// decode from data\nList&lt;?&gt; decodedFunctionParams = functionByData.decode(encodedFunctionData1);\nList&lt;?&gt; decodedFunctionParams2 = abi.decodeFunction(encodedFunctionData1);\n\n// select getter function by name\nAbi.Offchain offchainByName = abi.findOffchainByName(\"getVotes\");\n// encode getter function to look into the data field of a smart contract\nbyte[] encodedOffchainData1 = offchainByName.encode(new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\"));\nbyte[] encodedOffchainData2 = abi.encodeOffchain(\"getVotes\", new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\"));\n// decode return value\nList&lt;?&gt; decodedOffchainParams = abi.decodeOffchainOutput(\"getVotes\", BytesUtils.hexStringToBytes(\"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000a566974655f534250303100000000000000000000000000000000000000000000\"));\n\n// find event by name\nAbi.Event eventByName = abi.findEventByName(\"VoteForSBP\");\n// find event by topics\nList&lt;Hash&gt; eventTopics = Arrays.asList(new Hash(\"afa4799f2c9e07964e722c02e1c5b6f1a84aca56854e5b0eba69c2a067843cd1\"));\nAbi.Event eventByTopics = abi.findEventByTopics(eventTopics);\n// decode smart contract event\nbyte[] eventData = BytesUtils.hexStringToBytes(\"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000996e651f3885e6e6b83dfba8caa095ff7aa248e00000000000000000000000000000000000000000000000000000000000000000a566974655f534250303100000000000000000000000000000000000000000000\");\nList&lt;?&gt; decodedEventParams1 = eventByTopics.decode(eventData, eventTopics);\nList&lt;?&gt; decodedEventParams2 = abi.decodeEvent(eventData, eventTopics);\n</code></pre>"},{"location":"SDK/vitej/modules/wallet/","title":"Wallet API","text":"<p>In ViteJ, a wallet instance contains a mnemonic phrase, and is able to derive up to 100 public/private key pairs. One private key uniquely determines a Vite address.</p>"},{"location":"SDK/vitej/modules/wallet/#wallet-instance","title":"Wallet Instance","text":"<pre><code>// create new wallet instance\nWallet wallet0 = new Wallet();\n// recover wallet from mnemonic phrase\nWallet wallet1 = new Wallet(Arrays.asList(\"network\",\"north\",\"tell\",\"potato\",\"predict\",\"almost\",\"wonder\",\"spirit\",\"wheel\",\"smile\",\"disease\",\"bonus\",\"round\",\"flock\",\"pole\",\"review\",\"music\",\"oven\",\"clarify\",\"exclude\",\"loyal\",\"episode\",\"image\",\"notable\"));\nWallet wallet2 = new Wallet(\"network north tell potato predict almost wonder spirit wheel smile disease bonus round flock pole review music oven clarify exclude loyal episode image notable\");\n// export mnemonic phrase from wallet\nList&lt;String&gt; mnemonic = wallet.getMnemonic();\n</code></pre>"},{"location":"SDK/vitej/modules/wallet/#address-derivation","title":"Address Derivation","text":"<pre><code>// address 0\nKeyPair keyPair0 = wallet.deriveKeyPair();\n// address 1\nKeyPair keyPair1 = wallet.deriveKeyPair(1);\n</code></pre>"},{"location":"SDK/vitej/modules/wallet/#key-pairs","title":"Key Pairs","text":"<pre><code>// get public key\nbyte[] publicKey = keyPair.getPublicKey();\n// get private key\nbyte[] privateKey = keyPair.getPrivateKey();\n// get address\nAddress address = keyPair.getAddress();\n</code></pre>"},{"location":"SDK/vitej/modules/wallet/#signature-and-verification","title":"Signature and Verification","text":"<pre><code>byte[] message = BytesUtils.hexStringToBytes(\"7683bbc8be1391172ed21cc1fe0843ac3b1311109aa329601b73f717e6a93b53\");\n// sign\nbyte[] signedData = keyPair.sign(message);\n// verify signature\nboolean verified = Crypto.verify(signedData, message, keyPair.getPublicKey());\n</code></pre>"},{"location":"SDK/vitej/other/","title":"Other","text":""},{"location":"SDK/vitej/other/faq/","title":"Useful Links","text":""},{"location":"SDK/vitej/other/faq/#development-node","title":"Development Node","text":"<p>See Run a Local Dev Node - a guide to setup a local development node.</p>"},{"location":"SDK/vitej/other/faq/#dag-ledger","title":"DAG Ledger","text":"<p>Vite DAG Ledger introduces the design of DAG-based ledger of Vite.</p>"},{"location":"SDK/vitej/other/faq/#quota","title":"Quota","text":"<p>Quota are consumed in Vite for sending/receiving transactions. To obtain quota, you can choose to solve a simple PoW puzzle or stake VITE coin (recommended). For more information, please see Quota Introduction.</p>"},{"location":"SDK/vitej/other/faq/#wallet","title":"Wallet","text":"<p>Wallet manages mnemonic phrase and up to 100 addresses/private-keys that are derived from the mnemonic phrase.</p>"},{"location":"SDK/vitej/other/faq/#rpc-api","title":"RPC API","text":"<p>See Vite RPC API Documentation.</p>"},{"location":"SDK/vitej/other/faq/#common-rpc-errors","title":"Common RPC Errors","text":"<p>Common RPC Errors</p> <p>Common Business Errors</p>"},{"location":"SDK/vitej/other/types/","title":"Common Types","text":""},{"location":"SDK/vitej/other/types/#class","title":"Class","text":""},{"location":"SDK/vitej/other/types/#address","title":"Address","text":"<p>Address of account <pre><code>// create address object\nAddress address = new Address(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\");\nAddress address = Address.stringToAddress(\"vite_0996e651f3885e6e6b83dfba8caa095ff7aa248e4a429db7bd\");\n// is a user address?\nboolean isUser = address.isUser();\n// is a contract? \nboolean isContact = address.isContract();\n</code></pre></p>"},{"location":"SDK/vitej/other/types/#tokenid","title":"TokenId","text":"<p>Token ID <pre><code>// create token ID\nTokenId tokenId = new TokenId(\"tti_5649544520544f4b454e6e40\");\nTokenId tokenId = TokenId.stringToTokenId(\"tti_5649544520544f4b454e6e40\");\n</code></pre></p>"},{"location":"SDK/vitej/other/types/#hash","title":"Hash","text":"<p>32-byte Blake2b hash <pre><code>// create hash object\nHash hash = new Hash(\"7683bbc8be1391172ed21cc1fe0843ac3b1311109aa329601b73f717e6a93b53\");\nHash hash = Hash.stringToHash(\"7683bbc8be1391172ed21cc1fe0843ac3b1311109aa329601b73f717e6a93b53\");\n// generate hash of a byte string\nbyte[] data = BytesUtils.hexStringToBytes(\"7683bbc8be1391172ed21cc1fe0843ac3b1311109aa329601b73f717e6a93b53\");\nHash dataHash = Hash.dataToHash(data);\n</code></pre></p>"},{"location":"SDK/vitej/other/types/#constant","title":"Constant","text":"<pre><code>// VITE token ID\nTokenId VITE_TOKEN_ID = new TokenId(\"tti_5649544520544f4b454e6e40\");\n// Address of built-in smart contract (quota) \nAddress ADDRESS_QUOTA_CONTRACT = new Address(\"vite_0000000000000000000000000000000000000003f6af7459b9\");\n// Address of built-in smart contract (governance) \nAddress ADDRESS_GOVERNANCE_CONTRACT = new Address(\"vite_0000000000000000000000000000000000000004d28108e76b\");\n// Address of built-in smart contract (asset) \nAddress ADDRESS_ASSET_CONTRACT = new Address(\"vite_000000000000000000000000000000000000000595292d996d\");\n// ABI of built-in smart contract (quota) \nAbi ABI_QUOTA_CONTRACT = Abi.fromJson(ABI_JSON_QUOTA_CONTRACT);\n// ABI of built-in smart contract (governance) \nAbi ABI_GOVERNANCE_CONTRACT = Abi.fromJson(ABI_JSON_GOVERNANCE_CONTRACT);\n// ABI of built-in smart contract (asset) \nAbi ABI_ASSET_CONTRACT = Abi.fromJson(ABI_JSON_ASSET_CONTRACT);\n</code></pre>"},{"location":"SDK/vitejs/","title":"Overview","text":"<p>Vite.js is a collection of Javascript libraries that allows you to interact with a local or remote Vite node using HTTP, IPC or WebSocket.</p> <p>Vite.js mainly provides:</p> <ul> <li>Basic functions, such as network connection, abi resolution, data encoding/decoding, address derivation, etc.</li> <li>Wrapped full node RPC API, such as event monitoring, fetching transactions, sending various types of transactions, etc.</li> <li>Utility functions, such as generating wallets with mnemonic phrases, validating an Ed25519 signature, etc.</li> <li>Advanced usage, including auto-receiving transactions, subscriptions, batch transactions, etc.</li> </ul> <p>With Vite.js, you can easily generate or restore wallets, send or receive transactions, read data from the blockchain, call smart contracts, interact with dapps, and more.</p>"},{"location":"SDK/vitejs/#installation","title":"Installation","text":"<p>Vite.js is broken up into a few modules. Many of these can be imported from the top package <code>@vite/vitejs</code>; however some require you to install a separate package. Run the following command in your terminal to install the packages used in this documentation.</p> <pre><code>npm i @vite/vitejs\n</code></pre> <p>Starting from 2.3.19, all the modules are consolidated into <code>@vite/vitejs</code>.</p> <p>Starting from 2.4.0, the following packages will no longer be published. The related resources should be imported from <code>@vite/vitejs</code> instead. * @vite/vitejs-abi * @vite/vitejs-accountblock * @vite/vitejs-communication * @vite/vitejs-constant * @vite/vitejs-error * @vite/vitejs-http * @vite/vitejs-ipc * @vite/vitejs-utils * @vite/vitejs-viteapi * @vite/vitejs-wallet * @vite/vitejs-ws</p>"},{"location":"SDK/vitejs/abi/","title":"ABI","text":""},{"location":"SDK/vitejs/abi/#module-import","title":"Module Import","text":"<pre><code>import { abi } from '@vite/vitejs';\n</code></pre>"},{"location":"SDK/vitejs/abi/#method-types","title":"Method Types","text":"Type Description <code>constructor</code> Contract constructor <code>function</code> Solidity++ functions <code>event</code> Event method, to write a log on the blockchain <code>offchain</code> Legacy offchain method, replaced by <code>view function</code> in Solidity++ 0.8"},{"location":"SDK/vitejs/abi/#parameter-types","title":"Parameter Types","text":"<p>Methods of contract, including constructors and functions, may have passed-in parameters and return values. The following table shows the data types that are supported on Vite.</p> Type Description Example <code>uint&lt;M&gt;</code> Unsigned integer (0 &lt; M \u2264 256, M % 8 = 0) <code>uint256</code> '2345675643' <code>int&lt;M&gt;</code> Signed integer (0 &lt; M \u2264 256, M % 8 = 0) int8 '2' <code>uint</code> Equivalence of <code>uint256</code> <code>uint</code> '2345675643' <code>int</code> Equivalence of  <code>int256</code> <code>int</code> '2' <code>tokenId</code> Token id <code>tokenId</code> 'tti_5649544520544f4b454e6e40' <code>address</code> Address of account <code>address</code> 'vite_010000000000000000000000000000000000000063bef3da00' <code>gid</code> Consensus group id <code>gid</code> '01000000000000000000' <code>bool</code> Boolean <code>bool</code> true <code>bytes&lt;M&gt;</code> Fixed-length byte array (0 &lt; M &lt;= 32) <code>bytes32</code> '0x0100000000000000000000000000000000000000000000000000000000000000' <code>bytes</code> Variable-length byte array <code>bytes</code> '0xdf3234' <code>string</code> Variable-length string <code>string</code> 'foobar' <code>&lt;type&gt;[M]</code> Fixed-length array of type M (M &gt;= 0). Range of values:<code>uint&lt;M&gt;</code>, <code>int&lt;M&gt;</code>, <code>uint</code>, <code>int</code>, <code>tokenId</code>, <code>address</code>, <code>gid</code>, <code>bool</code> and <code>string</code> <code>uint8[2]</code> ['1','2'] <code>&lt;type&gt;[]</code> Variable-length array of type M. Range of values: <code>uint&lt;M&gt;</code>, <code>int&lt;M&gt;</code>, <code>uint</code>, <code>int</code>, <code>tokenId</code>, <code>address</code>, <code>gid</code>, <code>bool</code> and <code>string</code> <code>uint256[]</code> ['1','2']"},{"location":"SDK/vitejs/abi/#type-jsoninterface","title":"Type <code>jsonInterface</code>","text":"<p><code>jsonInterface</code> is a JSON object that represents a valid ABI. The following example defines an event named Register. <pre><code>{\n    \"type\": \"event\",\n    \"name\": \"Register\",\n    \"inputs\": [\n        { \"name\": \"user\", \"type\": \"address\" }\n    ]\n}\n</code></pre></p>"},{"location":"SDK/vitejs/abi/#methods","title":"Methods","text":""},{"location":"SDK/vitejs/abi/#encodelogsignature","title":"<code>encodeLogSignature</code>","text":"<p>Encode an event signature. The ABI must be a type of 'event' or an array contains such a type. - Parameters     - <code>jsonInterface | jsonInterface[]</code> ABI     - <code>methodName?: string</code> Method to encode - required if the first parameter is a <code>jsonInterface</code> array. - Returns     - <code>Hex</code> Encoded hex string - Example <pre><code>let result1 = abi.encodeLogSignature({\n    'type':'event', 'name': 'balance', 'inputs':[{'name':'in','type':'uint256'}]\n}); // 8a3390b86e28f274e3a88354b3b83cf0f8780a1f0975f629966bd2a2d38eb188\n\nlet result2 = abi.encodeLogSignature([\n    {'type':'event','name':'heck','inputs':[{'name':'t','type':'address'}]},\n    {'type':'event','name':'check','inputs':[{'name':'t','type':'address'},{'name':'b','type':'uint256'}]},\n    {'type':'event','name':'eck','inputs':[]},\n], 'check'); // 17c53855485cba60b5dea781a996394bb9d3b44bc8932b3adf79ac70e908b220\n</code></pre></p>"},{"location":"SDK/vitejs/abi/#encodefunctionsignature","title":"<code>encodeFunctionSignature</code>","text":"<p>Encode a function signature. The ABI must be a type of 'function' or 'constructor', or an array contains such a type. - Parameters     - <code>jsonInterface | jsonInterface[]</code> ABI     - <code>methodName?: string</code> Method to encode - required if the first parameter is a <code>jsonInterface</code> array. - Returns     - <code>Hex</code> Encoded hex string - Example <pre><code>let result = abi.encodeFunctionSignature({\n    'type':'function', 'name':'singleParam', 'inputs':[{'name':'param1','type':'address'}]\n}); // 053f71a4\n</code></pre></p>"},{"location":"SDK/vitejs/abi/#encodefunctioncall","title":"<code>encodeFunctionCall</code>","text":"<p>Encode a function call. The ABI must be a type of 'function' or 'constructor', or an array contains such a type. - Parameters     - <code>jsonInterface | jsonInterface[]</code> ABI     - <code>params</code> Input parameters     - <code>methodName?: string</code> Method to encode - required if the first parameter is a <code>jsonInterface</code> array. - Returns     - <code>Hex</code> Encoded hex string - Example <pre><code>// Use ABI\nlet result = abi.encodeFunctionCall({\n    name:'myMethod', type:'function', inputs:[{type:'uint256', name: 'myNumber'}, {type:'string', name:'myString'}]\n}, ['2345675643', 'Hello!%']); // 96173f6c000000000000000000000000000000000000000000000000000000008bd02b7b0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000748656c6c6f212500000000000000000000000000000000000000000000000000\n\n// Use ABI string\nlet result1 = abi.encodeFunctionCall([\n    {name:'myMethod', type:'function', inputs:[{type:'uint256', name: 'myNumber'}, {type:'string', name:'myString'}]},\n    {name:'myMethod2', type:'function', inputs:[{type:'uint256', name: 'myNumber'}, {type:'string', name:'myString'}]}\n], ['2345675643', 'Hello!%'], 'myMethod2'); // 96173f6c000000000000000000000000000000000000000000000000000000008bd02b7b0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000748656c6c6f212500000000000000000000000000000000000000000000000000\n</code></pre></p>"},{"location":"SDK/vitejs/abi/#encodeparameter","title":"<code>encodeParameter</code>","text":"<p>Encode input parameter according to parameter type - Parameters     - <code>type</code> See Parameter Types     - <code>params</code> Input parameters - Returns     - <code>Hex</code> Encoded hex string - Example <pre><code>let result = abi.encodeParameter('uint256', '2345675643'); // 000000000000000000000000000000000000000000000000000000008bd02b7b\n\nlet result2 = abi.encodeParameter('uint16[]', [1, 2]); // 000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002\n</code></pre></p>"},{"location":"SDK/vitejs/abi/#decodeparameter","title":"<code>decodeParameter</code>","text":"<p>Decode input parameter according to type - Parameters     - <code>type</code> See Parameter Types     - <code>Hex</code> Encoded hex string - Returns     - <code>decodeResult</code> Decoded results - Example <pre><code>let result = abi.decodeParameter(\n    'uint256',\n    '000000000000000000000000000000000000000000000000000000008bd02b7b',\n); // 2345675643\n\nlet result2 = abi.decodeParameter(\n    'uint8[]',\n    '000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002',\n); // ['1','2']\n</code></pre></p>"},{"location":"SDK/vitejs/abi/#encodeparameters","title":"<code>encodeParameters</code>","text":"<p>Encode input parameters according to ABI or parameter type - Parameters     - <code>jsonInterface | string[] | jsonInterface[]</code> ABI or parameter types     - <code>params&lt;Array | json-string&gt;</code> Input parameters     - <code>methodName?: string</code> Method to encode - required if the first parameter is an ABI array. - Returns     - <code>Hex</code> Encoded hex string - Example <pre><code>// Use ABI\nlet result = abi.encodeParameters({\n    type:'constructor', inputs:[{type:'uint8[]'}, {type:'bytes'}]\n}, [['34','43'], '324567ff']); // 000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000002b0000000000000000000000000000000000000000000000000000000000000004324567ff00000000000000000000000000000000000000000000000000000000\n\n// Use ABI and JSON string\nlet result1 = abi.encodeParameters({\n    type:'constructor', inputs:[{type:'uint8[]'}, {type:'bytes'}]\n}, JSON.stringify([['34', '43'], '324567ff'])); // 000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000002b0000000000000000000000000000000000000000000000000000000000000004324567ff00000000000000000000000000000000000000000000000000000000\n\n// Use type stings\nlet result2 = abi.encodeParameters(\n    ['tokenId', 'address'],\n    ['tti_01000000000000000000fb5e', 'vite_010000000000000000000000000000000000000063bef3da00']); // 00000000000000000000000000000000000000000000010000000000000000000000000000000000000000010000000000000000000000000000000000000000\n\n// Use ABI array\nlet result3 = abi.encodeParameters([\n    {'type':'constructor', 'name': 'myMethods', 'inputs':[{'type':'uint8[]'}, {'type': 'bytes'}]},\n    {'type':'constructor', 'name': 'myMethods2', 'inputs':[{'type': 'bytes'}]},\n    {'type':'constructor', 'name': 'myMethods3', 'inputs':[{'type':'uint8[]'}, {'type': 'bytes'}]},\n    {'type':'constructor', 'name': 'myMethods4', 'inputs':[{'type': 'bytes'}]}\n], [['34','43'], '324567ff'], 'myMethods3'); // 000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000002b0000000000000000000000000000000000000000000000000000000000000004324567ff00000000000000000000000000000000000000000000000000000000\n</code></pre></p>"},{"location":"SDK/vitejs/abi/#decodeparameters","title":"<code>decodeParameters</code>","text":"<p>Decode input parameters according to ABI or parameter type - Parameters     - <code>types: jsonInterface | string[] | jsonInterface[]</code> ABI or parameter types     - <code>params: Hex</code> Encoded hex string     - <code>methodName?: string</code> Method to decode - required if the first parameter is an array. - Returns     - <code>any[]</code> Decoded results - Example <pre><code>// Use ABI\nlet result1 = abi.decodeParameters({\n    type:'constructor', inputs:[{ type:'uint8[]'}, {type:'bytes'}]\n},'000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000002b0000000000000000000000000000000000000000000000000000000000000004324567ff00000000000000000000000000000000000000000000000000000000'); // [['34','43'], '324567ff']\n\n// Use type strings\nlet result2 = abi.decodeParameters(\n    ['string', 'tokenId', 'address'],\n    '000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f343832393438326e73646b6a736b640000000000000000000000000000000000'); // ['4829482nsdkjskd', 'tti_01000000000000000000fb5e', 'vite_00010000000000000000000000000000000000005cce05dbde']\n\n// Use ABI array\nlet result3 = abi.decodeParameters([\n    {type:'function', name:'singl', inputs:[{name:'param1', type:'address'}]},\n    {type:'function', name:'singleParam', inputs:[{name:'param1', type:'address'}, {name:'param1', type:'uint8[]'}]},\n],'00000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002', 'singleParam'); // ['vite_00010000000000000000000000000000000000005cce05dbde', [1,2]]\n</code></pre></p>"},{"location":"SDK/vitejs/abi/#decodelog","title":"<code>decodeLog</code>","text":"<p>Decode event logs according to ABI. The ABI must be a type of 'event' or an array contains such a type. - Parameters     - <code>abi: jsonInterface.inputs | jsonInterface | jsonInterface[]</code> ABI     - <code>data?: Hex = ''</code> Encoded hex string     - <code>topics: Hex[]</code> Event topics     - <code>methodName?: string</code> Method to decode - required if the first parameter is a <code>jsonInterface</code> array. - Returns     - <code>decodeResult: object</code> Decoded result in JSON - Example <pre><code>const decodeResult = abi.decodeLog({\n    'anonymous':false, 'inputs':[{'indexed':false, 'internalType':'string', 'name':'data', 'type':'string'}], 'name':'Event1', 'type':'event'},\n'0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000b68656c6c6f20776f726c64000000000000000000000000000000000000000000', ['30e00162ff22a0d2aaa98f7013fc6dcb0bfae6a56ed30e35c5ea19326211a1a9'], 'Event1');\n\nassert.deepEqual(decodeResult, {\n    '0': 'hello world',\n    data: 'hello world'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/abi/#getabibytype","title":"<code>getAbiByType</code>","text":"<p>Return matched ABI according to method type, or return null if the type is not found</p> <p>Note: this method returns the first result matched the given type - Parameters     - <code>jsonInterface | jsonInterface[]</code> ABI     - <code>type</code> See Method Types - Returns     - <code>jsonInterface</code> ABI - Example <pre><code>const result = abi.getAbiByType([\n    {type:'constructor', inputs:[{name:'addr', type:'address'}]},\n    {type:'function', name:'setIndex', inputs:[{name:'addr', type:'address'}, {name:'index', type:'uint8[]'}]},\n], 'function');\n</code></pre></p>"},{"location":"SDK/vitejs/abi/#getabibyname","title":"<code>getAbiByName</code>","text":"<p>Return matched ABI according to method name, or return null if the method is not found</p> <ul> <li>Parameters<ul> <li><code>jsonInterface | jsonInterface[]</code> ABI</li> <li><code>methodName</code> Method name</li> </ul> </li> <li>Returns<ul> <li><code>jsonInterface</code> ABI</li> </ul> </li> <li>Example <pre><code>const result = abi.getAbiByName([\n    {type:'constructor', inputs:[{name:'addr', type:'address'}]},\n    {type:'function', name:'setIndex', inputs:[{name:'addr', type:'address'}, {name:'index', type:'uint8[]'}]},\n], 'addr');\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/common-patterns/","title":"Common Patterns","text":"<p>In this chapter, we will cover the common use cases for ViteJS with examples, but first, in order to interact with the Vite network, you will need to create a connection.</p> <pre><code>import { ViteAPI } from '@vite/vitejs';\nimport WS_RPC from '@vite/vitejs-ws';\nconst providerWsURLs = {\n    localnet: 'ws://localhost:23457',\n    testnet: 'wss://buidl.vite.net/gvite/ws',\n    mainnet: 'wss://node.vite.net/gvite/ws',\n};\nconst provider = new WS_RPC(providerWsURLs.mainnet);\nconst viteApi = new ViteAPI(provider, () =&gt; {\n    console.log('connected');\n});\n</code></pre>"},{"location":"SDK/vitejs/common-patterns/#how-to-build-a-transaction","title":"How to build a transaction","text":"<p>The first step in building a transaction is to create a send block with the account you intend to send from. In this example, we are making a block to issue a new token and signing it with an existing account (with at least 1000 VITE already in it as token issuance fee).</p> <pre><code>import { wallet, accountBlock } from '@vite/vitejs';\nconst myWallet = wallet.getWallet(mnenomics);\n// or if you need to create a new wallet\n// const myWallet = wallet.createWallet();\n\nconst account = myWallet.deriveAddress(0);\n\nconst block = accountBlock.createAccountBlock('issueToken', {\n    address: account.address,\n    tokenName: \"Test Token\",\n    isReIssuable: true,\n    maxSupply: 100000000,\n    totalSupply: 100000000,\n    isOwnerBurnOnly: false,\n    decimals: 2,\n    tokenSymbol: \"TEST\",\n});\nblock.setProvider(viteApi); // this allow ViteJS to interact with the network\nblock.setPrivateKey(account.privateKey);\nawait block.autoSend();\n</code></pre>"},{"location":"SDK/vitejs/common-patterns/#how-to-stake-for-quota","title":"How to stake for quota","text":"<p>Quota is used for \"paying\" transaction fees instead of spending additional funds; this is how Vite transactions are fee-less. Quota is consumed when sending account blocks. An account's quota recharges over time and you can get a higher quota limit by staking more Vite tokens. It's possible to send transactions without having any quota by using proof of work, but this is not recommended.</p> <pre><code>const block = accountBlock.createAccountBlock('stakeForQuota', {\n    address: account.address,\n    beneficiaryAddress: account.address, // or any other address that you want to give quota to\n    // 134 Vite is the minimum staking amount for quota\n    amount: '134000000000000000000',\n});\nblock.setProvider(viteApi); // this allows ViteJS to interact with the network\nblock.setPrivateKey(account.privateKey);\nawait block.autoSend();\n\n// Check quota of the account\nviteApi.request('contract_getQuotaByAccount', address)\n    .then(result =&gt; {\n        console.log(result);\n    })\n    .catch(err =&gt; {\n        console.warn(err);\n    });\n</code></pre>"},{"location":"SDK/vitejs/common-patterns/#how-to-send-funds-to-an-address","title":"How to send funds to an address","text":"<p>Creating other kinds of transactions is fairly similar to the previous example. The main difference is the method name as the first argument and the parameters as the second argument. For the full list of methods and corresponding parameters, read the section on Transaction Types.</p> <pre><code>const block = accountBlock.createAccountBlock('send', {\n    address: account.address,\n    toAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    amount: '1000000000000000000', // equal to 1 VITE since the Vite coin has 18 decimal points\n});\nblock.sign(account.privateKey);\nawait block.autoSend();\n</code></pre>"},{"location":"SDK/vitejs/common-patterns/#how-to-receive-a-transaction","title":"How to receive a transaction","text":"<p>There are two main ways of receiving transactions. The first way is to sign and send each receive block individually.</p> <pre><code>const block = accountBlock.createAccountBlock('receive', {\n    address: account.address,\n    sendBlockHash: '44e69ea04fe830c9075c01e46f102d0c543b4119ce13ec575aee2e96501049fc',\n});\nblock.setProvider(viteApi);\nblock.setPrivateKey(account.privateKey);\nawait block.autoSetPreviousAccountBlock();\nblock.sign(account.privateKey);\nawait block.autoSend();\n</code></pre> <p>The second and much simpler way is to create and start a <code>ReceiveAccountBlockTask</code>.</p> <pre><code>const receiveTask = new accountBlock.ReceiveAccountBlockTask({\n    address: account.address,\n    privateKey: account.privateKey,\n    provider: viteApi,\n});\nreceiveTask.start();\n</code></pre>"},{"location":"SDK/vitejs/common-patterns/#how-to-sign-a-transaction","title":"How to sign a transaction","text":"<p>As you may have noticed in previous examples, there are two main ways to sign a transaction (i.e. block). The first way is to set the private key of the block and call certain methods that sign the block for you. The second way is to call the <code>sign</code> method which will sign the transaction, but won't send the block to the network.</p> <pre><code>block.setPrivateKey(privateKey);\n// This sets the block's previous block hash and other parameters needed to make a valid block\nawait block.autoSetPreviousAccountBlock();\n\nblock.sign(privateKey);\nawait block.autoSend();\n</code></pre>"},{"location":"SDK/vitejs/common-patterns/#how-to-deploy-a-contract","title":"How to deploy a contract","text":"<p>Deploying a contract is just like making any other transaction. For the parameters, the easiest way to get them is through the Solidity++ 0.8 Preview VS Code extension.</p> <pre><code>const block = accountBlock.createAccountBlock('createContract',{\n    abi:[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"SayHello\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"type\":\"event\"}],\n    code: '608060405234801561001057600080fd5b50610141806100206000396000f3fe608060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806391a6cb4b14610046575b600080fd5b6100896004803603602081101561005c57600080fd5b81019080803574ffffffffffffffffffffffffffffffffffffffffff16906020019092919050505061008b565b005b8074ffffffffffffffffffffffffffffffffffffffffff164669ffffffffffffffffffff163460405160405180820390838587f1505050508074ffffffffffffffffffffffffffffffffffffffffff167faa65281f5df4b4bd3c71f2ba25905b907205fce0809a816ef8e04b4d496a85bb346040518082815260200191505060405180910390a25056fea165627a7a7230582023e9669dd6fec3b6b2a84a1fd7c9939f49197203d0e1db312278e633c219c2480029',\n    responseLatency: 2,\n    params: ['vite_13f1f8e230f2ffa1e030e664e525033ff995d6c2bb15af4cf9'] // passed to the contract's constructor\n});\nblock.sign(account.privateKey);\nawait block.autoSend();\n</code></pre>"},{"location":"SDK/vitejs/common-patterns/#how-to-call-a-contract","title":"How to call a contract","text":"<p>Calling a contract's methods is just like sending funds, but with the addition of the contract's abi, method name, and arguments to pass.</p> <pre><code>let block = await accountBlock.createAccountBlock('callContract', {\n    address: account.address,\n    abi: contract.abi,\n    toAddress: contract.address,\n    params: ['method', 'params'],\n    methodName: 'methodName',\n    amount: '1000000000000000000',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n});\nblock.sign(account.privateKey);\nawait block.autoSend();\n</code></pre>"},{"location":"SDK/vitejs/common-patterns/#how-to-read-contract-event-logs","title":"How to read contract event logs","text":"<p>Getting a contract's event log first involves fetching them from a Vite node's RPC API. Then decoding them into a human-readable format.</p> <p>Note</p> <p>The following example has been adapted from the Vuilder Kit.</p> <pre><code>import { abi } from '@vite/vitejs';\n// ...\nconst getPastEvents = async (\n    eventName: string = 'allEvents',\n    {\n        fromHeight = 0,\n        toHeight = 0,\n    }: {\n        filter?: Object;\n        fromHeight?: Number;\n        toHeight?: Number;\n    }\n) =&gt; {\n    let result: any[] = [];\n    let logs = await viteApi.request('ledger_getVmLogsByFilter', {\n        addressHeightRange: {\n            [contract.address!]: {\n                fromHeight: fromHeight.toString(),\n                toHeight: toHeight.toString(),\n            },\n        },\n    });\n    const filteredAbi =\n        eventName === 'allEvents'\n            ? contract.abi\n            : contract.abi.filter((a: any) =&gt; {\n                    return a.name === eventName;\n              });\n    if (logs) {\n        for (let log of logs) {\n            let vmLog = log.vmlog;\n            let topics = vmLog.topics;\n            for (let abiItem of filteredAbi) {\n                let signature = abi.encodeLogSignature(abiItem);\n                if (abiItem.type === 'event' &amp;&amp; signature === topics[0]) {\n                    let dataHex;\n                    if (vmLog.data) {\n                        dataHex = Buffer.from(vmLog.data, 'base64').toString('hex');\n                    }\n                    let returnValues = abi.decodeLog(abiItem, dataHex, topics);\n                    let item = {\n                        returnValues: returnValues,\n                        event: abiItem.name,\n                        raw: {\n                            data: dataHex,\n                            topics: topics,\n                        },\n                        signature: signature,\n                        accountBlockHeight: log.accountBlockHeight,\n                        accountBlockHash: log.accountBlockHash,\n                        address: log.address,\n                    };\n                    result.push(item);\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n};\n</code></pre>"},{"location":"SDK/vitejs/common-patterns/#how-to-read-contract-state","title":"How to read contract state","text":"<p>Prior to Solidity++ 0.8, contracts had \"off-chain\" functions. These were used for querying the contracts written in Solidity++ 0.4. Starting in Solidity++ 0.8, off-chain methods were deprecated. Because of this, the RPC method for querying contracts written in 0.4 vs 0.8 are different - <code>contract_callOffChainMethod</code> and <code>contract_query</code> respectively.</p> <p>Note</p> <p>The following example has been adapted from the Vuilder Kit.</p> <pre><code>import { abi, utils } from '@vite/vitejs';\n// ...\nconst queryContract = async (methodName: string, params: any[]) =&gt; {\n    const methodAbi = contract.abi.find((x: { name: string }) =&gt; {\n        return x.name === methodName;\n    });\n    if (!methodAbi) {\n        throw new Error('method not found:' + methodName);\n    }\n    let data = abi.encodeFunctionCall(methodAbi, params);\n    let dataBase64 = utils._Buffer.from(data, 'hex').toString('base64');\n    let codeBase64;\n    if (contract.offchainCode &amp;&amp; contract.offchainCode.length &gt; 0)\n        codeBase64 = utils._Buffer.from(contract.offchainCode, 'hex').toString('base64');\n    while (true) {\n        let result = codeBase64\n            ? await viteApi.request('contract_callOffChainMethod', {\n                    address: contract.address,\n                    code: codeBase64,\n                    data: dataBase64,\n              })\n            : await viteApi.request('contract_query', {\n                    address: contract.address,\n                    data: dataBase64,\n              });\n        // parse result\n        if (result) {\n            let resultBytes = utils._Buffer.from(result, 'base64').toString('hex');\n            let outputs = [];\n            for (let i = 0; i &lt; methodAbi.outputs.length; i++) {\n                outputs.push(methodAbi.outputs[i].type);\n            }\n            return abi.decodeParameters(outputs, resultBytes);\n        }\n        console.log('Query failed, try again.');\n        await utils.sleep(500);\n    }\n};\n</code></pre> <p>Tips</p> <p>You can also use <code>callOffChainContract</code> and <code>queryContractState</code> in ViteAPI class.</p>"},{"location":"SDK/vitejs/constants-and-errors/","title":"Constants and Errors","text":"<p>The modules define the common constants and errors on Vite.</p>"},{"location":"SDK/vitejs/constants-and-errors/#module-import","title":"Module Import","text":"<pre><code>import { constant, error } from '@vite/vitejs';\nconst { Contracts, Vite_TokenId } = constant;\n</code></pre> <p>Note</p> <p>Starting from 2.3.19, all the modules are consolidated into <code>@vite/vitejs</code>.</p> <p>Note</p> <p>Starting from 2.4.0, the following packages will no longer be published. The related resources should be imported from <code>@vite/vitejs</code> instead.</p>"},{"location":"SDK/vitejs/constants-and-errors/#constants","title":"Constants","text":"<p>The constant module consist of the following information: * Token constants - VITE, VX  * Block types - See Block Types * Consensus groups - <code>Snapshot_Gid</code>, <code>Delegate_Gid</code> * Built-in smart contracts - See below     - Address constants     - ABI</p> Built-in Contract Name Description Address <code>Staking_ContractAddress</code> Quota management vite_0000000000000000000000000000000000000003f6af7459b9 <code>ConsensusGroup_ContractAddress</code> Governance vite_0000000000000000000000000000000000000004d28108e76b <code>TokenIssuance_ContractAddress</code> Token issuance vite_000000000000000000000000000000000000000595292d996d <code>DexFund_ContractAddress</code> ViteX - Asset management vite_0000000000000000000000000000000000000006e82b8ba657 <code>DexTrade_ContractAddress</code> ViteX - Order management vite_00000000000000000000000000000000000000079710f19dc7 <pre><code>export const Contracts = {\n    RegisterSBP_V1: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'Register', 'inputs': [ { 'name': 'gid', 'type': 'gid' }, { 'name': 'sbpName', 'type': 'string' }, { 'name': 'blockProducingAddress', 'type': 'address' } ] }\n    },\n    UpdateSBPBlockProducingAddress_V1: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'UpdateRegistration', 'inputs': [ { 'name': 'gid', 'type': 'gid' }, { 'name': 'name', 'type': 'string' }, { 'name': 'nodeAddr', 'type': 'address' } ] }\n    },\n    UpdateSBPBlockProducingAddress_V2: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'UpdateBlockProducingAddress', 'inputs': [ { 'name': 'gid', 'type': 'gid' }, { 'name': 'sbpName', 'type': 'string' }, { 'name': 'newBlockProducingAddress', 'type': 'address' } ] }\n    },\n    RevokeSBP_V1: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'CancelRegister', 'inputs': [ { 'name': 'gid', 'type': 'gid' }, { 'name': 'name', 'type': 'string' } ] }\n    },\n    RevokeSBP_V2: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'Revoke', 'inputs': [ { 'name': 'gid', 'type': 'gid' }, { 'name': 'sbpName', 'type': 'string' } ] }\n    },\n    WithdrawSBPReward_V1: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'Reward', 'inputs': [ { 'name': 'gid', 'type': 'gid' }, { 'name': 'name', 'type': 'string' }, { 'name': 'beneficialAddr', 'type': 'address' } ] }\n    },\n    WithdrawSBPReward_V2: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'WithdrawReward', 'inputs': [ { 'name': 'gid', 'type': 'gid' }, { 'name': 'sbpName', 'type': 'string' }, { 'name': 'receiveAddress', 'type': 'address' } ] }\n    },\n    VoteForSBP_V1: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'Vote', 'inputs': [ { 'name': 'gid', 'type': 'gid' }, { 'name': 'sbpName', 'type': 'string' } ] }\n    },\n    CancelSBPVoting_V1: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'CancelVote', 'inputs': [{ 'name': 'gid', 'type': 'gid' }] }\n    },\n    StakeForQuota_V1: {\n        contractAddress: Staking_ContractAddress,\n        abi: { 'type': 'function', 'name': 'Pledge', 'inputs': [{ 'name': 'beneficial', 'type': 'address' }] }\n    },\n    StakeForQuota_V2: {\n        contractAddress: Staking_ContractAddress,\n        abi: { 'type': 'function', 'name': 'Stake', 'inputs': [{ 'name': 'beneficiary', 'type': 'address' }] }\n    },\n    CancelQuotaStake_V1: {\n        contractAddress: Staking_ContractAddress,\n        abi: { 'type': 'function', 'name': 'CancelPledge', 'inputs': [ { 'name': 'beneficial', 'type': 'address' }, { 'name': 'amount', 'type': 'uint256' } ] }\n    },\n    CancelQuotaStake_V2: {\n        contractAddress: Staking_ContractAddress,\n        abi: { 'type': 'function', 'name': 'CancelStake', 'inputs': [ { 'name': 'beneficiary', 'type': 'address' }, { 'name': 'amount', 'type': 'uint256' } ] }\n    },\n    IssueToken_V1: {\n        contractAddress: TokenIssuance_ContractAddress,\n        abi: { 'type': 'function', 'name': 'Mint', 'inputs': [ { 'name': 'isReIssuable', 'type': 'bool' }, { 'name': 'tokenName', 'type': 'string' }, { 'name': 'tokenSymbol', 'type': 'string' }, { 'name': 'totalSupply', 'type': 'uint256' }, { 'name': 'decimals', 'type': 'uint8' }, { 'name': 'maxSupply', 'type': 'uint256' }, { 'name': 'ownerBurnOnly', 'type': 'bool' } ] }\n    },\n    ReIssueToken_V1: {\n        contractAddress: TokenIssuance_ContractAddress,\n        abi: { 'type': 'function', 'name': 'Issue', 'inputs': [ { 'name': 'tokenId', 'type': 'tokenId' }, { 'name': 'amount', 'type': 'uint256' }, { 'name': 'beneficial', 'type': 'address' } ] }\n    },\n    TransferTokenOwnership_V1: {\n        contractAddress: TokenIssuance_ContractAddress,\n        abi: { 'type': 'function', 'name': 'TransferOwner', 'inputs': [ { 'name': 'tokenId', 'type': 'tokenId' }, { 'name': 'newOwner', 'type': 'address' } ] }\n    },\n    DisableReIssue_V1: {\n        contractAddress: TokenIssuance_ContractAddress,\n        abi: { 'type': 'function', 'name': 'ChangeTokenType', 'inputs': [{ 'name': 'tokenId', 'type': 'tokenId' }] }\n    },\n    DexDeposit_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundUserDeposit', 'inputs': [] }\n    },\n    DexWithdraw_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundUserWithdraw', 'inputs': [ { 'name': 'token', 'type': 'tokenId' }, { 'name': 'amount', 'type': 'uint256' } ] }\n    },\n    DexPlaceOrder_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundNewOrder', 'inputs': [ { 'name': 'tradeToken', 'type': 'tokenId' }, { 'name': 'quoteToken', 'type': 'tokenId' }, { 'name': 'side', 'type': 'bool' }, { 'name': 'orderType', 'type': 'uint8' }, { 'name': 'price', 'type': 'string' }, { 'name': 'quantity', 'type': 'uint256' } ] }\n    },\n    DexCancelOrder_V1: {\n        contractAddress: DexTrade_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexTradeCancelOrder', 'inputs': [{ 'name': 'orderId', 'type': 'bytes' }] }\n    },\n    DexOpenNewMarket_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundNewMarket', 'inputs': [ { 'name': 'tradeToken', 'type': 'tokenId' }, { 'name': 'quoteToken', 'type': 'tokenId' } ] }\n    },\n    DexStakeForMining_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundPledgeForVx', 'inputs': [ { 'name': 'actionType', 'type': 'uint8' }, { 'name': 'amount', 'type': 'uint256' } ] }\n    },\n    DexStakeForVIP_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundPledgeForVip', 'inputs': [{ 'name': 'actionType', 'type': 'uint8' }] }\n    },\n    DexBindInviteCode_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundBindInviteCode', 'inputs': [{ 'name': 'code', 'type': 'uint32' }] }\n    },\n    DexCreateNewInviter_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundNewInviter', 'inputs': [] }\n    },\n    DexTransferTokenOwnership_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundTransferTokenOwner', 'inputs': [ { 'name': 'token', 'type': 'tokenId' }, { 'name': 'owner', 'type': 'address' } ] }\n    },\n    DexMarketAdminConfig_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundMarketOwnerConfig', 'inputs': [ { 'name': 'operationCode', 'type': 'uint8' }, { 'name': 'tradeToken', 'type': 'tokenId' }, { 'name': 'quoteToken', 'type': 'tokenId' }, { 'name': 'owner', 'type': 'address' }, { 'name': 'takerFeeRate', 'type': 'int32' }, { 'name': 'makerFeeRate', 'type': 'int32' }, { 'name': 'stopMarket', 'type': 'bool' } ] }\n    },\n    DexStakeForSuperVIP_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundPledgeForSuperVip', 'inputs': [{ 'name': 'actionType', 'type': 'uint8' }] }\n    },\n    DexConfigMarketAgents_V1: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DexFundConfigMarketsAgent', 'inputs': [ { 'name': 'actionType', 'type': 'uint8' }, { 'name': 'agent', 'type': 'address' }, { 'name': 'tradeTokens', 'type': 'tokenId[]' }, { 'name': 'quoteTokens', 'type': 'tokenId[]' } ] }\n    },\n\n    RegisterSBP: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'RegisterSBP', 'inputs': [ { 'name': 'sbpName', 'type': 'string' }, { 'name': 'blockProducingAddress', 'type': 'address' }, { 'name': 'rewardWithdrawAddress', 'type': 'address' } ] }\n    },\n    UpdateSBPBlockProducingAddress: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'UpdateSBPBlockProducingAddress', 'inputs': [ { 'name': 'sbpName', 'type': 'string' }, { 'name': 'blockProducingAddress', 'type': 'address' } ] }\n    },\n    UpdateSBPRewardWithdrawAddress: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'UpdateSBPRewardWithdrawAddress', 'inputs': [ { 'name': 'sbpName', 'type': 'string' }, { 'name': 'rewardWithdrawAddress', 'type': 'address' } ] }\n    },\n    RevokeSBP: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'RevokeSBP', 'inputs': [{ 'name': 'sbpName', 'type': 'string' }] }\n    },\n    WithdrawSBPReward: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'WithdrawSBPReward', 'inputs': [ { 'name': 'sbpName', 'type': 'string' }, { 'name': 'receiveAddress', 'type': 'address' } ] }\n    },\n    VoteForSBP: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'VoteForSBP', 'inputs': [{ 'name': 'sbpName', 'type': 'string' }] }\n    },\n    CancelSBPVoting: {\n        contractAddress: ConsensusGroup_ContractAddress,\n        abi: { 'type': 'function', 'name': 'CancelSBPVoting', 'inputs': [] }\n    },\n    StakeForQuota: {\n        contractAddress: Staking_ContractAddress,\n        abi: { 'type': 'function', 'name': 'StakeForQuota', 'inputs': [{ 'name': 'beneficiary', 'type': 'address' }] }\n    },\n    CancelQuotaStake: {\n        contractAddress: Staking_ContractAddress,\n        abi: { 'type': 'function', 'name': 'CancelQuotaStaking', 'inputs': [{ 'name': 'id', 'type': 'bytes32' }] }\n    },\n    IssueToken: {\n        contractAddress: TokenIssuance_ContractAddress,\n        abi: { 'type': 'function', 'name': 'IssueToken', 'inputs': [ { 'name': 'isReIssuable', 'type': 'bool' }, { 'name': 'tokenName', 'type': 'string' }, { 'name': 'tokenSymbol', 'type': 'string' }, { 'name': 'totalSupply', 'type': 'uint256' }, { 'name': 'decimals', 'type': 'uint8' }, { 'name': 'maxSupply', 'type': 'uint256' }, { 'name': 'isOwnerBurnOnly', 'type': 'bool' } ] }\n    },\n    ReIssueToken: {\n        contractAddress: TokenIssuance_ContractAddress,\n        abi: { 'type': 'function', 'name': 'ReIssue', 'inputs': [ { 'name': 'tokenId', 'type': 'tokenId' }, { 'name': 'amount', 'type': 'uint256' }, { 'name': 'receiveAddress', 'type': 'address' } ] }\n    },\n    BurnToken: {\n        contractAddress: TokenIssuance_ContractAddress,\n        abi: { 'type': 'function', 'name': 'Burn', 'inputs': [] }\n    },\n    TransferTokenOwnership: {\n        contractAddress: TokenIssuance_ContractAddress,\n        abi: { 'type': 'function', 'name': 'TransferOwnership', 'inputs': [ { 'name': 'tokenId', 'type': 'tokenId' }, { 'name': 'newOwner', 'type': 'address' } ] }\n    },\n    DisableReIssue: {\n        contractAddress: TokenIssuance_ContractAddress,\n        abi: { 'type': 'function', 'name': 'DisableReIssue', 'inputs': [{ 'name': 'tokenId', 'type': 'tokenId' }] }\n    },\n    DexDeposit: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'Deposit', 'inputs': [] }\n    },\n    DexWithdraw: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'Withdraw', 'inputs': [ { 'name': 'token', 'type': 'tokenId' }, { 'name': 'amount', 'type': 'uint256' } ] }\n    },\n    DexOpenNewMarket: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'OpenNewMarket', 'inputs': [ { 'name': 'tradeToken', 'type': 'tokenId' }, { 'name': 'quoteToken', 'type': 'tokenId' } ] }\n    },\n    DexPlaceOrder: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'PlaceOrder', 'inputs': [ { 'name': 'tradeToken', 'type': 'tokenId' }, { 'name': 'quoteToken', 'type': 'tokenId' }, { 'name': 'side', 'type': 'bool' }, { 'name': 'orderType', 'type': 'uint8' }, { 'name': 'price', 'type': 'string' }, { 'name': 'quantity', 'type': 'uint256' } ] }\n    },\n    DexCancelOrder: {\n        contractAddress: DexTrade_ContractAddress,\n        abi: { 'type': 'function', 'name': 'CancelOrder', 'inputs': [{ 'name': 'orderId', 'type': 'bytes' }] }\n    },\n    DexStakeForMining: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'StakeForMining', 'inputs': [ { 'name': 'actionType', 'type': 'uint8' }, { 'name': 'amount', 'type': 'uint256' } ] }\n    },\n    DexStakeForVIP: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'StakeForVIP', 'inputs': [{ 'name': 'actionType', 'type': 'uint8' }] }\n    },\n    DexMarketAdminConfig: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'MarketAdminConfig', 'inputs': [ { 'name': 'operationCode', 'type': 'uint8' }, { 'name': 'tradeToken', 'type': 'tokenId' }, { 'name': 'quoteToken', 'type': 'tokenId' }, { 'name': 'marketOwner', 'type': 'address' }, { 'name': 'takerFeeRate', 'type': 'int32' }, { 'name': 'makerFeeRate', 'type': 'int32' }, { 'name': 'stopMarket', 'type': 'bool' } ] }\n    },\n    DexTransferTokenOwnership: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'TransferTokenOwnership', 'inputs': [ { 'name': 'token', 'type': 'tokenId' }, { 'name': 'newOwner', 'type': 'address' } ] }\n    },\n    DexCreateNewInviter: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'CreateNewInviter', 'inputs': [] }\n    },\n    DexBindInviteCode: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'BindInviteCode', 'inputs': [{ 'name': 'code', 'type': 'uint32' }] }\n    },\n    DexStakeForSuperVIP: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'StakeForSVIP', 'inputs': [{ 'name': 'actionType', 'type': 'uint8' }] }\n    },\n    DexConfigMarketAgents: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'ConfigMarketAgents', 'inputs': [ { 'name': 'actionType', 'type': 'uint8' }, { 'name': 'agent', 'type': 'address' }, { 'name': 'tradeTokens', 'type': 'tokenId[]' }, { 'name': 'quoteTokens', 'type': 'tokenId[]' } ] }\n    },\n    DexLockVxForDividend: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'LockVxForDividend', 'inputs': [ { 'name': 'actionType', 'type': 'uint8' }, { 'name': 'amount', 'type': 'uint256' } ] }\n    },\n    DexSwitchConfig: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'SwitchConfig', 'inputs': [ { 'name': 'switchType', 'type': 'uint8' }, { 'name': 'enable', 'type': 'bool' } ] }\n    },\n    DexStakeForPrincipalSVIP: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'StakeForPrincipalSVIP', 'inputs': [{ 'name': 'principal', 'type': 'address' }] }\n    },\n    DexCancelStakeById: {\n        contractAddress: DexFund_ContractAddress,\n        abi: { 'type': 'function', 'name': 'CancelStakeById', 'inputs': [{ 'name': 'id', 'type': 'bytes32' }] }\n    },\n    DexTransfer: {\n        contractAddress: DexFund_ContractAddress,\n        abi: {'type': 'function', 'name': 'Transfer', 'inputs': [ {'name': 'target', 'type': 'address'}, {'name': 'token', 'type': 'tokenId'}, {'name': 'amount', 'type': 'uint256'} ]}\n    },\n    DexAgentDeposit: {\n        contractAddress: DexFund_ContractAddress,\n        abi: {'type': 'function', 'name': 'AgentDeposit', 'inputs': [{'name': 'beneficiary', 'type': 'address'}]}\n    },\n    DexAssignedWithdraw: {\n        contractAddress: DexFund_ContractAddress,\n        abi: {'type': 'function', 'name': 'AssignedWithdraw', 'inputs': [ {'name': 'target', 'type': 'address'}, {'name': 'token', 'type': 'tokenId'}, {'name': 'amount', 'type': 'uint256'}, {'name': 'label', 'type': 'bytes'} ]}\n    }\n};\n</code></pre>"},{"location":"SDK/vitejs/constants-and-errors/#common-errors","title":"Common Errors","text":"<p>The following table lists the common errors in Vite.js</p> Property Code Description <code>unknown</code> 100000 Unknown Error <code>paramsMissing</code> 100001 Missing Parameter <code>paramsFormat</code> 100002 Incorrect Parameter Format <code>paramsConflict</code> 100003 Conflicting Parameter <code>addressIllegal</code> 200001 Illegal Address <code>addressMissing</code> 200002 Address Does Not Exist <code>integerIllegal</code> 200003 Illegal Integer <code>unsafeInteger</code> 200004 Unsafe Integer <code>requestTimeout</code> 300001 Request Timeout <p>In addition, since vite.js relies on full node's RPC API, it will return the error messages come from the API. It's good to know the Common RPC Errors.</p>"},{"location":"SDK/vitejs/providers/","title":"Connection Providers","text":"<p>Connection Providers provide an endpoint for interacting with the full node's RPC API. There are three connection providers on Vite: HTTP, WebSocket and IPC. </p> <ul> <li>HTTP: set up connection via http/https. The default port on the node is 48132.</li> <li>WebSocket: set up connection via ws/wss. The default port is 41420.</li> <li>IPC: set up connection via ipc sockets. </li> </ul> <p>There are no obvious advantages and disadvantages between HTTP and WebSocket. However, if your program applies subscriptions, WebSocket is recommended as it updates in real time whereas HTTP polls for new data every few seconds. This chapter of Vite.js documentation will be brief as calling methods on these providers are best done by the ViteAPI class covered in the next chapter.</p> <p>IPC provider is a good option when using a local node since it gives the most secure connection.</p>"},{"location":"SDK/vitejs/providers/#websocket","title":"WebSocket","text":""},{"location":"SDK/vitejs/providers/#installation","title":"Installation","text":"<pre><code>npm i @vite/vitejs-ws\n</code></pre> <p>Note</p> <p>Starting from 2.3.19, package @vite/vitejs-ws is consolidated into @vite/vitejs, so there's no need to install it separately. </p>"},{"location":"SDK/vitejs/providers/#module-import","title":"Module Import","text":"<pre><code>import WS_RPC from \"@vite/vitejs-ws\";\n\n// After 2.3.19 \nimport WS_RPC from \"@vite/vitejs\";\n</code></pre>"},{"location":"SDK/vitejs/providers/#ws_rpc-class","title":"<code>WS_RPC</code> Class","text":"<ul> <li> <p>Constructor</p> <ul> <li><code>path: string = 'ws://localhost:41420'</code> Connection URL</li> <li><code>timeout: number = 60000</code> Timeout in milliseconds</li> <li><code>options: object</code><ul> <li><code>protocol: string = ''</code></li> <li><code>headers?: object</code> Request header</li> <li><code>clientConfig?: object</code> websocket client config options</li> <li><code>retryTimes: number = 10</code> Times to retry connecting if it fails the first time</li> <li><code>retryInterval: number = 10000</code> Time between each retry attempt in milliseconds</li> </ul> </li> </ul> </li> <li> <p>Example <pre><code>const providerWsURLs = {\n    localnet: 'ws://localhost:23457',\n    testnet: 'wss://buidl.vite.net/gvite/ws',\n    mainnet: 'wss://node.vite.net/gvite/ws',\n};\nimport WS_RPC from \"@vite/vitejs-ws\";\nconst wsProvider = new WS_RPC(providerWsURLs.localnet, 60000, { retryTimes: 10, retryInterval: 5000 });\n</code></pre></p> </li> </ul>"},{"location":"SDK/vitejs/providers/#reconnecthandler-and-subscription-renewal","title":"ReconnectHandler and Subscription Renewal","text":"<p>In 2.3.19, <code>ReconnectHandler</code>, <code>AlwaysReconnect</code> and <code>RenewSubscription</code> are added to support flexible reconnection mechanism and subscription renewal.</p> <p>Breaking Change</p> <p><code>retryTimes</code> and <code>retryInterval</code> are moved from the options of provider to <code>ReconnectHandler</code>'s constructor.</p> <p>Let's see a few examples.</p> <ol> <li>Auto resubscribe with maximum 5 retries and 1000ms interval.</li> </ol> <pre><code>const ws = new WS_RPC(config.wsURL);\nconst provider = new ViteAPI(ws, () =&gt; {\n  console.log(\"Connected\");\n}, new RenewSubscription(retryTimes = 5, retryInterval = 1000));\n</code></pre> <ol> <li>Auto resubscribe with maximum retries and default 10000ms interval.</li> </ol> <pre><code>const ws = new WS_RPC(config.wsURL);\nconst provider = new ViteAPI(ws, () =&gt; {\n  console.log(\"Connected\");\n}, new RenewSubscription(Number.MAX_VALUE));\n</code></pre> <ol> <li>Auto reconnect with unlimited retries and default 10000ms interval. </li> </ol> <pre><code>const ws = new WS_RPC(config.wsURL);\nconst provider = new ViteAPI(ws, () =&gt; {\n  console.log(\"Connected\");\n}, new AlwaysReconnect());\n</code></pre> <ol> <li>Use default handler (auto reconnect with 10 retries and 10000ms interval).</li> </ol> <pre><code>const ws = new WS_RPC(config.wsURL);\nconst provider = new ViteAPI(ws, () =&gt; {\n  console.log(\"Connected\");\n});\n</code></pre>"},{"location":"SDK/vitejs/providers/#http","title":"HTTP","text":""},{"location":"SDK/vitejs/providers/#installation_1","title":"Installation","text":"<pre><code>npm i @vite/vitejs-http\n</code></pre> <p>Starting from 2.3.19, package @vite/vitejs-http is consolidated into @vite/vitejs, so there's no need to install the package separately. </p>"},{"location":"SDK/vitejs/providers/#module-import_1","title":"Module Import","text":"<pre><code>import HTTP_RPC from \"@vite/vitejs-http\";\n\n// After 2.3.19 \nimport HTTP_RPC from \"@vite/vitejs\";\n</code></pre>"},{"location":"SDK/vitejs/providers/#http_rpc-class","title":"<code>HTTP_RPC</code> Class","text":"<ul> <li>Constructor<ul> <li><code>host:string = 'http://localhost:48132'</code> Connection URL</li> <li><code>timeout: number = 60000</code> Timeout in milliseconds</li> <li><code>options: object = { headers: [] }</code><ul> <li><code>headers: { name: any, value: any }[]</code> Request headers</li> </ul> </li> </ul> </li> <li>Example <pre><code>import HTTP_RPC from \"@vite/vitejs-http\";\n\nconst providerHttpURLs = {\n    localnet: 'http://127.0.0.1:23456',\n    testnet: 'https://buidl.vite.net/gvite',\n    mainnet: 'https://node.vite.net/gvite',\n};\n\nconst httpProvider = new HTTP_RPC(providerHttpURLs.mainnet);\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/providers/#ipc","title":"IPC","text":""},{"location":"SDK/vitejs/providers/#installation_2","title":"Installation","text":"<pre><code>npm i @vite/vitejs-ipc\n</code></pre> <p>Starting from 2.3.19, package @vite/vitejs-ipc is consolidated into @vite/vitejs, so there's no need to install the package separately. </p>"},{"location":"SDK/vitejs/providers/#module-import_2","title":"Module Import","text":"<pre><code>import IPC_RPC from \"@vite/vitejs-ipc\";\n\n// After 2.3.19 \nimport IPC_RPC from \"@vite/vitejs\";\n</code></pre>"},{"location":"SDK/vitejs/providers/#ipc_rpc-class","title":"<code>IPC_RPC</code> Class","text":"<ul> <li>Constructor<ul> <li><code>path:string = ''</code> File path to gvite.ipc</li> <li><code>timeout: number = 60000</code> Timeout in milliseconds</li> <li><code>options: object</code><ul> <li><code>delimiter: '\\n'</code> The delimiter at the end of each data packet</li> </ul> </li> </ul> </li> <li>Example <pre><code>import IPC_RPC from \"@vite/vitejs-ipc\";\n\nconst ipcProvider = new IPC_RPC(\"~/.gvite/maindata/gvite.ipc\");\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/types/","title":"Type Definition","text":"<p>Source code</p> <p>Note: ViteJS is in the process of being refactored to have easier to understand types</p>"},{"location":"SDK/vitejs/types/#type","title":"Type","text":"<pre><code>export declare type Hex = string;\nexport declare type Address = string;\nexport declare type Base64 = string;\nexport declare type TokenId = string;\nexport declare type Int32 = string;\nexport declare type Int64 = string;\nexport declare type Uint8 = string;\nexport declare type Uint16 = string;\nexport declare type Uint32 = string;\nexport declare type Uint64 = string;\nexport declare type Uint256 = string;\nexport declare type BigInt = string;\nexport declare type Bytes32 = string;\n\nexport enum TransactionType {\n    'RegisterSBP' = 1,\n    'UpdateSBPBlockProducingAddress',\n    'UpdateSBPRewardWithdrawAddress',\n    'RevokeSBP',\n    'WithdrawSBPReward',\n    'VoteForSBP',\n    'CancelSBPVoting',\n    'StakeForQuota',\n    'CancelQuotaStake',\n    'IssueToken',\n    'ReIssueToken',\n    'BurnToken',\n    'TransferTokenOwnership',\n    'DisableReIssue',\n    'CreateContractRequest',\n    'TransferRequest',\n    'ReIssueRequest',\n    'Response',\n    'ResponseFail',\n    'RefundByContractRequest',\n    'GenesisResponse',\n    'RegisterSBP_V1',\n    'UpdateSBPBlockProducingAddress_V1',\n    'UpdateSBPBlockProducingAddress_V2',\n    'RevokeSBP_V1',\n    'RevokeSBP_V2',\n    'WithdrawSBPReward_V1',\n    'WithdrawSBPReward_V2',\n    'VoteForSBP_V1',\n    'CancelSBPVoting_V1',\n    'StakeForQuota_V1',\n    'StakeForQuota_V2',\n    'CancelQuotaStake_V1',\n    'CancelQuotaStake_V2',\n    'IssueToken_V1',\n    'ReIssueToken_V1',\n    'TransferTokenOwnership_V1',\n    'DisableReIssue_V1',\n    'DexDeposit_V1',\n    'DexWithdraw_V1',\n    'DexPlaceOrder_V1',\n    'DexCancelOrder_V1',\n    'DexOpenNewMarket_V1',\n    'DexStakeForMining_V1',\n    'DexStakeForVIP_V1',\n    'DexBindInviteCode_V1',\n    'DexCreateNewInviter_V1',\n    'DexTransferTokenOwnership_V1',\n    'DexMarketAdminConfig_V1',\n    'DexStakeForSuperVIP_V1',\n    'DexConfigMarketAgents_V1',\n    'DexDeposit',\n    'DexWithdraw',\n    'DexPlaceOrder',\n    'DexCancelOrder',\n    'DexOpenNewMarket',\n    'DexStakeForMining',\n    'DexStakeForVIP',\n    'DexBindInviteCode',\n    'DexCreateNewInviter',\n    'DexTransferTokenOwnership',\n    'DexMarketAdminConfig',\n    'DexStakeForSuperVIP',\n    'DexConfigMarketAgents',\n    'DexLockVxForDividend',\n    'DexSwitchConfig',\n    'DexStakeForPrincipalSVIP',\n    'DexCancelStakeById',\n    'DexTransfer',\n    'DexAgentDeposit',\n    'DexAssignedWithdraw'\n}\n\nexport declare type TokenInfo = {\n    tokenName: string;\n    tokenSymbol: string;\n    totalSupply: BigInt;\n    decimals: Uint8;\n    owner: Address;\n    tokenId: TokenId;\n    isReIssuable: boolean;\n    maxSupply: BigInt;\n    isOwnerBurnOnly: boolean;\n    index: Uint16;\n}\n\nexport declare type AccountBlockType = {\n    blockType: BlockType;\n    height: Uint64;\n    hash: Hex;\n    previousHash: Hex;\n    address: Address;\n    publicKey: Base64;\n    producer?: Address;\n    fromAddress?: Address;\n    toAddress: Address;\n    sendBlockHash?: Hex;\n    tokenId?: TokenId;\n    amount?: BigInt;\n    tokenInfo?: TokenInfo;\n    fee?: BigInt;\n    data?: Base64;\n    difficulty?: BigInt;\n    nonce?: Base64;\n    signature: Base64;\n    quotaByStake?: Uint64;\n    totalQuota?: Uint64;\n    vmlogHash?: Hex;\n\n    triggeredSendBlockList?: AccountBlockType[]\n    confirmations?: Uint64;\n    firstSnapshotHash?: Hex;\n    timestamp?: Uint64;\n    receiveBlockHeight?: Uint64;\n    receiveBlockHash?: Hex;\n}\n\nexport declare type Transaction = {\n    blockType: BlockType;\n    height: Uint64;\n    hash: Hex;\n    previousHash: Hex;\n    address: Address;\n    publicKey: Base64;\n    producer?: Address;\n    fromAddress?: Address;\n    toAddress?: Address;\n    sendBlockHash?: Hex;\n    tokenId?: TokenId;\n    amount?: BigInt;\n    tokenInfo?: TokenInfo;\n    fee?: BigInt;\n    data?: Base64;\n    difficulty?: BigInt;\n    nonce?: Base64;\n    signature?: Base64;\n    quotaByStake?: Uint64;\n    totalQuota?: Uint64;\n    confirmations?: Uint64;\n    firstSnapshotHash?: Hex;\n    timestamp?: Uint64;\n    receiveBlockHeight?: Uint64;\n    receiveBlockHash?: Hex;\n    transactionType?: string;\n    contractParams?: Object;\n}\n\nexport declare type AddressObj = {\n    originalAddress: Hex;\n    publicKey: Hex;\n    privateKey: Hex;\n    address: Address;\n}\n\nexport enum BlockType {\n    'CreateContractRequest' = 1,\n    'TransferRequest',\n    'ReIssueRequest',\n    'Response',\n    'ResponseFail',\n    'RefundByContractRequest',\n    'GenesisResponse'\n}\n\nexport declare type Methods = string |\n'wallet_getEntropyFilesInStandardDir' |\n'wallet_getAllEntropyFiles' |\n'wallet_exportMnemonics' |\n'wallet_unlock' |\n'wallet_lock' |\n'wallet_deriveAddressesByIndexRange' |\n'wallet_createEntropyFile' |\n'wallet_deriveAddressByIndex' |\n'wallet_deriveAddressByPath' |\n'wallet_recoverEntropyFile' |\n'wallet_isUnlocked' |\n'wallet_findAddr' |\n'wallet_globalFindAddr' |\n'wallet_createTxWithPassphrase' |\n'wallet_addEntropyStore' |\n'ledger_getUnreceivedBlocksByAddress' |\n'ledger_getUnreceivedBlocksInBatch' |\n'ledger_getUnreceivedTransactionSummaryByAddress' |\n'ledger_getUnreceivedTransactionSummaryInBatch' |\n'ledger_getVmlogsByFilter' |\n'ledger_getPoWDifficulty' |\n'contract_createContractAddress' |\n'contract_getContractInfo' |\n'contract_callOffChainMethod' |\n'contract_getContractStorage' |\n'contract_getQuotaByAccount' |\n'contract_getStakeList' |\n'contract_getRequiredStakeAmount' |\n'contract_getDelegatedStakeInfo' |\n'contract_getSBPList' |\n'contract_getSBPRewardPendingWithdrawal' |\n'contract_getSBPRewardByTimestamp' |\n'contract_getSBPRewardByCycle' |\n'contract_getSBP' |\n'contract_getSBPVoteList' |\n'contract_getVotedSBP' |\n'vote_getVoteDetails' |\n'contract_getTokenInfoList' |\n'contract_getTokenInfoById' |\n'contract_getTokenInfoListByOwner' |\n'net_syncInfo' |\n'net_syncDetail' |\n'net_nodeInfo' |\n'net_peers' |\n'util_getPoWNonce' |\n'subscribe_newSnapshotBlockFilter' |\n'subscribe_newAccountBlockFilter' |\n'subscribe_newAccountBlockByAddressFilter' |\n'subscribe_newUnreceivedBlockByAddressFilter' |\n'subscribe_newVmLogFilter' |\n'subscribe_uninstallFilter' |\n'subscribe_getChangesByFilterId' |\n'subscribe_newSnapshotBlock' |\n'subscribe_newAccountBlock' |\n'subscribe_newAccountBlockByAddress' |\n'subscribe_newUnreceivedBlockByAddress' |\n'subscribe_newVmLog';\n\nexport declare interface RPCRequest {\n    type?: string;\n    methodName: Methods;\n    params: any[];\n}\n\nexport declare interface RPCResponse {\n    jsonrpc?: string;\n    id?: number;\n    result?: any;\n    error?: RPCError;\n}\n\nexport declare interface RPCError {\n    code: number;\n    message: string;\n}\n\nexport declare class ProviderType {\n    isConnected: boolean;\n\n    constructor(provider: any, onInitCallback: Function)\n\n    setProvider(provider, onInitCallback, abort)\n    unsubscribe(event)\n    unsubscribeAll()\n    request(methods: Methods, ...args: any[])\n    sendNotification(methods: Methods, ...args: any[])\n    batch(reqs: RPCRequest[])\n    subscribe(methodName, ...args)\n}\n\nexport declare class ViteAPI extends ProviderType {\n    transactionType: Object;\n\n    constructor(provider: any, onInitCallback: Function)\n\n    addTransactionType(contractList: Object)\n    getBalanceInfo(address: Address)\n    getTransactionList({ address, pageIndex, pageSize }: {\n        address: Address; pageIndex: number; pageSize?: number;\n    }, decodeTxTypeList: 'all' | string[])\n\n    callOffChainContract({ address, abi, code, params })\n    queryContractState({ address, abi, methodName, params })\n    getNonce({ difficulty, previousHash, address }: {\n        difficulty: BigInt;\n        previousHash: Hex;\n        address: Address;\n    }): Promise&lt;Base64&gt;\n}\n\n\nexport declare type AccountBlockBlock = {\n    blockType: BlockType;\n    address: Address;\n    fee?: BigInt;\n    data?: Base64;\n    sendBlockHash?: Hex;\n    toAddress?: Address;\n    tokenId?: TokenId;\n    amount?: BigInt;\n    height?: Uint64;\n    previousHash?: Hex;\n    difficulty?: BigInt;\n    nonce?: Base64;\n    signature?: Base64;\n    publicKey?: Base64;\n    hash?: Hex\n}\n\nexport declare class AccountBlockClassType {\n    blockType: BlockType;\n    address: Address;\n    fee?: BigInt;\n    data?: Base64;\n    sendBlockHash?: Hex;\n    toAddress?: Address;\n    tokenId?: TokenId;\n    amount?: BigInt;\n    height?: Uint64;\n    previousHash?: Hex;\n    difficulty?: BigInt;\n    nonce?: Base64;\n    signature?: Base64;\n    publicKey?: Base64;\n\n    originalAddress: Hex;\n    blockTypeHex: Hex;\n    previousHashHex: Hex;\n    heightHex: Hex;\n    addressHex: Hex;\n    toAddressHex: Hex;\n    amountHex: Hex;\n    tokenIdHex: Hex;\n    sendBlockHashHex: Hex;\n    dataHex: Hex;\n    feeHex: Hex;\n    nonceHex: Hex;\n    hash: Hex;\n\n    isRequestBlock: boolean;\n    isResponseBlock: boolean;\n\n    accountBlock: AccountBlockBlock;\n\n    constructor({ blockType, address, fee, data, sendBlockHash, amount, toAddress, tokenId }: {\n        blockType: BlockType;\n        address: Address;\n        fee?: BigInt;\n        data?: Base64;\n        sendBlockHash?: Hex;\n        amount?: BigInt;\n        toAddress?: Address;\n        tokenId?: TokenId;\n    }, provider?: ProviderType, privateKey?: Hex)\n\n    setProvider(provider: ProviderType)\n    setPrivateKey(privateKey: Hex)\n\n    getPreviousAccountBlock(): Promise&lt;AccountBlockType&gt;\n    setHeight(height: Uint64): AccountBlockClassType\n    setPreviousHash(previousHash: Hex): AccountBlockClassType\n    setPreviousAccountBlock(previousAccountBlock: AccountBlockType): AccountBlockClassType\n    autoSetPreviousAccountBlock(): Promise&lt;{\n        height: Uint64;\n        previousHash: Hex;\n    }&gt;\n\n    getDifficulty(): Promise&lt;BigInt&gt;\n    setDifficulty(difficulty: BigInt): AccountBlockClassType\n    autoSetDifficulty(): Promise&lt;BigInt&gt;\n    getNonce(): Promise&lt;Base64&gt;\n    setNonce(nonce: Base64): AccountBlockClassType\n    autoSetNonce(): Promise&lt;Base64&gt;\n    PoW(difficulty?: BigInt): Promise&lt;{difficulty: BigInt; nonce: Base64}&gt;\n\n    setPublicKey(publicKey: Hex | Base64): AccountBlockClassType\n    setSignature(signature: Hex | Base64): AccountBlockClassType\n    sign(privateKey?: Hex): AccountBlockClassType\n\n    send(): Promise&lt;AccountBlockBlock&gt;\n    sendByPoW(privateKey?: Hex): Promise&lt;AccountBlockBlock&gt;\n\n    autoSendByPoW(privateKey?: Hex): Promise&lt;AccountBlockBlock&gt;\n    autoSend(privateKey?: Hex): Promise&lt;AccountBlockBlock&gt;\n}\n</code></pre>"},{"location":"SDK/vitejs/utility-funcs/","title":"Utility Functions","text":""},{"location":"SDK/vitejs/utility-funcs/#module-import","title":"Module Import","text":"<pre><code>import { utils } from '@vite/vitejs';\n</code></pre>"},{"location":"SDK/vitejs/utility-funcs/#methods","title":"Methods","text":""},{"location":"SDK/vitejs/utility-funcs/#uristringify","title":"<code>uriStringify</code>","text":"<p>Generate a VEP-6 compatible Vite URI based on the given parameters - Parameters     - <code>object</code>         - <code>schema: string = 'vite'</code>         - <code>prefix: string = ''</code>         - <code>target_address: string = ''</code> Transaction recipient address         - <code>chain_id: number = ''</code> Network id. Default is the mainnet         - <code>function_name: string = ''</code> Method name of contract to call         - <code>params: Object</code> Additional parameters             - <code>amount: number</code> Amount to transfer. The unit is VITE. e.g. <code>1</code> stands for 1 VITE. Default is 0.             - <code>data: Base64</code> Optional data in Base64 format             - <code>fee: number</code> Transaction fee. The unit is VITE. Default is 0.             - <code>tti: TokenId</code> Token id. Default is Vite. - Returns     - <code>uri : string</code> Vite URI string - Example <pre><code>console.log(\n    utils.uriStringify({\n        target_address: 'vite_fa1d81d93bcc36f234f7bccf1403924a0834609f4b2e9856ad',\n        params: { amount: 1, data: 'MTIzYWJjZA' },\n        function_name: 'echo',\n    })\n); // vite:vite_fa1d81d93bcc36f234f7bccf1403924a0834609f4b2e9856ad/echo?amount=1&amp;data=MTIzYWJjZA\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#isvalidtokenid","title":"<code>isValidTokenId</code>","text":"<p>Determine if a token id is valid - Parameters     - <code>tokenId: string</code> Token id - Returns     - <code>boolean</code> If <code>true</code>, the token id is valid. - Example <pre><code>const viteTokenId = 'tti_5649544520544f4b454e6e40';\nconsole.log(utils.isValidTokenId(viteTokenId)); // true\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#getoriginaltokenidfromtokenid","title":"<code>getOriginalTokenIdFromTokenId</code>","text":"<p>Get Original Token ID from a token id - Parameters     - <code>tokenId: string</code> Token id - Returns     - <code>Hex</code> Original token id - Example <pre><code>const viteTokenId = 'tti_5649544520544f4b454e6e40';\nconsole.log(utils.getOriginalTokenIdFromTokenId(viteTokenId)); // 5649544520544f4b454e\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#gettokenidfromoriginaltokenid","title":"<code>getTokenIdFromOriginalTokenId</code>","text":"<p>Get token id from Original Token ID - Parameters     - <code>originalTokenId: string</code> Original token id - Returns     - <code>TokenId</code> Token id - Example <pre><code>console.log(utils.getTokenIdFromOriginalTokenId('5649544520544f4b454e')); // tti_5649544520544f4b454e6e40\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#isvalidsbpname","title":"<code>isValidSBPName</code>","text":"<p>Determine if the input is a valid SBP name. See SBP Name for details. - Parameters     - <code>sbpName: string</code> Input name - Returns     - <code>boolean</code> If <code>true</code>, the SBP name is valid. - Example <pre><code>console.log(utils.isValidSBPName('test')); // true\nconsole.log(utils.isValidSBPName('n!')); // false\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#isinteger","title":"<code>isInteger</code>","text":"<p>Determine if the input is an integer - Parameters     - <code>num: string</code> Input string - Returns     - <code>boolean</code> If <code>true</code>, the input string is an integer. - Example <pre><code>console.log(utils.isInteger('42')); // true\nconsole.log(utils.isInteger('1000')); // true\nconsole.log(utils.isInteger('-1000')); // true\nconsole.log(utils.isInteger('1,000')); // false\nconsole.log(utils.isInteger('3.14')); // false\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#isnonnegativeinteger","title":"<code>isNonNegativeInteger</code>","text":"<p>Determine if the input is a non-negative integer - Parameters     - <code>num: string</code> Input string - Returns     - <code>boolean</code> If <code>true</code>, the input string is a non-negative integer. - Example <pre><code>console.log(utils.isNonNegativeInteger('42')); // true\nconsole.log(utils.isNonNegativeInteger('1000')); // true\nconsole.log(utils.isNonNegativeInteger('-1000')); // false\nconsole.log(utils.isNonNegativeInteger('1,000')); // false\nconsole.log(utils.isNonNegativeInteger('3.14')); // false\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#issafeinteger","title":"<code>isSafeInteger</code>","text":"<p>Determine if the input is a safe integer - Parameters     - <code>string | number</code> Input number or string - Returns     - <code>-1 | 0 | 1</code> -1: not an integer; 0: unsafe integer or decimal; 1: safe integer - Example <pre><code>console.log(utils.isSafeInteger(42)); // 1\nconsole.log(utils.isSafeInteger('1000')); // 1\nconsole.log(utils.isSafeInteger('-1000')); // 1\nconsole.log(utils.isSafeInteger('1,000')); // -1\nconsole.log(utils.isSafeInteger(3.14)); // 0\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#isarray","title":"<code>isArray</code>","text":"<p>Determine if the input is an array - uses as a fallback function if <code>Array.isArray</code> doesn't exist in your runtime environment. - Parameters     - <code>any</code> Input value - Returns     - <code>boolean</code> If <code>true</code>, the input is an array. - Example <pre><code>console.log(utils.isArray([])); // true\nconsole.log(utils.isArray({})); // false\nconsole.log(utils.isArray(42)); // false\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#isobject","title":"<code>isObject</code>","text":"<p>Determine if the input is an object - Parameters     - <code>any</code> Input value - Returns     - <code>boolean</code> If <code>true</code>, the input is an object. - Example <pre><code>console.log(utils.isObject([])); // true\nconsole.log(utils.isObject({})); // true\nconsole.log(utils.isObject(() =&gt; {})); // true\nconsole.log(utils.isObject(42)); // false\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#ishexstring","title":"<code>isHexString</code>","text":"<p>Determine if the input is a hex string - Parameters     - <code>string</code> Input string - Returns     - <code>boolean</code> If <code>true</code>, the input is a hex string. - Example <pre><code>console.log(utils.isHexString('5649544520544f4b454e')); // true\nconsole.log(utils.isHexString('vite')); // false\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#isbase64string","title":"<code>isBase64String</code>","text":"<p>Determine if the input is a base64 string - Parameters     - <code>string</code> Input string - Returns     - <code>boolean</code> If <code>true</code>, the input is a base64 string. - Example <pre><code>const encoded = _Buffer.from(`Hello world!`).toString('base64');\nconsole.log(utils.isBase64String(encoded)); // true\nconsole.log(utils.isBase64String('Hello world!')); // false\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#blake2b","title":"<code>blake2b</code>","text":"<p>A reference to the <code>blake2b</code> function from blakejs/blake2b</p>"},{"location":"SDK/vitejs/utility-funcs/#blake2bhex","title":"<code>blake2bHex</code>","text":"<p>A reference to the <code>blake2bHex</code> function from blakejs/blake2b</p>"},{"location":"SDK/vitejs/utility-funcs/#_buffer","title":"<code>_Buffer</code>","text":"<p>A reference to <code>Buffer</code> from Node.js</p>"},{"location":"SDK/vitejs/utility-funcs/#_bn","title":"<code>_bn</code>","text":"<p>A reference to bn.js</p>"},{"location":"SDK/vitejs/utility-funcs/#ed25519","title":"<code>ed25519</code>","text":"<p>An object containing various Ed25519 methods</p>"},{"location":"SDK/vitejs/utility-funcs/#keypair","title":"<code>keyPair</code>","text":"<p>Generate a random Ed25519 key pair - Parameters     - None - Returns     - <code>object</code> Key pair         - <code>privateKey: Buffer</code> private key in 64 bytes buffer array         - <code>publicKey: Buffer</code> public key in 32 bytes buffer array - Example <pre><code>const keyPair = ed25519.keyPair();\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#getpublickey","title":"<code>getPublicKey</code>","text":"<p>Get the public key from a private key; the private key must be derived from an Ed25519 key pair. - Parameters     - <code>privKey: Buffer</code> private key in 64 bytes buffer array - Returns     - <code>Buffer</code> public key in 32 bytes buffer array - Example <pre><code>const { ed25519, _Buffer } = utils;\nconst keyPair = ed25519.keyPair();\n// https://nodejs.org/api/buffer.html#static-method-buffercomparebuf1-buf2\nconsole.log(_Buffer.compare(ed25519.getPublicKey(keyPair.privateKey), keyPair.publicKey)); // 0 (the two arguments have the same value)\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#sign","title":"<code>sign</code>","text":"<p>Sign a hex string with a private key - Parameters     - <code>hexStr: Hex</code> Original text encoded in hexadecimal     - <code>privKey: Hex</code> Private key - Returns     - <code>Hex</code> Signature - Example <pre><code>const encoded = _Buffer.from('vite').toString('hex'); // 76697465\nconsole.log(_Buffer.from(encoded, 'hex').toString()); // 'vite'\nconst signature = ed25519.sign(encoded, keyPair.privateKey.toString('hex')); // af35bbea83eda460bd8b4a16d5bf9f175b90e3d035e47bcdd676f214f4ecd79bdb192b2c5fbbff896e841d3614f19ce25f1fc079e778ba271288f427e626dc0b\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#verify","title":"<code>verify</code>","text":"<p>Determine if a signature is valid - Parameters     - <code>message: Hex</code> Original text     - <code>signature: Hex</code> Signature     - <code>publicKey: Hex</code> Public key - Returns     - <code>Boolean</code> If <code>true</code>, the signature is valid. - Example <pre><code>const encoded = _Buffer.from(`Let's build something cool`).toString('hex'); // 76697465\nconsole.log(_Buffer.from(encoded, 'hex').toString()); // `Let's build something cool`\nconst signature = ed25519.sign(encoded, keyPair.privateKey.toString('hex')); // af35bbea83eda460bd8b4a16d5bf9f175b90e3d035e47bcdd676f214f4ecd79bdb192b2c5fbbff896e841d3614f19ce25f1fc079e778ba271288f427e626dc0b\nconsole.log(ed25519.verify(encoded, signature, keyPair.publicKey.toString('hex'))); // true\n</code></pre></p>"},{"location":"SDK/vitejs/utility-funcs/#random","title":"<code>random</code>","text":"<p>Generate random buffer array</p> <p>Notes: This is used by scrypt salt when generating the keystore - Parameters     - <code>bytesLen: number = 32</code> Buffer array byte length - Returns     - <code>any</code> A random buffer array - Example <pre><code>const bufferArray = ed25519.random();\nconsole.log(bufferArray.length); // 32\nconsole.log(ed25519.random(5).length); // 5\n</code></pre></p>"},{"location":"SDK/vitejs/viteapi-class/","title":"ViteAPI Class","text":""},{"location":"SDK/vitejs/viteapi-class/#viteapi","title":"<code>ViteAPI</code>","text":"<p>Class of <code>ViteAPI</code>, along with the inherited <code>Provider</code> class, wraps and extends the full node's RPC API</p> <p>Tip</p> <p>Do NOT confuse the Provider class with Connection Providers we covered in last chapter. <code>Provider</code> wraps an instance of Connection Provider and provides a few convenient methods to interact with full node through the connection provider.</p> <ul> <li>Constructor<ul> <li><code>provider: Connection Provider</code> Learn more in Connection Providers</li> <li><code>onInitCallback: Function</code> Callback function that will be called when connection is established</li> <li><code>onConnectCallback?: ConnectHandler</code> Optional ConnectHandler instance. See here for details</li> </ul> </li> <li>Example <pre><code>import { ViteAPI } from '@vite/vitejs';\n// use http\n// import HTTP_RPC from '@vite/vitejs-http'\n// const provider = new HTTP_RPC('https://buidl.vite.net/gvite');\n\n// use websocket\nimport WS_RPC from '@vite/vitejs-ws';\nconst provider = new WS_RPC('wss://buidl.vite.net/gvite/ws');\n\nconst viteApi = new ViteAPI(provider, () =&gt; {\n    // Connected\n});\n</code></pre></li> </ul> <p>Note</p> <p><code>onConnectCallback</code> is added in 2.3.19.</p>"},{"location":"SDK/vitejs/viteapi-class/#methods","title":"Methods","text":""},{"location":"SDK/vitejs/viteapi-class/#getbalanceinfo","title":"<code>getBalanceInfo</code>","text":"<p>Fetch an address's balance (i.e. spendable assets) and unreceived balance (i.e. assets that cannot be spent yet because they do not have a receive block) - Parameters     - <code>address: Address</code> - Returns     - <code>Promise&lt;object&gt;</code>         - <code>Record&lt;'balance' | 'unreceived', object&gt;</code>             - <code>address: string</code>             - <code>blockCount: string</code>             - <code>balanceInfoMap?: object</code>                 - <code>[tokenId: string]: object</code>                     - <code>tokenInfo: TokenInfo</code>                     - <code>balance: string</code> - Example <pre><code>const address = 'vite_5e8d4ac7dc8b75394cacd21c5667d79fe1824acb46c6b7ab1f';\nviteApi.getBalanceInfo(address).then(({ balance, unreceived }) =&gt; {\n    console.log(balance, unreceived);\n});\n</code></pre></p>"},{"location":"SDK/vitejs/viteapi-class/#gettransactionlist","title":"<code>getTransactionList</code>","text":"<p>Fetch an address's transaction history - Parameters     - <code>object</code>         - <code>address: Address</code>         - <code>pageSize: number = 50</code> The number of transactions in the transaction list         - <code>pageIndex: number</code> The multiple of <code>pageSize</code> to offset the transaction list (i.e. <code>pageIndex = n</code> will give you the last transactions starting from <code>n * pageSize</code> to <code>n * pageSize + pageSize</code>)     - <code>decodeTxTypeList: 'all' | string[] = 'all'</code> The transaction types to decode the <code>contractParams</code> of. For default, all <code>contractParams</code> are decoded. - Returns:     - <code>Promise&lt;Transaction[]&gt;</code> If this <code>Promise</code> resolves, the <code>Transaction</code> array is ordered from newest to oldest transactions. - Example <pre><code>viteApi\n    .getTransactionList(\n        {\n            address: 'vite_5e8d4ac7dc8b75394cacd21c5667d79fe1824acb46c6b7ab1f',\n            pageIndex: 0,\n            pageSize: 10,\n        },\n        ['WithdrawSBPReward']\n    )\n    .then((txs) =&gt; {\n        console.log(txs);\n    });\n</code></pre></p>"},{"location":"SDK/vitejs/viteapi-class/#addtransactiontype","title":"<code>addTransactionType</code>","text":"<p>Extend the default contract methods - useful for when you want to tag the transactions of your own smart contract with a certain customized types. - Parameters     - <code>{ [transactionTypeName: string]: object }</code>         - <code>contractAddress: Address</code>         - <code>abi</code> ABI - Example <pre><code>const abi = { methodName: 'hello', inputs: [] };\nconst contractAddress = 'vite_0000000000000000000000000000000000000003f6af7459b9';\nviteAPI.addTransactionType({ helloWorld: { contractAddress, abi }});\n</code></pre></p>"},{"location":"SDK/vitejs/viteapi-class/#calloffchaincontract","title":"<code>callOffChainContract</code>","text":"<p>Call an offchain function of the contract.</p> <p>Note</p> <p>Offchain function is deprecated and replaced by view function in Solidity++ 0.8. If your contract is written with 0.8 or above version, use <code>queryContractState</code> instead.</p> <ul> <li>Parameters <ul> <li><code>object</code><ul> <li><code>address: Address</code> Address of contract</li> <li><code>abi</code> ABI of the offchain function</li> <li><code>code</code> Base64 encoded offchain code</li> <li><code>params: any[]</code> Base64 encoded passed-in parameters</li> </ul> </li> </ul> </li> <li>Return:<ul> <li><code>Promise&lt;any&gt;</code> Decoded calling result</li> </ul> </li> <li>Example <pre><code>const methodAbi = abiUtil.getAbiByName(contractAbi, 'get');\nviteApi.callOffChainContract({address: contractAddress, abi: methodAbi, code, params: [\"734782968573636608\",\"tti_5649544520544f4b454e6e40\"]})\n.then((result) =&gt; {\n    console.log(result);\n});\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/viteapi-class/#querycontractstate","title":"<code>queryContractState</code>","text":"<p>Call a view function or query a public state of the contract.</p> <p>Note</p> <p>Added in 2.3.18.</p> <ul> <li>Parameters <ul> <li><code>object</code><ul> <li><code>address: Address</code> Address of contract</li> <li><code>abi</code> ABI of the offchain function</li> <li><code>methodName</code> view functions's name</li> <li><code>params: any[]</code> Base64 encoded passed-in parameters</li> </ul> </li> </ul> </li> <li>Return:<ul> <li><code>Promise&lt;any&gt;</code> Decoded calling result</li> </ul> </li> <li>Example <pre><code>const methodName = 'tokenMap';\nviteApi.queryContractState({ address: contractAddress, abi: contractAbi, methodName, params: ['tti_30831c79099bbe5af0b037b1'] })\n.then((result) =&gt; {\n    console.log(result);\n});\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/viteapi-class/#getnonce","title":"<code>getNonce</code>","text":"<p>Return PoW nonce for the given difficulty, previous block hash and account address.</p> <ul> <li>Parameters <ul> <li><code>object</code><ul> <li><code>difficulty: BigInt</code> PoW difficulty</li> <li><code>previousHash: Hex</code> Hash of previous account block</li> <li><code>address: Address</code> Address</li> </ul> </li> </ul> </li> <li>Return:<ul> <li><code>Promise&lt;Base64&gt;</code> Nonce</li> </ul> </li> <li>Example <pre><code>viteApi.getNonce({ difficulty: 67108863, previousHash: '0000000000000000000000000000000000000000000000000000000000000000', address: 'vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a' })\n.then((nonce) =&gt; {\n    console.log(nonce);\n});\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/viteapi-class/#setprovider","title":"<code>setProvider</code>","text":"<p>Update the Connection Provider of a <code>ViteAPI</code> instance. - Parameters     - <code>provider: Connection Provider</code> New provider     - <code>onInitCallback: Function</code> Called when connection is established     - <code>abort: boolean</code> If <code>true</code>, the ongoing request connection of original provider will be interrupted. - Example <pre><code>const newProvider = new HTTP_RPC('https://buidl.vite.net/gvite')\nviteApi.setProvider(newProvider, () =&gt; {\n    // Connected\n}, true)\n</code></pre></p>"},{"location":"SDK/vitejs/viteapi-class/#request","title":"<code>request</code>","text":"<p>Call a method in the go-vite RPC API. - Parameters     - <code>methods: string</code> Name of API method     - <code>...args: any[]</code> API method arguments - Returns:     - <code>Promise&lt;any&gt;</code> RPC response - Example <pre><code>const address = 'vite_5e8d4ac7dc8b75394cacd21c5667d79fe1824acb46c6b7ab1f';\nviteApi.request('ledger_getLatestAccountBlock', address).then((block) =&gt; {\n    console.log(block);\n});\n</code></pre></p>"},{"location":"SDK/vitejs/viteapi-class/#sendnotification","title":"<code>sendNotification</code>","text":"<p>Call RPC API and do not return response - one use case is when calling ledger_sendRawTransaction. - Parameters     - <code>methods: string</code> Name of API method     - <code>...args: any[]</code> API method arguments - Returns:     - <code>Promise&lt;any&gt;</code> RPC response - Example <pre><code>viteApi.sendNotification('ledger_sendRawTransaction').then((requestObj) =&gt; {\n    console.log('requestObj:', requestObj)\n});\n</code></pre></p>"},{"location":"SDK/vitejs/viteapi-class/#batch","title":"<code>batch</code>","text":"<p>Call multiple RPC API methods at once</p> <ul> <li>Parameters</li> <li><code>object[]</code><ul> <li><code>type: 'request' | 'notification'</code></li> <li><code>methodName: string</code> Name of API method</li> <li><code>params: any</code> API method arguments</li> </ul> </li> <li>Returns:<ul> <li><code>Promise&lt;any[]&gt;</code> RPC responses</li> </ul> </li> <li>Example <pre><code>const address = 'vite_5e8d4ac7dc8b75394cacd21c5667d79fe1824acb46c6b7ab1f';\nviteApi\n    .batch([\n        {\n            type: 'request',\n            methodName: 'ledger_getSnapshotChainHeight',\n            params: [],\n        },\n        {\n            type: 'request',\n            methodName: 'ledger_getLatestAccountBlock',\n            params: [address],\n        },\n    ])\n    .then((data) =&gt; {\n        console.log(data);\n    })\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/viteapi-class/#subscribe","title":"<code>subscribe</code>","text":"<p>Subscribe to events according to the subscription RPC API</p> <p>Note: Polling will be used by this method if the RPC API connection was established with <code>HTTP_RPC</code>, otherwise a websocket subscription will be used for <code>WS_RPC</code>.</p> <ul> <li>Parameters<ul> <li><code>methodName: string</code><ul> <li><code>'newSnapshotBlock'</code></li> <li><code>'newAccountBlock'</code></li> <li><code>'newAccountBlockByAddress'</code></li> <li><code>'newUnreceivedBlockByAddress'</code></li> <li><code>'newVmLog'</code> <p>Note: Vite.js will automatically add prefixes/suffixes if necessary</p> </li> </ul> </li> <li><code>...args</code> Passed-in parameters</li> </ul> </li> <li>Returns:<ul> <li><code>Promise&lt;EventEmitter&gt;</code><ul> <li>The most useful method for external use in <code>EventEmitter</code> object is <code>EventEmitter.on</code>. Call this method to pass in a callback how subscription events should be handled.</li> </ul> </li> </ul> </li> <li>Example <pre><code>const address = 'vite_5e8d4ac7dc8b75394cacd21c5667d79fe1824acb46c6b7ab1f';\nviteApi\n    .subscribe('newAccountBlockByAddress', address)\n    .then((event) =&gt; {\n        event.on((result) =&gt; {\n            console.log(result);\n        });\n        // event.off();\n    })\n    .catch((e) =&gt; {\n        console.log('e:', e);\n    });\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/viteapi-class/#unsubscribe","title":"<code>unsubscribe</code>","text":"<p>Cancel a subscription by <code>event</code> reference - Parameters     - <code>event: EventEmitter</code> Resolved by the <code>Promise</code> <code>ViteAPI.subscribe</code> returns</p> <ul> <li>Example <pre><code>let event\nviteApi.subscribe('newAccountBlock').then((e) =&gt; {\n    event = e;\n})\n\nconst unsubscribe = () =&gt; {\n    viteApi.unsubscribe(event);\n}\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/viteapi-class/#unsubscribeall","title":"<code>unsubscribeAll</code>","text":"<p>Cancel all subscriptions - Parameters     - None - Example <pre><code>viteApi.unsubscribeAll();\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/","title":"Module","text":""},{"location":"SDK/vitejs/account-block/#what-is-account-block","title":"What is Account Block?","text":"<p>Vite adopts the ledger structure of DAG (Directed Acyclic Graph). Each account has a chain composed of a list of account blocks.</p> <p>Let's look at the process that account A sends a transaction to account B. First, account A creates an <code>AccountBlock</code> instance with <code>toAddress</code> set to the address of account B; account A signs the transaction and sends it; when the transaction is confirmed, the transfer is done.</p> <p>The most common <code>AccountBlock</code> must contain four pieces of information as follows: 1. The recipient's address 2. The token id 3. The amount of token to send 4. The hash of last account block so that the current account block can link to it</p> <p>Note: for response transactions, the recipient's address is not required, instead, you need to provide the send block hash.</p> <p>See here for more information about account block and account chain.</p>"},{"location":"SDK/vitejs/account-block/#module-import","title":"Module Import","text":"<pre><code>import { accountBlock } from '@vite/vitejs';\nconst { createAccountBlock, utils, AccountBlock } = accountBlock;\n</code></pre>"},{"location":"SDK/vitejs/account-block/#methods","title":"Methods","text":""},{"location":"SDK/vitejs/account-block/#createaccountblock","title":"<code>createAccountBlock</code>","text":"<p>Create an <code>AccountBlock</code> instance with a given type - Parameters      - <code>transactionType: string</code> See Transaction Types below for possible transaction types     - <code>params: object</code> See Transaction Types below for possible parameters - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('receive', {\n    address: account.address,\n    sendBlockHash: '44e69ea04fe830c9075c01e46f102d0c543b4119ce13ec575aee2e96501049fc',\n});\nblock.setProvider(viteApi);\nblock.setPrivateKey(account.privateKey);\nawait block.autoSetPreviousAccountBlock();\nblock.sign(account.privateKey);\nawait block.autoSend();\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#transaction-types","title":"Transaction Types","text":"<p>The possible transaction types that are accepted by <code>createAccountBlock</code> method are listed below. In fact, they are methods of <code>Account</code> class that we will cover in Account Class chapter.</p>"},{"location":"SDK/vitejs/account-block/#receive","title":"<code>receive</code>","text":"<p>Transaction type for receiving unreceived transactions - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account         - <code>sendBlockHash: Hex</code> Hash of the request transaction - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('receive', { // blockType: 4\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    sendBlockHash: '156a47de8b5a690562278360e41e337ee4f1b4aa8d979f377beb0cc70f939032'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#send","title":"<code>send</code>","text":"<p>Transaction type for sending a transaction - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account         - <code>toAddress: Address</code> Transaction recipient's address         - <code>tokenId: TokenId = Vite_TokenId</code> Token id. The default token is VITE         - <code>amount: BigInt = '0'</code> Amount of tokens to send (in base unit, e.g. <code>1000000000000000000</code> stands for 1 VITE)         - <code>data?: Base64</code> Additional data - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('send', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    toAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    amount: '1000000000000000000',\n    data: 'pinFMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#createcontract","title":"<code>createContract</code>","text":"<p>Block type for creating a smart contract - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account         - <code>code: Hex</code> Complied code of contract in hex format         - <code>responseLatency: Uint8 = '0'</code> See Response Latency         - <code>quotaMultiplier: Uint8 = '10'</code> See Quota Multiplier         - <code>randomDegree: Uint8 = '0'</code> See Random Degree         - <code>abi?: object | Array&lt;object&gt;</code> ABI of the constructor. If your contract doesn't have a constructor, ignore this field.         - <code>params?: string | Array&lt;string | boolean&gt;</code> Passed-in parameter(s) of the constructor. If your contract doesn't have a constructor, ignore this field. - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('createContract', { // blockType: 1\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    abi:{\"inputs\":[{\"name\": \"addr\",\"type\": \"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},\n    code: '608060405234801561001057600080fd5b50610141806100206000396000f3fe608060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806391a6cb4b14610046575b600080fd5b6100896004803603602081101561005c57600080fd5b81019080803574ffffffffffffffffffffffffffffffffffffffffff16906020019092919050505061008b565b005b8074ffffffffffffffffffffffffffffffffffffffffff164669ffffffffffffffffffff163460405160405180820390838587f1505050508074ffffffffffffffffffffffffffffffffffffffffff167faa65281f5df4b4bd3c71f2ba25905b907205fce0809a816ef8e04b4d496a85bb346040518082815260200191505060405180910390a25056fea165627a7a7230582023e9669dd6fec3b6b2a84a1fd7c9939f49197203d0e1db312278e633c219c2480029',\n    responseLatency: 2,\n    params: ['vite_13f1f8e230f2ffa1e030e664e525033ff995d6c2bb15af4cf9']\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#callcontract","title":"<code>callContract</code>","text":"<p>Block type for calling a contract - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account         - <code>toAddress: Address</code> Address of contract         - <code>abi: object | Array&lt;object&gt;</code> ABI         - <code>methodName?: string</code> Name of the method to call         - <code>params?: any = []</code> Passed-in parameters         - <code>tokenId: TokenId = Vite_TokenId</code> Token id         - <code>amount: BigInt = '0'</code> Amount of tokens to send (in base unit, e.g. <code>1000000000000000000</code> stands for 1 VITE)         - <code>fee: BigInt = '0'</code> Transaction fee - Returns     - <code>AccountBlock</code> instance - Example <pre><code>import { constant } from '~@vite/vitejs';\nconst { Contracts, Vite_TokenId } = constant;\n\nconst block = createAccountBlock('callContract', {\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    abi: Contracts.RegisterSBP.abi,\n    toAddress: Contracts.RegisterSBP.contractAddress,\n    params: ['sbpName', blockProducingAddress, rewardWithdrawAddress],\n    tokenId: Vite_TokenId,\n    amount: '1000000' + '0'.repeat(18),\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#registersbp","title":"<code>registerSBP</code>","text":"<p>Block type for registering an SBP</p> <p>Note: To register an SBP node, transferring 1,000,000 <code>VITE</code> is required. The transferred VITE will be locked for 7,776,000 snapshot blocks (about 3 months), after which it can be withdrawn if you choose to cancel your SBP. - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account (i.e. SBP Registration Address)         - <code>sbpName: string</code> See SBP name         - <code>blockProducingAddress: Address</code> See Block Creation Address         - <code>rewardWithdrawAddress: Address</code> See Reward Withdrawal Address         - <code>amount: BigInt = '1000000000000000000000000'</code> A default amount of 1M VITE is required for SBP registration. - Returns     - <code>AccountBlock</code> instance - Example <pre><code>    const block = createAccountBlock('registerSBP', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    sbpName: 'TEST_NODE',\n    blockProducingAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    rewardWithdrawAddress: 'vite_5e8d4ac7dc8b75394cacd21c5667d79fe1824acb46c6b7ab1f',\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#updatesbpblockproducingaddress","title":"<code>updateSBPBlockProducingAddress</code>","text":"<p>Block type for updating an SBP's block producing address - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account - must be the SBP's registration address.         - <code>sbpName: string</code> Name of the SBP         - <code>blockProducingAddress: Address</code> New block producing address - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('updateSBPBlockProducingAddress', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    sbpName: 'TEST_NODE',\n    blockProducingAddress: 'vite_5e8d4ac7dc8b75394cacd21c5667d79fe1824acb46c6b7ab1f',\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#revokesbp","title":"<code>revokeSBP</code>","text":"<p>Block type for cancelling an SBP - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account - must be the SBP's registration address.         - <code>sbpName: string</code> Name of the SBP - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('revokeSBP', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    sbpName: 'TEST_NODE'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#withdrawsbpreward","title":"<code>withdrawSBPReward</code>","text":"<p>Block type for withdrawing an SBP's mining rewards - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account - must be the SBP's registration address.         - <code>sbpName: string</code> Name of the SBP         - <code>receiveAddress: Address</code> An address to receive rewards - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('withdrawSBPReward', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    sbpName: 'TEST_NODE',\n    receiveAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#voteforsbp","title":"<code>voteForSBP</code>","text":"<p>Block type for voting for an SBP - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account         - <code>sbpName: string</code> Name of the SBP - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('voteForSBP', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    sbpName: 'TEST_NODE'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#cancelsbpvoting","title":"<code>cancelSBPVoting</code>","text":"<p>Block type for cancelling voting - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('cancelSBPVoting', {\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#stakeforquota","title":"<code>stakeForQuota</code>","text":"<p>Block type for supply a beneficiary address with quota - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account         - <code>beneficiaryAddress: Address</code> Address of quota beneficiary         - <code>amount: BigInt</code> Amount of VITE to lock (in base unit, e.g. <code>134000000000000000000</code> stands for 134 VITE)     &gt; Note: the minimum locking amount is 134 VITE. - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('stakeForQuota', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    beneficiaryAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    amount: '134' + '0'.repeat(18),\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#cancelquotastake","title":"<code>cancelQuotaStake</code>","text":"<p>Block type for cancelling locking for quota and withdrawing the locked tokens. - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account         - <code>id: string</code> Locking id - referring to the hash of the locking transaction. - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('cancelQuotaStake', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    id: '401d46c2330d3c76c8f0da6be2a24b17c5e3ece9c28d80a74e91146d1f95ad2e'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#issuetoken","title":"<code>issueToken</code>","text":"<p>Block type for creating a new token</p> <p>Note: An issuance fee of 1,000 VITE will be charged from the account of the owner who will subsequently receive an amount of issued tokens equivalent to the total initial supply. The token owner in the context of issuing a new token will not have control of the tokens sent to other accounts. See here for more information.</p> <ul> <li>Parameters <ul> <li><code>object</code><ul> <li><code>address: Address</code> Address of account (i.e. token owner)</li> <li><code>tokenName: string</code> Name of token in 1-40 characters. See Token Name.</li> <li><code>tokenSymbol: string</code> Symbol of token in 1-10 characters. See Token Symbol.</li> <li><code>decimals: Uint8</code> See Decimals</li> <li><code>maxSupply: Uint256</code> See Max Supply. For non-reissuable token, fill in <code>0</code>.</li> <li><code>totalSupply: Uint256</code> See Total Supply. For re-issuable tokens, this is the initial supply</li> <li><code>isReIssuable: boolean</code> See ReIssuable Flag</li> <li><code>isOwnerBurnOnly: boolean</code> Only applies to re-issuable token. If <code>true</code>, the token can only burned by owner. For non-re-issuable token, fill in <code>false</code>. <p>Note: <code>isOwnerBurnOnly</code> is deprecated and removed from the latest go-vite release.</p> </li> </ul> </li> </ul> </li> <li>Returns<ul> <li><code>AccountBlock</code> instance</li> </ul> </li> <li>Example <pre><code>const block = createAccountBlock('issueToken', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    tokenName: 'TestCoin', \n    isReIssuable: true, \n    maxSupply: '10000000000000000000000000', \n    isOwnerBurnOnly: false, \n    totalSupply: '100000000000000000000000', \n    decimals: 2, \n    tokenSymbol: 'TEST'\n});\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/account-block/#reissuetoken","title":"<code>reIssueToken</code>","text":"<p>Block type for re-issuing additional amount of tokens</p> <p>Note: A re-issuable token's owner can mint additional amount of tokens by re-issuance - not applicable to non-re-issuable tokens and only the owner of the token can do this. - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account (i.e. token owner)         - <code>tokenId: TokenId</code> Token id         - <code>amount: BigInt</code> Amount of tokens to mint (in base unit, e.g. <code>1000000000000000000000</code> stands for <code>1000</code> for a 18-decimal token)         - <code>receiveAddress: Address</code> Address to receive newly minted tokens - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('reIssueToken', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    tokenId: 'tti_f1fdb1fce23ca4a2c760012c',\n    amount: '1000000000000000000000',\n    receiveAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#burntoken","title":"<code>burnToken</code>","text":"<p>Block type for burning tokens</p> <p>Note: Re-issuable tokens can be burned by sending the amount of tokens to the built-in token issuance contract - not applicable to non-re-issuable tokens. - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account         - <code>tokenId: TokenId</code> Token id         - <code>amount: BigInt</code> Amount of tokens to mint (in base unit, e.g. <code>1000000000000000000000</code> stands for <code>1000</code> for a 18-decimal token) - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('burnToken', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    amount: '1000000000000000000000'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#disablereissuetoken","title":"<code>disableReIssueToken</code>","text":"<p>Block type for changing a re-issuable token to non-re-issuable</p> <p>Note</p> <p>Only the owner of the token can do this.</p> <p>Warning</p> <p>This action cannot be reversed</p> <ul> <li>Parameters <ul> <li><code>object</code><ul> <li><code>address: Address</code> Address of account (i.e. token owner)</li> <li><code>tokenId: TokenId</code> Token id</li> </ul> </li> </ul> </li> <li>Returns<ul> <li><code>AccountBlock</code> instance</li> </ul> </li> <li>Example <pre><code>const block = createAccountBlock('disableReIssueToken', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    tokenId: 'tti_5649544520544f4b454e6e40'\n});\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/account-block/#transfertokenownership","title":"<code>transferTokenOwnership</code>","text":"<p>Block type for transferring a token's ownership</p> <p>Note: only applicable to re-issuable tokens and only the owner of the token can do this. - Parameters      - <code>object</code>         - <code>address: Address</code> Address of account (i.e. token owner)         - <code>tokenId</code>: <code>string tokenId</code> Token id         - <code>newOwnerAddress</code>: <code>string address</code> Address of new owner - Returns     - <code>AccountBlock</code> instance - Example <pre><code>const block = createAccountBlock('transferTokenOwnership', { // blockType: 2\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    newOwnerAddress: 'vite_869a06b8963bd5d88a004723ad5d45f345a71c0884e2c80e88'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#utils-methods","title":"<code>utils</code> Methods","text":""},{"location":"SDK/vitejs/account-block/#isvalidaccountblockwithouthash","title":"<code>isValidAccountBlockWithoutHash</code>","text":"<p>Determine if an account block is valid regardless of block hash - Parameters      - <code>accountBlock: object</code> Fields are described above in Properties         - <code>blockType: BlockType</code>         - <code>address: Address</code>         - <code>height: Uint64</code>         - <code>previousHash: Hex</code>         - <code>fee?: BigInt</code>         - <code>amount?: BigInt</code>         - <code>toAddress?: Address</code>         - <code>tokenId?: TokenId</code>         - <code>data?: Base64</code>         - <code>sendBlockHash?: Hex</code>         - <code>difficulty?: BigInt</code>         - <code>nonce?: Base64</code> - Returns     - <code>boolean</code> If <code>true</code>, the account block is valid - Example <pre><code>const isValid = utils.isValidAccountBlockWithoutHash({\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    amount: '1000000000000000000',\n    blockType: 2,\n    data: 'pinFMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB',\n    fee: '0',\n    height: '105',\n    previousHash: '558c6873d27c903ec9067cf54432e9d16d9b31474adab165ad1f6cc392beeb8d',\n    toAddress: 'vite_0000000000000000000000000000000000000004d28108e76b',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n}); // true\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#isvalidaccountblockwithoutsignature","title":"<code>isValidAccountBlockWithoutSignature</code>","text":"<p>Determine if an account block is valid regardless of signature - Parameters      - <code>accountBlock: object</code> Fields are described above in Properties         - <code>blockType: BlockType</code>         - <code>address: Address</code>         - <code>height: Uint64</code>         - <code>previousHash: Hex</code>         - <code>hash: Hex</code>         - <code>fee?: BigInt</code>         - <code>amount?: BigInt</code>         - <code>toAddress?: Address</code>         - <code>tokenId?: TokenId</code>         - <code>data?: Base64</code>         - <code>sendBlockHash?: Hex</code>         - <code>difficulty?: BigInt</code>         - <code>nonce?: Base64</code> - Returns     - <code>boolean</code> If <code>true</code>, the account block is valid - Example <pre><code>const isValid = utils.isValidAccountBlockWithoutSignature({\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    amount: '1000000000000000000',\n    blockType: 2,\n    data: 'pinFMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB',\n    fee: '0',\n    hash: '156a47de8b5a690562278360e41e337ee4f1b4aa8d979f377beb0cc70f939032',\n    height: '105',\n    previousHash: '558c6873d27c903ec9067cf54432e9d16d9b31474adab165ad1f6cc392beeb8d',\n    toAddress: 'vite_0000000000000000000000000000000000000004d28108e76b',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n}); // true\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#isvalidaccountblock","title":"<code>isValidAccountBlock</code>","text":"<p>Determine if an account block is complete and ready to be sent  - Parameters      - <code>accountBlock: object</code> Fields are described above in Properties         - <code>blockType: BlockType</code>         - <code>address: Address</code>         - <code>height: Uint64</code>         - <code>previousHash: Hex</code>         - <code>hash: Hex</code>         - <code>signature: Base64</code>         - <code>publicKey: Base64</code>         - <code>fee?: BigInt</code>         - <code>amount?: BigInt</code>         - <code>toAddress?: Address</code>         - <code>tokenId?: TokenId</code>         - <code>data?: Base64</code>         - <code>sendBlockHash?: Hex</code>         - <code>difficulty?: BigInt</code>         - <code>nonce?: Base64</code> - Returns     - <code>boolean</code> If <code>true</code>, the account block is valid. - Example <pre><code>const { address, privateKey } = wallet.createAddressByPrivateKey();\nconst block = createAccountBlock('receive', {\n    address,\n    sendBlockHash: '558c6873d27c903ec9067cf54432e9d16d9b31474adab165ad1f6cc392beeb8d',\n});\nblock.setProvider(viteApi);\nblock.setPrivateKey(privateKey);\nawait block.autoSetPreviousAccountBlock();\nblock.sign(privateKey);\nconst isValid = utils.isValidAccountBlock(block); // true\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#getaccountblockhash","title":"<code>getAccountBlockHash</code>","text":"<p>Calculate the hash of an account block</p> <p>Tip</p> <p>Prefer using <code>block.hash</code> as this will give you the hash of a valid account block. If a block is invalid, <code>block.hash</code> will return <code>null</code>.</p> <ul> <li>Parameters<ul> <li><code>accountBlock: object</code> Fields are described above in Properties<ul> <li><code>blockType: BlockType</code></li> <li><code>address: Address</code></li> <li><code>hash?: Hex</code></li> <li><code>height?: Uint64</code></li> <li><code>previousHash?: Hex</code></li> <li><code>fromAddress?: Address</code></li> <li><code>toAddress?: Address</code></li> <li><code>sendBlockHash?: Hex</code></li> <li><code>tokenId?: TokenId</code></li> <li><code>amount?: BigInt</code></li> <li><code>fee?: BigInt</code></li> <li><code>data?: Base64</code></li> <li><code>difficulty?: BigInt</code></li> <li><code>nonce?: Base64</code></li> <li><code>vmlogHash?: Hex</code></li> <li><code>triggeredSendBlockList?: AccountBlockType[]</code></li> </ul> </li> </ul> </li> <li>Returns<ul> <li><code>Hex</code> Hash of AccountBlock</li> </ul> </li> <li>Example <pre><code>const hash = utils.getAccountBlockHash({\n    address: 'vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a',\n    blockType: 2,\n    previousHash: 'd517e8d4dc9c676876b72ad0cbb4c45890804aa438edd1f171ffc66276202a95',\n    height: '2',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    toAddress: 'vite_13f1f8e230f2ffa1e030e664e525033ff995d6c2bb15af4cf9',\n    amount: '1000000000000000000000000',\n});\n\nconst block = createAccountBlock('receive', {\n    address,\n    sendBlockHash: '558c6873d27c903ec9067cf54432e9d16d9b31474adab165ad1f6cc392beeb8d',\n});\nconst hash = utils.getAccountBlockHash(block);\nconsole.log('hash:', hash); // b8db850e1a71d028e5e0e24045bce033b5e430e3da84b524de254a2a6f61fc1d\nconsole.log('block.hash:', block.hash); // null\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/account-block/#signaccountblock","title":"<code>signAccountBlock</code>","text":"<p>Calculate the signature of a signed account block. </p> <p>Tip</p> <p>Use the <code>block.sign</code> method to automatically set the signature and public key of the block. See here for details.</p> <ul> <li>Parameters<ul> <li><code>accountBlock: object</code> Fields are described above in Properties<ul> <li><code>address: Address</code></li> <li><code>blockType: BlockType</code></li> <li><code>hash: Hex</code></li> <li><code>height: Uint64</code></li> <li><code>previousHash: Hex</code></li> <li><code>toAddress?: Address</code></li> <li><code>tokenId?: TokenId</code></li> <li><code>amount?: BigInt</code></li> <li><code>sendBlockHash?: Hex</code></li> <li><code>data?: Base64</code></li> <li><code>fee?: BigInt</code></li> <li><code>difficulty?: BigInt</code></li> <li><code>nonce?: Base64</code></li> </ul> </li> <li><code>privateKey: Hex</code> </li> </ul> </li> <li>Returns<ul> <li><code>object</code><ul> <li><code>signature: Base64</code></li> <li><code>publicKey: Base64</code></li> </ul> </li> </ul> </li> <li>Example <pre><code>const { address, privateKey } = wallet.createAddressByPrivateKey();\nconst blockProps = {\n    address,\n    blockType: 2,\n    previousHash: 'd517e8d4dc9c676876b72ad0cbb4c45890804aa438edd1f171ffc66276202a95',\n    height: '2',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    toAddress: 'vite_13f1f8e230f2ffa1e030e664e525033ff995d6c2bb15af4cf9',\n    amount: '1000000000000000000000000',\n};\nconst hash = utils.getAccountBlockHash(blockProps);\nconst { signature, publicKey } = utils.signAccountBlock(\n    {\n        hash,\n        ...blockProps,\n    },\n    privateKey,\n);\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/account-block/#messagetodata","title":"<code>messageToData</code>","text":"<p>Encode a message string into base64 format according to VEP-8.</p> <ul> <li>Parameters<ul> <li><code>message: string</code> Message</li> </ul> </li> <li>Returns<ul> <li><code>Base64</code> Base64 encoded message</li> </ul> </li> <li>Example <pre><code>const data = utils.messageToData('1212hhhh');\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/account-block/#isrequestblock","title":"<code>isRequestBlock</code>","text":"<p>Determine if an account block is request transaction based on its <code>blockType</code> - Parameters     - <code>blockType: BlockType</code> See Block Type - Returns     - <code>boolean</code> If <code>true</code>, the block is a request transaction. - Example <pre><code>const block = createAccountBlock('send', {\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    toAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    amount: '1000000000000000000',\n});\nconsole.log(utils.isRequestBlock(block.blockType)); // true\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#isresponseblock","title":"<code>isResponseBlock</code>","text":"<p>Determine if an account block is response transaction based on its <code>blockType</code> - Parameters     - <code>blockType: BlockType</code> See Block Type - Returns     - <code>boolean</code> If <code>true</code>, the block is a response transaction. - Example <pre><code>const block = createAccountBlock('receive', {\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    sendBlockHash: '156a47de8b5a690562278360e41e337ee4f1b4aa8d979f377beb0cc70f939032',\n});\nconsole.log(utils.isResponseBlock(block.blockType)); // true\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#getcreatecontractdata","title":"<code>getCreateContractData</code>","text":"<p>Generate data of <code>AccountBlock</code> for creating smart contract - Parameters     - <code>object</code>         - <code>code: Hex</code> Complied code of contract in hex format         - <code>responseLatency: Uint8 = '0'</code> See Response Latency         - <code>quotaMultiplier: Uint8 = '10'</code> See Quota Multiplier         - <code>randomDegree: Uint8 = '0'</code> See Random Degree         - <code>abi?: object | Array&lt;object&gt;</code> ABI of the constructor. If your contract doesn't have a constructor, ignore this field.         - <code>params?: string | Array&lt;string | boolean&gt;</code> Passed-in parameter(s) of the constructor. If your contract doesn't have a constructor, ignore this field. - Returns     - <code>Base64</code>: Encoded data string - Example <pre><code>const data = utils.getCreateContractData({\n    responseLatency: '2',\n    randomDegree: '1',\n    quotaMultiplier: '10',\n    code: '608060405234801561001057600080fd5b506101ca806100206000396000f3fe608060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806380ae0ea114610046575b600080fd5b6100bd6004803603602081101561005c57600080fd5b810190808035906020019064010000000081111561007957600080fd5b82018360208201111561008b57600080fd5b803590602001918460208302840111640100000000831117156100ad57600080fd5b90919293919293905050506100bf565b005b60006002838390508115156100d057fe5b061415156100dd57600080fd5b600080905060008090505b8383905081101561018a576000848483818110151561010357fe5b9050602002013590506000858560018501818110151561011f57fe5b905060200201359050808401935080841015151561013c57600080fd5b600081111561017d578173ffffffffffffffffffffffffffffffffffffffff164669ffffffffffffffffffff168260405160405180820390838587f1505050505b50506002810190506100e8565b50348114151561019957600080fd5b50505056fea165627a7a723058203cef4a3f93b33e64e99e0f88f586121282084394f6d4b70f1030ca8c360b74620029',\n    params: '',\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#getcallcontractdata","title":"<code>getCallContractData</code>","text":"<p>Generate data of <code>AccountBlock</code> for calling a contract - Parameters     - <code>object</code>         - <code>abi: object | Array&lt;object&gt;</code> ABI         - <code>methodName?: string</code> Name of the method to call         - <code>params?: any = []</code> Passed-in parameters - Returns     - <code>Base64</code>: Encoded data string - Example <pre><code>import { constant } from '~@vite/vitejs';\nconst { Contracts, Snapshot_Gid } = constant;\n\nconst params = [ Snapshot_Gid, 'SBP Name', 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2' ];\nconst abi = Contracts.RegisterSBP.abi;\n// It's ok to omit methodName only if the abi contains one method\nconst data = utils.getCallContractData({ params, abi });\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/#gettransactiontype","title":"<code>getTransactionType</code>","text":"<p>Return the Transaction Type of a contract call - Parameters     - <code>object</code>         - <code>toAddress?: Address</code> Address of contract         - <code>data?: Base64</code> Data of the account block         - <code>blockType: BlockType</code> Block type - Returns     - <code>txType : TxType</code> Transaction type - Example <pre><code>const block = accountBlock.createAccountBlock('cancelSBPVoting', {\n    address: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n});\nconsole.log(accountBlock.utils.getTransactionType(block));\n// {\n//  transactionType: 'CancelSBPVoting',\n//  contractAddress: 'vite_0000000000000000000000000000000000000004d28108e76b',\n//  abi: { type: 'function', name: 'CancelSBPVoting', inputs: [] }\n// }\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/","title":"<code>AccountBlock</code> Instance","text":"<p>Instance of <code>AccountBlock</code> represents an account block on the Vite blockchain. </p> <p>Account Block and Transaction</p> <p>On Vite, usually one account block contains only one transaction. So in many cases when we say account block, it also refers to a transaction, and vise versa. However, this rule doesn't apply to RS blocks, which are special account blocks produced by smart contracts containing more than one transaction. See RS Blocks for details.</p>"},{"location":"SDK/vitejs/account-block/account-block-class/#block-types","title":"Block Types","text":"<p>There are a total of seven block types on Vite.</p> Block Type ID Description Type <code>CreateContractRequest</code> 1 Create Contract Request <code>TransferRequest</code> 2 Send Transaction / Call Contract Request <code>ReIssueRequest</code> 3 Mint Token Request <code>Response</code> 4 Receive Transaction / Execute Contract Response <code>ResponseFail</code> 5 Execute Contract Failed Response <code>RefundByContractRequest</code> 6 Refund Request <code>GenesisResponse</code> 7 Genesis Response"},{"location":"SDK/vitejs/account-block/account-block-class/#properties","title":"Properties","text":"Name Type Description blockType <code>BlockType</code> See Block Types for possible account block types on Vite address <code>Address</code> Address of this account. For request transaction, this is <code>fromAddress</code>; for response transaction, this is <code>toAddress</code> fee <code>BigInt</code> Transaction fee data <code>Base64</code> Optional data field in Base64 format sendBlockHash <code>Hex</code> Hash of the request transaction. For response transaction only toAddress <code>Address</code> Transaction receiving address tokenId <code>TokenId</code> Token id amount <code>BigInt</code> The amount of tokens to send (in base unit, e.g. <code>1000000000000000000</code> stands for 1 VITE) height <code>Uint64</code> Height of this account block previousHash <code>Hex</code> Hash of the previous account block difficulty <code>BigInt</code> PoW difficulty nonce <code>Base64</code> PoW nonce hash <code>Hex</code> Hash of this account block signature <code>Base64</code> Signature publicKey <code>Base64</code> Public key of this account originalAddress <code>originalAddress</code> Original address isRequestBlock <code>boolean</code> If <code>true</code>, the block is a request transaction isResponseBlock <code>boolean</code> If <code>true</code>, the block is a response transaction <ul> <li>Constructor<ul> <li><code>object</code> Fields are described above in Properties<ul> <li><code>blockType: BlockType</code></li> <li><code>address: Address</code></li> <li><code>fee?: BigInt</code></li> <li><code>data?: Base64</code></li> <li><code>sendBlockHash?: Hex</code></li> <li><code>amount?: BigInt</code></li> <li><code>toAddress?: Address</code></li> <li><code>tokenId?: TokenId</code></li> </ul> </li> <li><code>provider?: ProviderType</code> <code>ViteAPI</code> instance</li> <li><code>privateKey?: Hex</code> Private key used for signing the block</li> </ul> </li> <li>Example <pre><code>import { wallet, accountBlock } from '@vite/vitejs';\nconst { AccountBlock } = accountBlock;\n\nconst myWallet = wallet.createWallet();\nconst { address } = myWallet.deriveAddress(0);\n\n// block for sending 1 VITE\nconst block = new AccountBlock({\n    blockType: 2,\n    address,\n    toAddress: 'vite_5e8d4ac7dc8b75394cacd21c5667d79fe1824acb46c6b7ab1f',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    amount: '1' + '0'.repeat(18),\n});\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/account-block/account-block-class/#methods","title":"Methods","text":""},{"location":"SDK/vitejs/account-block/account-block-class/#setprovider","title":"<code>setProvider</code>","text":"<p>Set the <code>ViteAPI</code> instance of an <code>AccountBlock</code> instance for making requests to go-vite RPC API - Parameters:     - <code>ViteAPI</code> <code>ViteAPI</code> instance - Returns:     - this <code>AccountBlock</code> instance - Example <pre><code>import { wallet, ViteAPI, accountBlock } from '@vite/vitejs';\nconst { AccountBlock } = accountBlock;\nimport WS_RPC from '@vite/vitejs-ws';\n\nconst providerWsURLs = {\n    localnet: 'ws://localhost:23457',\n    testnet: 'wss://buidl.vite.net/gvite/ws',\n    mainnet: 'wss://node.vite.net/gvite/ws',\n};\nconst provider = new WS_RPC(providerWsURLs.testnet);\nconst viteApi = new ViteAPI(provider, () =&gt; {});\n\nconst myWallet = wallet.createWallet();\nconst { address } = myWallet.deriveAddress(0);\n\nconst block = new AccountBlock({\n    blockType: 2,\n    address,\n    toAddress: 'vite_5e8d4ac7dc8b75394cacd21c5667d79fe1824acb46c6b7ab1f',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    amount: '1' + '0'.repeat(18),\n}).setProvider(viteApi);\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#setprivatekey","title":"<code>setPrivateKey</code>","text":"<p>Set the private key of an <code>AccountBlock</code> instance for signing - Parameters:     - <code>Hex</code> private key - Returns:     - this <code>AccountBlock</code> instance - Example <pre><code>const myWallet = wallet.createWallet();\nconst { address, privateKey } = myWallet.deriveAddress(0);\nblock.setPrivateKey(privateKey);\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#getpreviousaccountblock","title":"<code>getPreviousAccountBlock</code>","text":"<p>Get the previous block of an <code>AccountBlock</code> instance - Parameters:     - None - Returns:     - <code>Promise&lt;AccountBlockType&gt;</code> - Example <pre><code>block.setProvider(viteApi);\nconst lastBlock = await block.getPreviousAccountBlock();\n</code></pre></p> <p>Note: <code>ViteAPI</code> must exist on the <code>AccountBlock</code> before calling this method on it; one way to do this is to call its <code>setProvider</code> method first.</p>"},{"location":"SDK/vitejs/account-block/account-block-class/#setpreviousaccountblock","title":"<code>setPreviousAccountBlock</code>","text":"<p>Set the <code>previousHash</code> of an <code>AccountBlock</code> instance to the hash of the block passed in as an argument. If the block passed in as an argument has no <code>hash</code>, the <code>previousHash</code> will be set to <code>0000000000000000000000000000000000000000000000000000000000000000</code>. - Parameters:     - <code>previousAccountBlock: AccountBlockType</code> - Returns:     - this <code>AccountBlock</code> instance - Example <pre><code>block.setProvider(viteApi);\nblock.setPreviousAccountBlock(await block.getPreviousAccountBlock());\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#autosetpreviousaccountblock","title":"<code>autoSetPreviousAccountBlock</code>","text":"<p>Get and set the <code>previousHash</code> of an <code>AccountBlock</code> instance. This combines the <code>getPreviousAccountBlock</code> and <code>setPreviousAccountBlock</code> methods. - Parameters:     - None - Returns:     - <code>Promise&lt;{ height: Uint64; previousHash: Hex }&gt;</code> - Example <pre><code>block.setProvider(viteApi);\nblock.autoSetPreviousAccountBlock().then(({ height, previousHash }) =&gt; {\n    console.log('height', height);\n    console.log('previousHash', previousHash);\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#getdifficulty","title":"<code>getDifficulty</code>","text":"<p>Get the PoW difficulty for sending an <code>AccountBlock</code> instance. If the sending <code>address</code> of the <code>AccountBlock</code> instance has sufficient quota to send the block, the returned <code>Promise</code> will resolve with <code>''</code>.</p> <p>Note: <code>previousHash</code> must exist on the <code>AccountBlock</code> instance before calling this method on it; one way to do this is to call its <code>autoSetPreviousAccountBlock</code> method first. - Parameters:     - None - Returns     - <code>Promise&lt;BigInt&gt;</code> PoW difficulty - Example <pre><code>block.setProvider(viteApi);\nawait block.autoSetPreviousAccountBlock();\nconst difficulty = await block.getDifficulty();\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#setdifficulty","title":"<code>setDifficulty</code>","text":"<p>Set the PoW difficulty for an <code>AccountBlock</code> instance - Parameters:     - <code>difficulty: BigInt</code> PoW difficulty - Returns:     - this <code>AccountBlock</code> instance - Example <pre><code>block.setProvider(viteApi);\nawait block.autoSetPreviousAccountBlock();\nconst difficulty = await block.getDifficulty();\nblock.setDifficulty(difficulty);\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#autosetdifficulty","title":"<code>autoSetDifficulty</code>","text":"<p>Get and set the PoW difficulty for an <code>AccountBlock</code> instance. This combines the <code>getDifficulty</code> and <code>setDifficulty</code> methods.</p> <p>Note: <code>previousHash</code> must exist on the <code>AccountBlock</code> instance before calling this method on it; one way to do this is to call its <code>autoSetPreviousAccountBlock</code> method first. - Parameters:     - None - Returns:     - <code>Promise&lt;BigInt&gt;</code> PoW difficulty - Example <pre><code>await block.autoSetPreviousAccountBlock();\nawait block.autoSetDifficulty();\nconsole.log(block.difficulty);\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#getnonce","title":"<code>getNonce</code>","text":"<p>Get the PoW nonce for an <code>AccountBlock</code> instance</p> <p>Note: <code>difficulty</code> must exist on the <code>AccountBlock</code> instance before calling this method on it; one way to do this is to call its <code>autoSetDifficulty</code> method first. - Parameters:     - None - Returns:     - <code>Promise&lt;Base64&gt;</code> Nonce - Example <pre><code>block.setProvider(viteApi);\nawait block.autoSetPreviousAccountBlock();\nawait block.autoSetDifficulty();\nconst nonce = await block.getNonce();\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#setnonce","title":"<code>setNonce</code>","text":"<p>Set the PoW nonce for an <code>AccountBlock</code> instance - Parameters:     - <code>nonce: Base64</code> - Returns:     - this <code>AccountBlock</code> instance - Example <pre><code>block.setProvider(viteApi);\nawait block.autoSetPreviousAccountBlock();\nawait block.autoSetDifficulty();\nconst nonce = await block.getNonce();\nblock.setNonce(nonce);\nconsole.log(block.nonce);\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#setpublickey","title":"<code>setPublicKey</code>","text":"<p>Set the public key of an <code>AccountBlock</code> instance - Parameters:     - <code>publicKey: Hex | Base64</code> Public key in Hex or Base64 format - Returns:     - this <code>AccountBlock</code> instance - Example <code>js     const myWallet = wallet.createWallet();     const { address, publicKey } = myWallet.deriveAddress(0);     const block = new AccountBlock({         blockType: 2,         address,     }).setProvider(viteApi);     console.log('block.address:', block.address === wallet.getAddressFromPublicKey(publicKey)); // true     block.setPublicKey(publicKey);   // or     block.setPublicKey(utils._Buffer.from(publicKey, 'hex').toString('base64'));</code></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#sign","title":"<code>sign</code>","text":"<p>Sign account block</p> <p>Note: Make sure to set all necessary block properties before calling this method. Calling <code>autoSetPreviousAccountBlock</code> can help. For what qualifies as all the necessary block properties, please view the source code for the checks done on a block before signing. - Parameters:     - <code>privateKey: Hex = this.privateKey</code> Private key used to sign the account block. If not present, <code>privateKey</code> must exist on the <code>AccountBlock</code> instance before calling this method. - Returns:     - this <code>AccountBlock</code> instance - Example <pre><code>await block.autoSetPreviousAccountBlock();\nblock.sign(privateKey);\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#setsignature","title":"<code>setSignature</code>","text":"<p>Set the signature of an <code>AccountBlock</code> instance. - Parameters:     - <code>signature: Hex | Base64</code> Signature in Hex or Base64 format - Returns:     - this <code>AccountBlock</code> instance - Example <pre><code>block.setSignature(yourSignature);\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#send","title":"<code>send</code>","text":"<p>Send account block. The account block must be complete and signed. - Parameters:     - None - Returns:     - <code>Promise&lt;AccountBlockBlock&gt;</code> instance of account block type - Example <pre><code>block.setProvider(viteApi);\nawait block.autoSetPreviousAccountBlock();\nblock.sign(privateKey);\nconst result = await block.send();\n\nconsole.log('send success', result);\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account-block-class/#autosend","title":"<code>autoSend</code>","text":"<p>Sign and send the account block. This combines the <code>autoSetPreviousAccountBlock</code>, <code>sign</code>, and <code>send</code> methods. - Parameters:     - <code>privateKey: Hex = this.privateKey</code> Private key used to sign the account block. If not present, <code>privateKey</code> must exist on the <code>AccountBlock</code> instance before calling this method. - Returns:     - <code>Promise&lt;AccountBlock&gt;</code> instance of account block type - Example <pre><code>const result = await block.autoSend();\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/","title":"<code>Account</code> Instance","text":"<p>Instance of <code>Account</code> represents a user account on the Vite blockchain. </p> <p>Note: NOT applicable to smart contract accounts. </p>"},{"location":"SDK/vitejs/account-block/account/#constructor","title":"<code>Constructor</code>","text":"<ul> <li>Constructor<ul> <li><code>object</code><ul> <li><code>address: Address</code> Address of account</li> </ul> </li> </ul> </li> <li>Example <pre><code>import { accountBlock } from '@vite/vitejs';\nconst { Account } = accountBlock;\nconst account = new Account(address);\naccount.setProvider(viteApi);\naccount.setPrivateKey(privateKey);\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/account-block/account/#methods","title":"Methods","text":""},{"location":"SDK/vitejs/account-block/account/#receive","title":"<code>receive</code>","text":"<p>Receive a transaction - Parameters      - <code>object</code>         - <code>sendBlockHash: Hex</code> Hash of the request transaction - Example <pre><code>account.receive({ // blockType: 4\n    sendBlockHash: '156a47de8b5a690562278360e41e337ee4f1b4aa8d979f377beb0cc70f939032'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#send","title":"<code>send</code>","text":"<p>Send a transaction - Parameters      - <code>object</code>         - <code>toAddress: Address</code> Transaction recipient's address         - <code>tokenId: TokenId = Vite_TokenId</code> Token id. The default token is VITE         - <code>amount: BigInt = '0'</code> Amount of tokens to send (in base unit, e.g. <code>1000000000000000000</code> stands for 1 VITE)         - <code>data?: Base64</code> Additional data - Example <pre><code>account.send({ // blockType: 2\n    toAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    amount: '1000000000000000000',\n    data: 'pinFMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#createcontract","title":"<code>createContract</code>","text":"<p>Deploy a smart contract - Parameters      - <code>object</code>         - <code>code: Hex</code> Complied code of contract in hex format         - <code>responseLatency: Uint8 = '0'</code> See Response Latency         - <code>quotaMultiplier: Uint8 = '10'</code> See Quota Multiplier         - <code>randomDegree: Uint8 = '0'</code> See Random Degree         - <code>abi?: object | Array&lt;object&gt;</code> ABI of the constructor. If your contract doesn't have a constructor, ignore this field.         - <code>params?: string | Array&lt;string | boolean&gt;</code> Passed-in parameter(s) of the constructor. If your contract doesn't have a constructor, ignore this field. - Example <pre><code>account.createContract({ // blockType: 1\n    abi:{\"inputs\":[{\"name\": \"addr\",\"type\": \"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},\n    code: '608060405234801561001057600080fd5b50610141806100206000396000f3fe608060405260043610610041576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806391a6cb4b14610046575b600080fd5b6100896004803603602081101561005c57600080fd5b81019080803574ffffffffffffffffffffffffffffffffffffffffff16906020019092919050505061008b565b005b8074ffffffffffffffffffffffffffffffffffffffffff164669ffffffffffffffffffff163460405160405180820390838587f1505050508074ffffffffffffffffffffffffffffffffffffffffff167faa65281f5df4b4bd3c71f2ba25905b907205fce0809a816ef8e04b4d496a85bb346040518082815260200191505060405180910390a25056fea165627a7a7230582023e9669dd6fec3b6b2a84a1fd7c9939f49197203d0e1db312278e633c219c2480029',\n    responseLatency: 2,\n    params: ['vite_13f1f8e230f2ffa1e030e664e525033ff995d6c2bb15af4cf9']\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#callcontract","title":"<code>callContract</code>","text":"<p>Call smart contract - Parameters      - <code>object</code>         - <code>toAddress: Address</code> Address of contract         - <code>abi: object | Array&lt;object&gt;</code> ABI         - <code>methodName?: string</code> Name of the method to call         - <code>params?: any = []</code> Passed-in parameters         - <code>tokenId: TokenId = Vite_TokenId</code> Token id         - <code>amount: BigInt = '0'</code> Amount of tokens to send (in base unit, e.g. <code>1000000000000000000</code> stands for 1 VITE)         - <code>fee: BigInt = '0'</code> Transaction fee - Example <pre><code>import { constant } from '~@vite/vitejs';\nconst { Contracts, Vite_TokenId } = constant;\n\naccount.callContract({\n    abi: Contracts.RegisterSBP.abi,\n    toAddress: Contracts.RegisterSBP.contractAddress,\n    params: ['sbpName', blockProducingAddress, rewardWithdrawAddress],\n    tokenId: Vite_TokenId,\n    amount: '1000000' + '0'.repeat(18),\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#registersbp","title":"<code>registerSBP</code>","text":"<p>Register an new SBP</p> <p>Note: To register an SBP node, transferring 1,000,000 <code>VITE</code> is required. The transferred VITE will be locked for 7,776,000 snapshot blocks (about 3 months), after which it can be withdrawn if you choose to cancel your SBP. - Parameters      - <code>object</code>         - <code>sbpName: string</code> See SBP name         - <code>blockProducingAddress: Address</code> See Block Creation Address         - <code>rewardWithdrawAddress: Address</code> See Reward Withdrawal Address         - <code>amount: BigInt = '1000000000000000000000000'</code> A default amount of 1M VITE is required for SBP registration. - Example <pre><code>account.registerSBP({ // blockType: 2\n    sbpName: 'TEST_NODE',\n    blockProducingAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    rewardWithdrawAddress: 'vite_5e8d4ac7dc8b75394cacd21c5667d79fe1824acb46c6b7ab1f',\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#updatesbpblockproducingaddress","title":"<code>updateSBPBlockProducingAddress</code>","text":"<p>Update an SBP's block producing address - Parameters      - <code>object</code>         - <code>sbpName: string</code> See SBP name         - <code>blockProducingAddress: Address</code> New block producing address - Example <pre><code>account.updateSBPBlockProducingAddress({ // blockType: 2\n    sbpName: 'TEST_NODE',\n    blockProducingAddress: 'vite_5e8d4ac7dc8b75394cacd21c5667d79fe1824acb46c6b7ab1f',\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#revokesbp","title":"<code>revokeSBP</code>","text":"<p>Cancel an SBP's registration - Parameters      - <code>object</code>         - <code>sbpName: string</code> Name of the SBP - Example <pre><code>account.revokeSBP({ // blockType: 2\n    sbpName: 'TEST_NODE'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#withdrawsbpreward","title":"<code>withdrawSBPReward</code>","text":"<p>Withdraw an SBP's mining rewards - Parameters      - <code>object</code>         - <code>sbpName: string</code> Name of the SBP         - <code>receiveAddress: Address</code> An address to receive rewards - Example <pre><code>account.withdrawSBPReward({ // blockType: 2\n    sbpName: 'TEST_NODE',\n    receiveAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#voteforsbp","title":"<code>voteForSBP</code>","text":"<p>Vote for an SBP - Parameters      - <code>object</code>         - <code>sbpName: string</code> Name of the SBP - Example <pre><code>account.voteForSBP({ // blockType: 2\n    sbpName: 'TEST_NODE'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#cancelsbpvoting","title":"<code>cancelSBPVoting</code>","text":"<p>Cancel voting - Parameters      - none - Example <pre><code>account.cancelSBPVoting();\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#stakeforquota","title":"<code>stakeForQuota</code>","text":"<p>Supply a beneficiary address with quota - Parameters      - <code>object</code>         - <code>beneficiaryAddress: Address</code> Address of quota beneficiary         - <code>amount: BigInt</code> Amount of VITE to lock (in base unit, e.g. <code>134000000000000000000</code> stands for 134 VITE)</p> <p>Note: the minimum locking amount is 134 VITE. - Example <pre><code>account.stakeForQuota({ // blockType: 2\n    beneficiaryAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2',\n    amount: '134' + '0'.repeat(18),\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#cancelquotastake","title":"<code>cancelQuotaStake</code>","text":"<p>Cancel locking for quota and withdraw the locked tokens. - Parameters      - <code>object</code>         - <code>id: string</code> Locking id - referring to the hash of the locking transaction. - Example <pre><code>account.cancelQuotaStake({ // blockType: 2\n    id: '401d46c2330d3c76c8f0da6be2a24b17c5e3ece9c28d80a74e91146d1f95ad2e'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#issuetoken","title":"<code>issueToken</code>","text":"<p>Create a new token - Parameters      - <code>object</code>         - <code>tokenName: string</code> Name of token in 1-40 characters. See Token Name.         - <code>tokenSymbol: string</code> Symbol of token in 1-10 characters. See Token Symbol.         - <code>decimals: Uint8</code> See Decimals         - <code>maxSupply: Uint256</code> See Max Supply. For non-reissuable token, fill in <code>0</code>.         - <code>totalSupply: Uint256</code> See Total Supply. For re-issuable tokens, this is the initial supply         - <code>isReIssuable: boolean</code> See ReIssuable Flag         - <code>isOwnerBurnOnly: boolean</code> Only applies to re-issuable token. If <code>true</code>, the token can only burned by owner. For non-re-issuable token, fill in <code>false</code>.     &gt; Note: <code>isOwnerBurnOnly</code> is deprecated and removed from the latest go-vite release. - Example <pre><code>account.issueToken({ // blockType: 2\n    tokenName: 'TestCoin', \n    isReIssuable: true, \n    maxSupply: '10000000000000000000000000', \n    isOwnerBurnOnly: false, \n    totalSupply: '100000000000000000000000', \n    decimals: 2, \n    tokenSymbol: 'TEST'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#reissuetoken","title":"<code>reIssueToken</code>","text":"<p>Re-issue additional amount of tokens</p> <p>Note: A re-issuable token's owner can mint additional amount of tokens by re-issuance - not applicable to non-re-issuable tokens and only the owner of the token can do this. - Parameters      - <code>object</code>         - <code>tokenId: TokenId</code> Token id         - <code>amount: BigInt</code> Amount of tokens to mint (in base unit, e.g. <code>1000000000000000000000</code> stands for <code>1000</code> for a 18-decimal token)         - <code>receiveAddress: Address</code> Address to receive newly minted tokens - Example <pre><code>account.reIssueToken({ // blockType: 2\n    tokenId: 'tti_f1fdb1fce23ca4a2c760012c',\n    amount: '1000000000000000000000',\n    receiveAddress: 'vite_553462bca137bac29f440e9af4ab2e2c1bb82493e41d2bc8b2'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#burntoken","title":"<code>burnToken</code>","text":"<p>Burn tokens</p> <p>Note: Re-issuable tokens can be burned by sending the amount of tokens to the built-in token issuance contract - not applicable to non-re-issuable tokens. - Parameters      - <code>object</code>         - <code>tokenId: TokenId</code> Token id         - <code>amount: BigInt</code> Amount of tokens to mint (in base unit, e.g. <code>1000000000000000000000</code> stands for <code>1000</code> for a 18-decimal token) - Example <pre><code>account.burnToken({ // blockType: 2\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    amount: '1000000000000000000000'\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/account/#disablereissuetoken","title":"<code>disableReIssueToken</code>","text":"<p>Change a re-issuable token to non-re-issuable</p> <p>Note</p> <p>Only the owner of the token can do this.</p> <p>Warning</p> <p>This action cannot be reversed</p> <ul> <li>Parameters <ul> <li><code>object</code><ul> <li><code>tokenId: TokenId</code> Token id</li> </ul> </li> </ul> </li> <li>Example <pre><code>account.disableReIssueToken({ // blockType: 2\n    tokenId: 'tti_5649544520544f4b454e6e40'\n});\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/account-block/account/#transfertokenownership","title":"<code>transferTokenOwnership</code>","text":"<p>Block type for transferring a token's ownership</p> <p>Note</p> <p>Only applicable to re-issuable tokens and only the owner of the token can do this.</p> <ul> <li>Parameters <ul> <li><code>object</code><ul> <li><code>tokenId</code>: <code>string tokenId</code> Token id</li> <li><code>newOwnerAddress</code>: <code>string address</code> Address of new owner</li> </ul> </li> </ul> </li> <li>Example <pre><code>account.transferTokenOwnership({ // blockType: 2\n    tokenId: 'tti_5649544520544f4b454e6e40',\n    newOwnerAddress: 'vite_869a06b8963bd5d88a004723ad5d45f345a71c0884e2c80e88'\n});\n</code></pre></li> </ul>"},{"location":"SDK/vitejs/account-block/receive-task/","title":"<code>ReceiveAccountBlockTask</code>","text":"<p><code>ReceiveAccountBlockTask</code> is a timed task which polls for unreceived transactions for an account and receives the transactions automatically.</p>"},{"location":"SDK/vitejs/account-block/receive-task/#constructor","title":"<code>Constructor</code>","text":"<ul> <li>Constructor<ul> <li><code>object</code><ul> <li><code>address: Address</code> Address of account</li> <li><code>provider: ViteAPI</code> <code>ViteAPI</code> instance</li> <li><code>privateKey: Hex</code></li> <li><code>sign?: Function</code> Set the signature when the private key can not be obtained, e.g. using a hardware wallet.</li> </ul> </li> </ul> </li> <li> <p>Example</p> <ul> <li> <p>With a private key: <pre><code>import { wallet, accountBlock } from '@vite/vitejs';\nconst { ReceiveAccountBlockTask } = accountBlock;\n\nconst { address, privateKey } = wallet.createAddressByPrivateKey();\nconst receiveTask = new ReceiveAccountBlockTask({\n    address,\n    privateKey,\n    provider: viteApi,\n});\n</code></pre></p> </li> <li> <p>Without a private key - using a hardware wallet: <pre><code>import { accountBlock } from '@vite/vitejs';\nconst { ReceiveAccountBlockTask } = accountBlock;\nconst signWithHardWallet = async () =&gt; {\n    let signature = '';\n    // Sign with a hardware wallet and return the signature\n    return signature;\n}\n\nconst receiveTask = new ReceiveAccountBlockTask({\n    address,\n    provider: viteApi,\n    sign: async (block) =&gt; {\n        let signature = await signWithHardWallet();\n        // Set publicKey if it isn't set already\n        block.setPublicKey(this.publicKey);\n        // Set signature; this is required.\n        block.setSignature(signature);\n    }\n});\n</code></pre></p> </li> </ul> </li> </ul>"},{"location":"SDK/vitejs/account-block/receive-task/#methods","title":"<code>Methods</code>","text":""},{"location":"SDK/vitejs/account-block/receive-task/#start","title":"<code>start</code>","text":"<p>Start receiving transactions on an account - Parameters      - <code>object</code>         - <code>checkTime: number = 3000</code> Polling interval (in milliseconds)         - <code>transactionNumber: number = 5</code> Maximum transactions to process in each poll         - <code>gapTime: number = 1000</code> Transaction processing interval (in milliseconds) - Example <pre><code>receiveTask.start({\n    checkTime: 3000,\n    transactionNumber: 10\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/receive-task/#stop","title":"<code>stop</code>","text":"<p>Stop receiving transactions on an account - Parameters      - None - Example <pre><code>receiveTask.start({\n    checkTime: 3000,\n    transactionNumber: 10\n});\nreceiveTask.stop();\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/receive-task/#onerror","title":"<code>onError</code>","text":"<p>Set up a callback function which will be triggered when failed to receive a transaction - Parameters      - <code>errorCB: (error) =&gt; void</code> Callback function         - <code>error</code> object             - <code>status: 'error'</code>             - <code>timestamp: number</code> Timestamp             - <code>message: string</code> Error message             - <code>unreceivedHash?: Hex</code> Hash of account block that failed to receive             - <code>error: any</code> RPC error message - Example <pre><code>receiveTask.start({\n    checkTime: 3000,\n    transctionNumber: 10\n});\nreceiveTask.onError((error) =&gt; {\n    console.log('error', error);\n});\n</code></pre></p>"},{"location":"SDK/vitejs/account-block/receive-task/#onsuccess","title":"<code>onSuccess</code>","text":"<p>Set up a callback function which will be triggered when a batch of transactions is successfully received - Parameters      - <code>successCB: Function</code> Callback function         - <code>success</code> object             - <code>status: 'ok'</code>             - <code>message: string</code> Success message             - <code>timestamp: number</code> Timestamp             - <code>accountBlockList?: AccountBlock[]</code> A list of <code>AccountBlock</code> that has been received - Example <pre><code>receiveTask.start({\n    checkTime: 3000,\n    transctionNumber: 10\n});\nreceiveTask.onSuccess((result) =&gt; {\n    console.log('success', result);\n});\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/","title":"Module","text":"<p>Vite wallet adopts BIP-39 that uses the PBKDF2 function to generate a wallet's seed from a mnemonic phrase (i.e. password) and an optional passphrase (i.e. salt). From this seed, public and private keys are derived. Losing the mnemonic phrase or the passphrase will result in the loss of a wallet's seed and private keys. For more information about key derivation on Vite, see Address Derivation.</p>"},{"location":"SDK/vitejs/wallet/#module-import","title":"Module Import","text":"<pre><code>import { wallet } from '@vite/vitejs';\n</code></pre>"},{"location":"SDK/vitejs/wallet/#methods","title":"Methods","text":""},{"location":"SDK/vitejs/wallet/#createwallet","title":"<code>createWallet</code>","text":"<p>Create a new <code>Wallet</code> instance. See Wallet Class - Parameters      - <code>strength: number = 256</code> Bits of entropy. A 256-bit entropy will generate 24-word mnemonic phrase while 128 bits entropy will give 12-word mnemonics.     - <code>wordlist: string[] = bip39.wordlists.EN</code>     - <code>passphrase: string = ''</code> Optional passphrase - Returns     - <code>Wallet</code> instance - Example <pre><code>const myWallet = wallet.createWallet();\nconsole.log(myWallet.rootPath);\nconsole.log(myWallet.mnemonics);\nconsole.log(myWallet.entropy);\nconsole.log(myWallet.seedHex);\nconst firstAddress = myWallet.deriveAddress(0);\nconst { originalAddress, publicKey, privateKey, address, path } = firstAddress;\nconst myWallet2 = wallet.createWallet(256, bip39.wordlists.EN, 'myPassword');\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#getwallet","title":"<code>getWallet</code>","text":"<p>Restore <code>Wallet</code> instance from a mnemonic phrase. See Wallet Class - Parameters      - <code>mnemonic: string</code> Mnemonic phrase     - <code>wordlist: string[] = bip39.wordlists.EN</code>     - <code>passphrase: string = ''</code> Optional passphrase - Returns     - <code>Wallet</code> instance - Example <pre><code>const mnemonics = wallet.createMnemonics();\nconst myWallet = wallet.getWallet(mnemonics);\nconst myWallet2 = wallet.getWallet(mnemonics, bip39.wordlists.EN, 'myPassword');\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#createmnemonics","title":"<code>createMnemonics</code>","text":"<p>Create a random mnemonic phrase - Parameters      - <code>strength: number = 256</code> Bits of entropy. A 256-bit entropy will generate 24-word mnemonic phrase while 128 bits entropy will give 12-word mnemonics.     - <code>wordlist: string[] = bip39.wordlists.EN</code> - Returns     - <code>mnemonic: string</code> - Example <pre><code>const english24Words = wallet.createMnemonics();\nconst portuguese12Words = wallet.createMnemonics(128, bip39.wordlists.portuguese);\nconst japaneseMnemonics = wallet.createMnemonics(256, bip39.wordlists.japanese)\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#validatemnemonics","title":"<code>validateMnemonics</code>","text":"<p>Determine if the input is a valid mnemonic phrase - Parameters      - <code>mnemonic: string</code>     - <code>wordlist: string[] = bip39.wordlists.EN</code> - Returns     - <code>boolean</code> If <code>true</code>, the mnemonic phrase is valid. - Example <pre><code>const result = wallet.validateMnemonics(mnemonic);\nconst result = wallet.validateMnemonics(japanMnemonic, bip39.wordlists.japanese);\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#deriveaddress","title":"<code>deriveAddress</code>","text":"<p>Generate address from a combination of mnemonic phrase, index, and optional passphrase - Parameters      - <code>object</code>         - <code>mnemonics: string</code> Mnemonic phrase         - <code>index: number = 0</code> Address index         - <code>wordlist: string[] = bip39.wordlists.EN</code>         - <code>passphrase: string = ''</code> - Returns     - <code>AddressObj</code>         - <code>originalAddress: Hex</code> Original address         - <code>publicKey: Hex</code> Public key         - <code>privateKey: Hex</code> Private key         - <code>address: Address</code> Vite address - Example <pre><code>const mnemonics = wallet.createMnemonics();\nconst { privateKey, publicKey, address, originalAddress } = wallet.deriveAddress({ \n    mnemonics,\n    index: 0 \n});\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#deriveaddresslist","title":"<code>deriveAddressList</code>","text":"<p>Derive a list of addresses from a combination of mnemonic phrase, index range, and optional passphrase  - Parameters      - <code>object</code>         - <code>mnemonics: string</code> Mnemonic phrase         - <code>startIndex: number</code> Start index (inclusive)         - <code>endIndex: number</code> End index (inclusive)         - <code>wordlist: string[] = bip39.wordlists.EN</code>         - <code>passphrase: string = ''</code> - Returns     - <code>AddressObj[]</code>         - <code>originalAddress: Hex</code> Original address         - <code>publicKey: Hex</code> Public key         - <code>privateKey: Hex</code> Private key         - <code>address: Address</code> Vite address - Example <pre><code>const mnemonics = wallet.createMnemonics();\nconst addressList = wallet.deriveAddressList({\n    mnemonics,\n    startIndex: 0,\n    endIndex: 9,\n});\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#isvalidaddress","title":"<code>isValidAddress</code>","text":"<p>Determine if the input is a valid Vite address - Parameters      - <code>string</code> Address - Returns     - <code>0 | 1 | 2</code> 0: Illegal. 1: User Address. 2: Contract Address. - Example <pre><code>const mnemonics = wallet.createMnemonics();\nconst { address, originalAddress } = wallet.deriveAddress({ mnemonics, index: 0 });\nwallet.isValidAddress(address); // 1\nwallet.isValidAddress(originalAddress); // 0\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#more-methods","title":"More Methods","text":"<p>The following methods are for advanced usage.</p>"},{"location":"SDK/vitejs/wallet/#getentropyfrommnemonics","title":"<code>getEntropyFromMnemonics</code>","text":"<p>Get entropy from a mnemonic phrase - Parameters      - <code>mnemonic: string</code>     - <code>wordlist: string[] = bip39.wordlists.EN</code> - Returns     - <code>Hex</code> Entropy with length of 16 bytes (12-word mnemonics) or 32 bytes (24-word mnemonics) - Example <pre><code>const mnemonics = wallet.createMnemonics();\nconst entropy = wallet.getEntropyFromMnemonics(mnemonics);\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#createseed","title":"<code>createSeed</code>","text":"<p>Create a random seed for deriving addresses from - Parameters      - <code>strength: number = 256</code> Bits of entropy. A 256-bit entropy will generate 24-word mnemonic phrase while 128 bits entropy will give 12-word mnemonic phrase.     - <code>passphrase: string = ''</code> Optional passphrase     - <code>wordlist: string[] = bip39.wordlists.EN</code> - Returns     - <code>object</code>         - <code>mnemonic: string</code> Mnemonic phrase         - <code>seed: Buffer</code> 64-bytes seed         - <code>seedHex: Hex</code> Seed as a hex string - Example <pre><code>const { mnemonic, seed, seedHex } = wallet.createSeed();\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#getseedfrommnemonics","title":"<code>getSeedFromMnemonics</code>","text":"<p>Derive seed from a mnemonic phrase - Parameters      - <code>mnemonic: string</code> Mnemonic phrase     - <code>passphrase: string = ''</code> Optional passphrase     - <code>wordlist: string[] = bip39.wordlists.EN</code> - Returns     - <code>object</code>         - <code>seed: Buffer</code> 64-bytes seed         - <code>seedHex: Hex</code> Seed as a hex string - Example <pre><code>const mnemonics = wallet.createMnemonics();\nconst { seed, seedHex } = wallet.getSeedFromMnemonics(mnemonics);\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#getmnemonicsfromentropy","title":"<code>getMnemonicsFromEntropy</code>","text":"<p>Get mnemonic phrase from an entropy - Parameters      - <code>entropy: Hex</code> Entropy as a 32-bytes hex string     - <code>wordlist: string[] = bip39.wordlists.EN</code> - Returns     - <code>mnemonic: string</code> Mnemonic phrase - Example <pre><code>const mnemonics = wallet.createMnemonics();\nconst entropy = wallet.getEntropyFromMnemonics(mnemonics);\nconst mnemonics2 = wallet.getMnemonicsFromEntropy(entropy);\nconsole.log(mnemonics === mnemonics2); // true\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#getpath","title":"<code>getPath</code>","text":"<p>Get derivation path - Parameters      - <code>index: number</code> Address index  - Returns     - <code>string</code> Derivation path - Example <pre><code>const derivationPath = wallet.getPath();\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#derivekeypairbypath","title":"<code>deriveKeyPairByPath</code>","text":"<p>Derive keypair from a seed and derivation path - Parameters      - <code>seed: Hex</code> Seed as a hex string     - <code>path: string</code> Derivation path of address - Returns     - <code>Object</code> Key pair         - <code>privateKey: Hex</code>         - <code>publicKey: Hex</code> - Example <pre><code>const mnemonics = wallet.createMnemonics();\nconst { seedHex } = wallet.getSeedFromMnemonics(mnemonics);\nconst { privateKey, publicKey } = wallet.deriveKeyPairByPath(seedHex, wallet.getPath(0));\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#derivekeypairbyindex","title":"<code>deriveKeyPairByIndex</code>","text":"<p>Derive keypair from a seed and derivation index - Parameters      - <code>seed: Hex</code> Seed as a hex string     - <code>number</code> Address index - Returns     - <code>Object</code> Key pair         - <code>privateKey: Hex</code>         - <code>publicKey: Hex</code> - Example <pre><code>const mnemonics = wallet.createMnemonics();\nconst { seedHex } = wallet.getSeedFromMnemonics(mnemonics);\nconst { privateKey, publicKey } = wallet.deriveKeyPairByIndex(seedHex, 0);\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#createaddressbyprivatekey","title":"<code>createAddressByPrivateKey</code>","text":"<p>Get address from a private key - Parameters      - <code>privateKey?: Hex</code> The private key will be generated in method if not provided - Returns     - <code>AddressObj</code>         - <code>originalAddress: Hex</code> Original address         - <code>publicKey: Hex</code> Public key         - <code>privateKey: Hex</code> Private key         - <code>address: Address</code> Vite address - Example <pre><code>const { originalAddress, publicKey, privateKey, address } = wallet.createAddressByPrivateKey();\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#getaddressfrompublickey","title":"<code>getAddressFromPublicKey</code>","text":"<p>Get address from a public key - Parameters      - <code>Hex</code> Public key - Returns     - <code>Address</code> Address - Example <pre><code>const { publicKey, address } = wallet.createAddressByPrivateKey();\nconst viteAddress = wallet.getAddressFromPublicKey(publicKey);\nconsole.log(address === viteAddress); // true\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#getoriginaladdressfromaddress","title":"<code>getOriginalAddressFromAddress</code>","text":"<p>Get original address from an address. </p> <p>An original address is the initial address without <code>vite_</code> prefix and checksum. See Original Address for details. - Parameters      - <code>hexAddr: Hex</code> - Returns     - <code>Hex</code> Original address - Example <pre><code>const { publicKey, originalAddress } = wallet.createAddressByPrivateKey();\nconst viteAddress = wallet.getAddressFromPublicKey(publicKey);\nconsole.log(originalAddress === wallet.getOriginalAddressFromAddress(viteAddress)); // true\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/#getaddressfromoriginaladdress","title":"<code>getAddressFromOriginalAddress</code>","text":"<p>Get address from an original address</p> <p>An original address is the initial address without <code>vite_</code> prefix and checksum. See Original Address for details. - Parameters      - <code>originalAddress</code> Original address - Returns     - <code>Address</code> Address - Example <pre><code>const { originalAddress, address } = wallet.createAddressByPrivateKey();\nconst viteAddress = wallet.getAddressFromOriginalAddress(originalAddress);\nconsole.log(address === viteAddress); // true\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/wallet-class/","title":"<code>Wallet</code> Instance","text":"<p>An instance of <code>Wallet</code> is a BIP-44 HD wallet that holds a BIP-39 mnemonic phrase and is capable of deriving addresses and Ed25519 keypairs with BIP-32 paths. </p> <p>Tip</p> <p>The <code>Wallet</code> class doesn't expose constructor. Use <code>createWallet</code> or <code>getWallet</code> to get a wallet instance.</p> <p>The class has the following properties:</p>"},{"location":"SDK/vitejs/wallet/wallet-class/#properties","title":"Properties","text":"Name Type Description rootPath <code>string</code> BIP-32 root path, read-only. For Vite the root path is <code>'m/44\\'/666666\\''</code> mnemonics <code>string</code> Mnemonic phrase entropy <code>Hex</code> Entropy of mnemonics wordlist <code>string[]</code> Wordlist passphrase <code>string</code> Passphrase, optional. Default empty string seed <code>Buffer</code> Seed seedHex <code>Hex</code> Seed in hex string id <code>Hex</code> BLAKE2b hash at Address 0. This property is used to uniquely tag a wallet instance."},{"location":"SDK/vitejs/wallet/wallet-class/#methods","title":"Methods","text":""},{"location":"SDK/vitejs/wallet/wallet-class/#deriveaddress","title":"<code>deriveAddress</code>","text":"<p>Get address from a <code>Wallet</code> instance and index - Parameters     - <code>number</code> Address index - Returns     - <code>AddressObj</code> - Example <pre><code>const myWallet = wallet.createWallet();\nconst addressObj = myWallet.deriveAddress(0);\nconsole.log(addressObj.address)\nconsole.log(addressObj.originalAddress)\nconsole.log(addressObj.privateKey)\nconsole.log(addressObj.publicKey)\nconsole.log(addressObj.path)\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/wallet-class/#deriveaddresslist","title":"<code>deriveAddressList</code>","text":"<p>Derive a list of addresses from the start index to end - Parameters     - <code>startIndex: number</code> Start index, inclusive     - <code>endIndex: number</code> End index, inclusive - Returns     - <code>AddressObj[]</code> - Example <pre><code>const myWallet = wallet.createWallet();\nconst addressObjList = myWallet.deriveAddressList(0, 9);\n</code></pre></p>"},{"location":"SDK/vitejs/wallet/wallet-class/#getaddresslist","title":"<code>getAddressList</code>","text":"<p>Get all the addresses that a <code>Wallet</code> instance has derived - Returns     - <code>object</code>         - <code>[index: string]: AddressObj</code> - Example <pre><code>const myWallet = wallet.createWallet();\nconst { address } = myWallet.deriveAddress(0);\nconst currentAddressList = myWallet.getAddressList();\nconsole.log(address === currentAddressList['0'].address); // true\n</code></pre></p>"},{"location":"api/","title":"Overview","text":"<p>Each Vite node provides a JSON-RPC API that allows applications to connect to the blockchain.  Developers can interact with on-chain data and send various types of transactions to the network by utilizing the endpoints provided by the API.  The API follows the JSON-RPC standard, a stateless, lightweight, remote procedure call (RPC) protocol commonly used when interacting with blockchains.</p>"},{"location":"api/#protocol","title":"Protocol","text":"JSON-RPC 2.0 HTTP Publish\u2013Subscribe WebSocket \u2713 \u2713 \u2713 \u2713 Protocol Default Port HTTP 48132 WebSocket 41420 <p>Tip</p> <p>On Vite, a transaction is equivalent to an account block. When we mention a transaction, it also refers to an account block, and vice versa.</p>"},{"location":"api/#type-conversion","title":"Type Conversion","text":"<ul> <li>Bytes (<code>byte[]</code>) are converted to a base64 string.</li> <li><code>hash</code> is a 32-byte hex string.</li> <li><code>hex</code> and <code>base64</code> are strings in hex or base64 format.</li> <li>For numeric types such as <code>uint64</code>, <code>float</code>, and <code>bigint</code>, when they are suffixed with the <code>string</code> type, it means they should be passed as strings.</li> <li><code>address</code> and <code>tokenId</code> are passed in as strings.</li> </ul>"},{"location":"api/#common-models","title":"Common Models","text":""},{"location":"api/#accountinfo","title":"<code>AccountInfo</code>","text":"Name Type Description address address Account address blockCount uint64 string The total number of transactions balanceInfoMap mapBalanceInfo&gt; Account balance"},{"location":"api/#balanceinfo","title":"<code>BalanceInfo</code>","text":"Name Type Description tokenInfo TokenInfo Token information balance bigint string Token balance transactionCount uint64 string The total number of transactions for this token"},{"location":"api/#tokeninfo","title":"<code>TokenInfo</code>","text":"Name Type Description tokenName string Token name tokenSymbol string Token symbol totalSupply bigint string Token total supply decimals uint8 Decimal places owner address Token owner tokenId tokenId Token ID isReIssuable bool <code>true</code> means the token can be re-issued maxSupply bigint string The maximum supply of the token. 0 for non-reissuable tokens isOwnerBurnOnly bool <code>true</code> means only the token owner can burn the tokens. Deprecated index uint16 A number between 0-999 to distinguish tokens with the same symbol"},{"location":"api/#accountblock","title":"<code>AccountBlock</code>","text":"Name Type Description blockType byte Block type. 1 - request (create contract), 2 - request (send transaction), 3 - request (mint token), 4 - response (receive transaction), 5 - response (execute contract failed), 6 - request (refund), 7 - response (genesis). height uint64 string Account block height hash hash 32-byte block hash previousHash hash The hash of the previous account block. For the first transaction in an account, the value is a string of 64 zeros address address Account address publicKey base64 Producer's public key producer address Block producer address. For user accounts, the producer is the account address itself; for contract accounts, the address is the delegate node of the consensus group fromAddress address The address of the account the transaction is sent from toAddress address The address of the account the transaction is sent to sendBlockHash hash The hash of the corresponding request transaction. For request transactions, the value is a string of 64 zeros tokenId tokenId Token ID amount bigint string Transfer amount tokenInfo TokenInfo Transferred token information fee bigint string Transaction fee data base64 Additional block data difficulty bigint string PoW difficulty nonce base64 PoW nonce signature base64 Block signature quotaByStake uint64 string Quota consumed by the transaction, excluding quota obtained through PoW totalQuota uint64 string Total quota consumed by the transaction vmLogHash hash The hash of the event log generated in the smart contract response triggeredSendBlockList Array&lt;AccountBlock&gt; A list of request transactions sent within this block. RS blocks only. confirmations uint64 string Confirmation number firstSnapshotHash hash The hash of the snapshot block that snapshots the transaction timestamp int64 The timestamp (in seconds) when the transaction is snapshotted receiveBlockHeight uint64 string The height of the corresponding response transaction. Request block only receiveBlockHash hash The hash of the corresponding response transaction. Request block only"},{"location":"api/#snapshotblock","title":"<code>SnapshotBlock</code>","text":"Name Type Description producer address Block producer address hash hash Snapshot block hash previousHash hash The hash of the previous snapshot block height uint64 Snapshot block height publicKey base64 Producer's public key signature base64 Block signature timestamp int64 The timestamp (in seconds) when the block is produced seed uint64 Random seed generated by the same producer in the previous round nextSeedHash hash Hash of the random seed generated in the current round snapshotData SnapshotContent Content of the snapshot version uint32 Snapshot version"},{"location":"api/#vmlog","title":"VmLog","text":"Name Type Description topics Array\\&lt;hash&gt; Event topics data base64 Event log data"},{"location":"api/#logs","title":"Logs","text":"Name Type Description vmlog VmLog Event log accountBlockHash hash The hash of the account block that contains the log accountBlockHeight uint64 string The height of the account block that contains the log address address Contract address"},{"location":"api/#common-rpc-errors","title":"Common RPC Errors","text":"Description Code Example Failed to parse JSON string <code>-32700</code> <code>{\"code\":-32700,\"message\":\"missing request id\"}</code> Invalid JSON request <code>-32600</code> <code>{\"code\":-32600,\"message\":\"Unable to parse subscription request\"}</code> Method not found. Please check if the corresponding namespace has been added in <code>PublicModules</code> <code>-32601</code> <code>{\"code\":-32601,\"message\":\"The method tx_sendRawTx does not exist/is not available\"}</code> Parameter type error <code>-32602</code> <code>{\"code\":-32602,\"message\":\"missing value for required argument\"}</code> Service stopped <code>-32000</code> <code>{\"code\":-32000,\"message\":\"server is shutting down\"}</code> Service temporarily unavailable. Please try again later <code>-32001</code> <code>{\"code\":-32001,\"message\":\"server execute panic\"}</code> Callback error <code>-32002</code> <code>{\"code\":-32002,\"message\":\"notifications not supported\"}</code>"},{"location":"api/#common-errors","title":"Common Errors","text":"Description Code Example Wrong password <code>-34001</code> <code>{\"code\":-34001,\"message\":\"error decrypting key\"}</code> Insufficient balance <code>-35001</code> <code>{\"code\":-35001,\"message\":\"insufficient balance for transfer\"}</code> Insufficient quota <code>-35002</code> <code>{\"code\":-35002,\"message\":\"out of quota\"}</code> Invalid parameter <code>-35004</code> <code>{\"code\":-35004,\"message\":\"invalid method param\"}</code> Too many PoW requests <code>-35005</code> <code>{\"code\":-35005,\"message\":\"calc PoW twice referring to one snapshot block\"}</code> ABI not found <code>-35006</code> <code>{\"code\":-35006,\"message\":\"abi: method not found\"}</code> Invalid response latency <code>-35007</code> <code>{\"code\":-35007,\"message\":\"invalid confirm time\"}</code> Contract not found <code>-35008</code> <code>{\"code\":-35008,\"message\":\"contract not exists\"}</code> Invalid quota multiplier <code>-35010</code> <code>{\"code\":-35010,\"message\":\"invalid quota ratio\"}</code> PoW not available due to network congestion <code>-35011</code> <code>{\"code\":-35011,\"message\":\"PoW service not supported\"}</code> Maximum quota for a single transaction reached <code>-35012</code> <code>{\"code\":-35012,\"message\":\"quota limit for block reached\"}</code> Invalid block producing address <code>-36001</code> <code>{\"code\":-36001, \"message\":\"general account's sendBlock.Height must be larger than 1\"}</code> Hash verification failure <code>-36002</code> <code>{\"code\":-36002,\"message\":\"verify hash failed\"}</code> Signature verification failure <code>-36003</code> <code>{\"code\":-36003,\"message\":\"verify signature failed\"}</code> Invalid PoW nonce <code>-36004</code> <code>{\"code\":-36004,\"message\":\"check pow nonce failed\"}</code> Hash verification failure for the previous block <code>-36005</code> <code>{\"code\":-36005,\"message\":\"verify prevBlock failed, incorrect use of prevHash or fork happened\"}</code> Waiting for block <code>-36006</code> <code>{\"code\":-36006,\"message\":\"verify referred block failed, pending for them\"}</code>"},{"location":"api/ledger/","title":"Ledger API","text":"<p>Tip</p> <p>To enable the Ledger RPC API on a node, add <code>\"ledger\"</code> to the <code>PublicModules</code> section in <code>node_config.json</code>.</p>"},{"location":"api/ledger/#ledger_getaccountblocks","title":"<code>ledger_getAccountBlocks</code>","text":"<p>Retrieve account blocks based on address, Token ID, and/or account block hash.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>address</code>: <code>address</code> The account address.</li> <li><code>startBlockHash</code>: <code>hash</code> Optional. The starting block hash. Results are sorted in descending order by height. Use <code>null</code> to start from the latest block.</li> <li><code>tokenId</code>: <code>tokenId</code> Optional. The Token ID for filtering transactions. Use <code>null</code> to return all account blocks.</li> <li><code>count</code>: <code>uint64</code> The number of blocks to retrieve, with a maximum value of 1000.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>Array&lt;AccountBlock&gt;</code> See AccountBlock for details.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_getAccountBlocks\",\n    \"params\": [\n        \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        null,\n        null,\n        3\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": [\n        {\n            \"blockType\": 4,\n            \"height\": \"21846\",\n            \"hash\": \"7c534db9946950197dbce8654c0538278ec38e2b1bb3e229c84df26cf936a739\",\n            \"previousHash\": \"5a78365f4f7e9c29d57c8f087c9691bfff63a4889cde5d03a89cb24d34abbdf3\",\n            \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"publicKey\": \"dTwfba0WWN2amkGLuMaanCNiGgJsT0ArM//zaDO3Mro=\",\n            \"producer\": \"vite_8370865362e739fb71615b8b33f9e394d85743093bdfaede6c\",\n            \"fromAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n            \"toAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"sendBlockHash\": \"37702663fbad5d405d78b9c53bd3206f4040ac17843852fef0d125973030318c\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"amount\": \"0\",\n            \"fee\": \"0\",\n            \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\n            \"difficulty\": null,\n            \"nonce\": null,\n            \"signature\": \"FLPFkplSkoq31iJpYeNho2MyZR1BKmOD3V54U9XV3PTRWnjm5e7sOnCNWW8EgCMPbK+WYImxPueYfnZXEcnDAw==\",\n            \"quotaByStake\": \"33184\",\n            \"totalQuota\": \"33184\",\n            \"vmLogHash\": null,\n            \"triggeredSendBlockList\": [\n                {\n                    \"blockType\": 2,\n                    \"height\": \"0\",\n                    \"hash\": \"dda7b2c0d2d6c1c1ca3c9bdb061dd4a14ee892d29ab0cdd7fc552c1e57d6f0d2\",\n                    \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"publicKey\": null,\n                    \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                    \"fromAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"toAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n                    \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"amount\": \"61984000000000000000000\",\n                    \"fee\": \"0\",\n                    \"data\": null,\n                    \"difficulty\": null,\n                    \"nonce\": null,\n                    \"signature\": null,\n                    \"quotaByStake\": \"0\",\n                    \"totalQuota\": \"0\",\n                    \"vmLogHash\": null,\n                    \"triggeredSendBlockList\": null,\n                    \"tokenInfo\": {\n                        \"tokenName\": \"VITE\",\n                        \"tokenSymbol\": \"VITE\",\n                        \"totalSupply\": \"999344176075854028300627070\",\n                        \"decimals\": 18,\n                        \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                        \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                        \"ownerBurnOnly\": false,\n                        \"isReIssuable\": true,\n                        \"index\": 0,\n                        \"isOwnerBurnOnly\": false\n                    },\n                    \"confirmations\": \"3605345\",\n                    \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n                    \"receiveBlockHeight\": \"38\",\n                    \"receiveBlockHash\": \"7a6e4ab1420c3a1d319431ba77757f780578622c938afd1eb7bc8bdc4fe947fc\",\n                    \"timestamp\": 1562208615\n                }\n            ],\n            \"tokenInfo\": {\n                \"tokenName\": \"VITE\",\n                \"tokenSymbol\": \"VITE\",\n                \"totalSupply\": \"999344176075854028300627070\",\n                \"decimals\": 18,\n                \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                \"ownerBurnOnly\": false,\n                \"isReIssuable\": true,\n                \"index\": 0,\n                \"isOwnerBurnOnly\": false\n            },\n            \"confirmations\": \"3605345\",\n            \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n            \"receiveBlockHeight\": null,\n            \"receiveBlockHash\": null,\n            \"timestamp\": 1562208615\n        },\n        {\n            \"blockType\": 4,\n            \"height\": \"21845\",\n            \"hash\": \"5a78365f4f7e9c29d57c8f087c9691bfff63a4889cde5d03a89cb24d34abbdf3\",\n            \"previousHash\": \"4d2c1bc90e235b5a5fdec69bda0ebe6494f0c01b2af53accaa1beff00b9fa976\",\n            \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"publicKey\": \"1cgxEjT1L3x+mPzKsBnV4DSPiU+RTmY7akbrTCxcArE=\",\n            \"producer\": \"vite_165a295e214421ef1276e79990533953e901291d29b2d4851f\",\n            \"fromAddress\": \"vite_f74d18fc6431cb9d813c62a47a9063c4b9488219dc22c2736d\",\n            \"toAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"sendBlockHash\": \"fc2c937d542fd5b02aeadb0acb3a2f015e1cc92b94873304ab8642f703e4c059\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"amount\": \"16000000000000000000\",\n            \"fee\": \"0\",\n            \"data\": \"eo15oJWpGqoIm4hP9riEZRvcSXLUs8QKC7XBStD6yyAA\",\n            \"difficulty\": null,\n            \"nonce\": null,\n            \"signature\": \"XccA38Yxcgt1EZDdSNrgcZNC3YJ088HKNBdTt72noa1F+SbEBxmWnUjSKj5h/FlO/3SXrYnt0rU97L8JkY3lBA==\",\n            \"quotaByStake\": \"105710\",\n            \"totalQuota\": \"105710\",\n            \"vmLogHash\": \"56d05270b0d62a8dac3a01908177ed6e47899eced76bc9fa7716e808d6068705\",\n            \"triggeredSendBlockList\": [\n                {\n                    \"blockType\": 2,\n                    \"height\": \"0\",\n                    \"hash\": \"6cb62e1576bfc6652251a89b540972aceaa678f51ef4b92156b5d1a387f8b178\",\n                    \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"publicKey\": null,\n                    \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                    \"fromAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"toAddress\": \"vite_f74d18fc6431cb9d813c62a47a9063c4b9488219dc22c2736d\",\n                    \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"amount\": \"30000000000000000000\",\n                    \"fee\": \"0\",\n                    \"data\": null,\n                    \"difficulty\": null,\n                    \"nonce\": null,\n                    \"signature\": null,\n                    \"quotaByStake\": \"0\",\n                    \"totalQuota\": \"0\",\n                    \"vmLogHash\": null,\n                    \"triggeredSendBlockList\": null,\n                    \"tokenInfo\": {\n                        \"tokenName\": \"VITE\",\n                        \"tokenSymbol\": \"VITE\",\n                        \"totalSupply\": \"999344176075854028300627070\",\n                        \"decimals\": 18,\n                        \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                        \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                        \"ownerBurnOnly\": false,\n                        \"isReIssuable\": true,\n                        \"index\": 0,\n                        \"isOwnerBurnOnly\": false\n                    },\n                    \"confirmations\": \"3607047\",\n                    \"firstSnapshotHash\": \"462da9711b54219036d26b6cf8533a510e75680089a2a1ec54201bf14bdce16c\",\n                    \"receiveBlockHeight\": \"547\",\n                    \"receiveBlockHash\": \"3536cd55cb61723bf29d1ac193d39e6f049c2475370a91b8a68a7750e5d57bf5\",\n                    \"timestamp\": 1562206877\n                }\n            ],\n            \"tokenInfo\": {\n                \"tokenName\": \"VITE\",\n                \"tokenSymbol\": \"VITE\",\n                \"totalSupply\": \"999344176075854028300627070\",\n                \"decimals\": 18,\n                \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                \"ownerBurnOnly\": false,\n                \"isReIssuable\": true,\n                \"index\": 0,\n                \"isOwnerBurnOnly\": false\n            },\n            \"confirmations\": \"3607047\",\n            \"firstSnapshotHash\": \"462da9711b54219036d26b6cf8533a510e75680089a2a1ec54201bf14bdce16c\",\n            \"receiveBlockHeight\": null,\n            \"receiveBlockHash\": null,\n            \"timestamp\": 1562206877\n        },\n        {\n            \"blockType\": 4,\n            \"height\": \"21844\",\n            \"hash\": \"4d2c1bc90e235b5a5fdec69bda0ebe6494f0c01b2af53accaa1beff00b9fa976\",\n            \"previousHash\": \"b91ce0f015e7d89e87925762a8996326a979b27f7d2d7ed8d22c327937584ee4\",\n            \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"publicKey\": \"O4QZHbAsZQ4KHHzxEPuLdnVT+DiJomRrG6+zYSUSZRc=\",\n            \"producer\": \"vite_10513d54e0c38a304ad9e7902c82277328b4df76dd31871f37\",\n            \"fromAddress\": \"vite_f74d18fc6431cb9d813c62a47a9063c4b9488219dc22c2736d\",\n            \"toAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"sendBlockHash\": \"080b41f1cb5194df8d5b8903a6ed987f36291d172f93a8c67c75a87a3769308d\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"amount\": \"16000000000000000000\",\n            \"fee\": \"0\",\n            \"data\": \"wao4N2P26LmbJEmmYuINTMJoQ1MX0+EWEXSTK5CHCh4A\",\n            \"difficulty\": null,\n            \"nonce\": null,\n            \"signature\": \"RUo6punEG3XzqO/2bL3vOlOMXM9xpvUxToEBgqtP7GLYYr/9ZxrK5GamaaUHA/OyXq8jwrrX5hf1z/F8nT1BCw==\",\n            \"quotaByStake\": \"116522\",\n            \"totalQuota\": \"116522\",\n            \"vmLogHash\": \"e449ac3a53689813ef73d149f8ebb83f3fdc77812d21aaf399575dca353de895\",\n            \"triggeredSendBlockList\": [\n                {\n                    \"blockType\": 2,\n                    \"height\": \"0\",\n                    \"hash\": \"1a92be3b93725056f9df1906e1fcd1fc123f704d879b020f836daa41eacc42dd\",\n                    \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"publicKey\": null,\n                    \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                    \"fromAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"toAddress\": \"vite_f74d18fc6431cb9d813c62a47a9063c4b9488219dc22c2736d\",\n                    \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"amount\": \"4000000000000000000\",\n                    \"fee\": \"0\",\n                    \"data\": null,\n                    \"difficulty\": null,\n                    \"nonce\": null,\n                    \"signature\": null,\n                    \"quotaByStake\": \"0\",\n                    \"totalQuota\": \"0\",\n                    \"vmLogHash\": null,\n                    \"triggeredSendBlockList\": null,\n                    \"tokenInfo\": {\n                        \"tokenName\": \"VITE\",\n                        \"tokenSymbol\": \"VITE\",\n                        \"totalSupply\": \"999344176075854028300627070\",\n                        \"decimals\": 18,\n                        \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                        \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                        \"ownerBurnOnly\": false,\n                        \"isReIssuable\": true,\n                        \"index\": 0,\n                        \"isOwnerBurnOnly\": false\n                    },\n                    \"confirmations\": \"3607067\",\n                    \"firstSnapshotHash\": \"dd23c7d1c866311a41977fc008830558ad34d9bcd790ce4dad6367ee52dfedc6\",\n                    \"receiveBlockHeight\": \"545\",\n                    \"receiveBlockHash\": \"6172267c757d6234c833aaa05f393ba4a733e584a83ac8c43acf2c6c2da8510f\",\n                    \"timestamp\": 1562206856\n                }\n            ],\n            \"tokenInfo\": {\n                \"tokenName\": \"VITE\",\n                \"tokenSymbol\": \"VITE\",\n                \"totalSupply\": \"999344176075854028300627070\",\n                \"decimals\": 18,\n                \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                \"ownerBurnOnly\": false,\n                \"isReIssuable\": true,\n                \"index\": 0,\n                \"isOwnerBurnOnly\": false\n            },\n            \"confirmations\": \"3607067\",\n            \"firstSnapshotHash\": \"dd23c7d1c866311a41977fc008830558ad34d9bcd790ce4dad6367ee52dfedc6\",\n            \"receiveBlockHeight\": null,\n            \"receiveBlockHash\": null,\n            \"timestamp\": 1562206856\n        }\n    ]\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getaccountblockbyhash","title":"<code>ledger_getAccountBlockByHash</code>","text":"<p>Retrieve an account block by its hash.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>blockHash</code>: <code>hash</code> The hash of the account block.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>AccountBlock</code></li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_getAccountBlockByHash\",\n    \"params\": [\n        \"7c534db9946950197dbce8654c0538278ec38e2b1bb3e229c84df26cf936a739\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": {\n        \"blockType\": 4,\n        \"height\": \"21846\",\n        \"hash\": \"7c534db9946950197dbce8654c0538278ec38e2b1bb3e229c84df26cf936a739\",\n        \"previousHash\": \"5a78365f4f7e9c29d57c8f087c9691bfff63a4889cde5d03a89cb24d34abbdf3\",\n        \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        \"publicKey\": \"dTwfba0WWN2amkGLuMaanCNiGgJsT0ArM//zaDO3Mro=\",\n        \"producer\": \"vite_8370865362e739fb71615b8b33f9e394d85743093bdfaede6c\",\n        \"fromAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n        \"toAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        \"sendBlockHash\": \"37702663fbad5d405d78b9c53bd3206f4040ac17843852fef0d125973030318c\",\n        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n        \"amount\": \"0\",\n        \"fee\": \"0\",\n        \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\n        \"difficulty\": null,\n        \"nonce\": null,\n        \"signature\": \"FLPFkplSkoq31iJpYeNho2MyZR1BKmOD3V54U9XV3PTRWnjm5e7sOnCNWW8EgCMPbK+WYImxPueYfnZXEcnDAw==\",\n        \"quotaByStake\": \"33184\",\n        \"totalQuota\": \"33184\",\n        \"vmLogHash\": null,\n        \"triggeredSendBlockList\": [\n            {\n                \"blockType\": 2,\n                \"height\": \"0\",\n                \"hash\": \"dda7b2c0d2d6c1c1ca3c9bdb061dd4a14ee892d29ab0cdd7fc552c1e57d6f0d2\",\n                \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                \"publicKey\": null,\n                \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                \"fromAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                \"toAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n                \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"amount\": \"61984000000000000000000\",\n                \"fee\": \"0\",\n                \"data\": null,\n                \"difficulty\": null,\n                \"nonce\": null,\n                \"signature\": null,\n                \"quotaByStake\": \"0\",\n                \"totalQuota\": \"0\",\n                \"vmLogHash\": null,\n                \"triggeredSendBlockList\": null,\n                \"tokenInfo\": {\n                    \"tokenName\": \"VITE\",\n                    \"tokenSymbol\": \"VITE\",\n                    \"totalSupply\": \"999369292029736282857580488\",\n                    \"decimals\": 18,\n                    \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                    \"ownerBurnOnly\": false,\n                    \"isReIssuable\": true,\n                    \"index\": 0,\n                    \"isOwnerBurnOnly\": false\n                },\n                \"confirmations\": \"3622745\",\n                \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n                \"receiveBlockHeight\": \"38\",\n                \"receiveBlockHash\": \"7a6e4ab1420c3a1d319431ba77757f780578622c938afd1eb7bc8bdc4fe947fc\",\n                \"timestamp\": 1562208615\n            }\n        ],\n        \"tokenInfo\": {\n            \"tokenName\": \"VITE\",\n            \"tokenSymbol\": \"VITE\",\n            \"totalSupply\": \"999369292029736282857580488\",\n            \"decimals\": 18,\n            \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n            \"ownerBurnOnly\": false,\n            \"isReIssuable\": true,\n            \"index\": 0,\n            \"isOwnerBurnOnly\": false\n        },\n        \"confirmations\": \"3622745\",\n        \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n        \"receiveBlockHeight\": null,\n        \"receiveBlockHash\": null,\n        \"timestamp\": 1562208615\n    }\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getaccountblockbyheight","title":"<code>ledger_getAccountBlockByHeight</code>","text":"<p>Retrieve an account block by its height.</p> <p>Note: The height is the account block height, not the snapshot block height.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>address</code>: <code>address</code> The account address.</li> <li><code>height</code>: <code>uint64 string</code> The account block height.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>AccountBlock</code></li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_getAccountBlockByHeight\",\n    \"params\": [\n        \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        21846\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": {\n        \"blockType\": 4,\n        \"height\": \"21846\",\n        \"hash\": \"7c534db9946950197dbce8654c0538278ec38e2b1bb3e229c84df26cf936a739\",\n        \"previousHash\": \"5a78365f4f7e9c29d57c8f087c9691bfff63a4889cde5d03a89cb24d34abbdf3\",\n        \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        \"publicKey\": \"dTwfba0WWN2amkGLuMaanCNiGgJsT0ArM//zaDO3Mro=\",\n        \"producer\": \"vite_8370865362e739fb71615b8b33f9e394d85743093bdfaede6c\",\n        \"fromAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n        \"toAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        \"sendBlockHash\": \"37702663fbad5d405d78b9c53bd3206f4040ac17843852fef0d125973030318c\",\n        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n        \"amount\": \"0\",\n        \"fee\": \"0\",\n        \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\n        \"difficulty\": null,\n        \"nonce\": null,\n        \"signature\": \"FLPFkplSkoq31iJpYeNho2MyZR1BKmOD3V54U9XV3PTRWnjm5e7sOnCNWW8EgCMPbK+WYImxPueYfnZXEcnDAw==\",\n        \"quotaByStake\": \"33184\",\n        \"totalQuota\": \"33184\",\n        \"vmLogHash\": null,\n        \"triggeredSendBlockList\": [\n            {\n                \"blockType\": 2,\n                \"height\": \"0\",\n                \"hash\": \"dda7b2c0d2d6c1c1ca3c9bdb061dd4a14ee892d29ab0cdd7fc552c1e57d6f0d2\",\n                \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                \"publicKey\": null,\n                \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                \"fromAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                \"toAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n                \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"amount\": \"61984000000000000000000\",\n                \"fee\": \"0\",\n                \"data\": null,\n                \"difficulty\": null,\n                \"nonce\": null,\n                \"signature\": null,\n                \"quotaByStake\": \"0\",\n                \"totalQuota\": \"0\",\n                \"vmLogHash\": null,\n                \"triggeredSendBlockList\": null,\n                \"tokenInfo\": {\n                    \"tokenName\": \"VITE\",\n                    \"tokenSymbol\": \"VITE\",\n                    \"totalSupply\": \"999998383901711633310557566\",\n                    \"decimals\": 18,\n                    \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                    \"ownerBurnOnly\": false,\n                    \"isReIssuable\": true,\n                    \"index\": 0,\n                    \"isOwnerBurnOnly\": false\n                },\n                \"confirmations\": \"4299959\",\n                \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n                \"receiveBlockHeight\": \"38\",\n                \"receiveBlockHash\": \"7a6e4ab1420c3a1d319431ba77757f780578622c938afd1eb7bc8bdc4fe947fc\",\n                \"timestamp\": 1562208615\n            }\n        ],\n        \"tokenInfo\": {\n            \"tokenName\": \"VITE\",\n            \"tokenSymbol\": \"VITE\",\n            \"totalSupply\": \"999998383901711633310557566\",\n            \"decimals\": 18,\n            \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n            \"ownerBurnOnly\": false,\n            \"isReIssuable\": true,\n            \"index\": 0,\n            \"isOwnerBurnOnly\": false\n        },\n        \"confirmations\": \"4299954\",\n        \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n        \"receiveBlockHeight\": null,\n        \"receiveBlockHash\": null,\n        \"timestamp\": 1562208615\n    }\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getaccountblocksbyaddress","title":"<code>ledger_getAccountBlocksByAddress</code>","text":"<p>Retrieve account blocks by page number, sorted in descending order by account block height.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>address</code>: <code>address</code> The account address.</li> <li><code>pageIndex</code>: <code>uint64</code> The page number, starting from 0.</li> <li><code>pageSize</code>: <code>uint64</code> The page size, with a maximum value of 1000.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>List&lt;AccountBlock&gt;</code> See AccountBlock for details.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_getAccountBlocksByAddress\",\n    \"params\": [\n        \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        0,\n        3\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": [\n        {\n            \"blockType\": 4,\n            \"height\": \"21846\",\n            \"hash\": \"7c534db9946950197dbce8654c0538278ec38e2b1bb3e229c84df26cf936a739\",\n            \"previousHash\": \"5a78365f4f7e9c29d57c8f087c9691bfff63a4889cde5d03a89cb24d34abbdf3\",\n            \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"publicKey\": \"dTwfba0WWN2amkGLuMaanCNiGgJsT0ArM//zaDO3Mro=\",\n            \"producer\": \"vite_8370865362e739fb71615b8b33f9e394d85743093bdfaede6c\",\n            \"fromAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n            \"toAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"sendBlockHash\": \"37702663fbad5d405d78b9c53bd3206f4040ac17843852fef0d125973030318c\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"amount\": \"0\",\n            \"fee\": \"0\",\n            \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\n            \"difficulty\": null,\n            \"nonce\": null,\n            \"signature\": \"FLPFkplSkoq31iJpYeNho2MyZR1BKmOD3V54U9XV3PTRWnjm5e7sOnCNWW8EgCMPbK+WYImxPueYfnZXEcnDAw==\",\n            \"quotaByStake\": \"33184\",\n            \"totalQuota\": \"33184\",\n            \"vmLogHash\": null,\n            \"triggeredSendBlockList\": [\n                {\n                    \"blockType\": 2,\n                    \"height\": \"0\",\n                    \"hash\": \"dda7b2c0d2d6c1c1ca3c9bdb061dd4a14ee892d29ab0cdd7fc552c1e57d6f0d2\",\n                    \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"publicKey\": null,\n                    \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                    \"fromAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"toAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n                    \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"amount\": \"61984000000000000000000\",\n                    \"fee\": \"0\",\n                    \"data\": null,\n                    \"difficulty\": null,\n                    \"nonce\": null,\n                    \"signature\": null,\n                    \"quotaByStake\": \"0\",\n                    \"totalQuota\": \"0\",\n                    \"vmLogHash\": null,\n                    \"triggeredSendBlockList\": null,\n                    \"tokenInfo\": {\n                        \"tokenName\": \"VITE\",\n                        \"tokenSymbol\": \"VITE\",\n                        \"totalSupply\": \"1000032113155962510026863838\",\n                        \"decimals\": 18,\n                        \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                        \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                        \"ownerBurnOnly\": false,\n                        \"isReIssuable\": true,\n                        \"index\": 0,\n                        \"isOwnerBurnOnly\": false\n                    },\n                    \"confirmations\": \"4368185\",\n                    \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n                    \"receiveBlockHeight\": \"38\",\n                    \"receiveBlockHash\": \"7a6e4ab1420c3a1d319431ba77757f780578622c938afd1eb7bc8bdc4fe947fc\",\n                    \"timestamp\": 1562208615\n                }\n            ],\n            \"tokenInfo\": {\n                \"tokenName\": \"VITE\",\n                \"tokenSymbol\": \"VITE\",\n                \"totalSupply\": \"1000032113155962510026863838\",\n                \"decimals\": 18,\n                \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                \"ownerBurnOnly\": false,\n                \"isReIssuable\": true,\n                \"index\": 0,\n                \"isOwnerBurnOnly\": false\n            },\n            \"confirmations\": \"4368185\",\n            \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n            \"receiveBlockHeight\": null,\n            \"receiveBlockHash\": null,\n            \"timestamp\": 1562208615\n        },\n        {\n            \"blockType\": 4,\n            \"height\": \"21845\",\n            \"hash\": \"5a78365f4f7e9c29d57c8f087c9691bfff63a4889cde5d03a89cb24d34abbdf3\",\n            \"previousHash\": \"4d2c1bc90e235b5a5fdec69bda0ebe6494f0c01b2af53accaa1beff00b9fa976\",\n            \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"publicKey\": \"1cgxEjT1L3x+mPzKsBnV4DSPiU+RTmY7akbrTCxcArE=\",\n            \"producer\": \"vite_165a295e214421ef1276e79990533953e901291d29b2d4851f\",\n            \"fromAddress\": \"vite_f74d18fc6431cb9d813c62a47a9063c4b9488219dc22c2736d\",\n            \"toAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"sendBlockHash\": \"fc2c937d542fd5b02aeadb0acb3a2f015e1cc92b94873304ab8642f703e4c059\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"amount\": \"16000000000000000000\",\n            \"fee\": \"0\",\n            \"data\": \"eo15oJWpGqoIm4hP9riEZRvcSXLUs8QKC7XBStD6yyAA\",\n            \"difficulty\": null,\n            \"nonce\": null,\n            \"signature\": \"XccA38Yxcgt1EZDdSNrgcZNC3YJ088HKNBdTt72noa1F+SbEBxmWnUjSKj5h/FlO/3SXrYnt0rU97L8JkY3lBA==\",\n            \"quotaByStake\": \"105710\",\n            \"totalQuota\": \"105710\",\n            \"vmLogHash\": \"56d05270b0d62a8dac3a01908177ed6e47899eced76bc9fa7716e808d6068705\",\n            \"triggeredSendBlockList\": [\n                {\n                    \"blockType\": 2,\n                    \"height\": \"0\",\n                    \"hash\": \"6cb62e1576bfc6652251a89b540972aceaa678f51ef4b92156b5d1a387f8b178\",\n                    \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"publicKey\": null,\n                    \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                    \"fromAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"toAddress\": \"vite_f74d18fc6431cb9d813c62a47a9063c4b9488219dc22c2736d\",\n                    \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"amount\": \"30000000000000000000\",\n                    \"fee\": \"0\",\n                    \"data\": null,\n                    \"difficulty\": null,\n                    \"nonce\": null,\n                    \"signature\": null,\n                    \"quotaByStake\": \"0\",\n                    \"totalQuota\": \"0\",\n                    \"vmLogHash\": null,\n                    \"triggeredSendBlockList\": null,\n                    \"tokenInfo\": {\n                        \"tokenName\": \"VITE\",\n                        \"tokenSymbol\": \"VITE\",\n                        \"totalSupply\": \"1000032113155962510026863838\",\n                        \"decimals\": 18,\n                        \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                        \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                        \"ownerBurnOnly\": false,\n                        \"isReIssuable\": true,\n                        \"index\": 0,\n                        \"isOwnerBurnOnly\": false\n                    },\n                    \"confirmations\": \"4369892\",\n                    \"firstSnapshotHash\": \"462da9711b54219036d26b6cf8533a510e75680089a2a1ec54201bf14bdce16c\",\n                    \"receiveBlockHeight\": \"547\",\n                    \"receiveBlockHash\": \"3536cd55cb61723bf29d1ac193d39e6f049c2475370a91b8a68a7750e5d57bf5\",\n                    \"timestamp\": 1562206877\n                }\n            ],\n            \"tokenInfo\": {\n                \"tokenName\": \"VITE\",\n                \"tokenSymbol\": \"VITE\",\n                \"totalSupply\": \"1000032113155962510026863838\",\n                \"decimals\": 18,\n                \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                \"ownerBurnOnly\": false,\n                \"isReIssuable\": true,\n                \"index\": 0,\n                \"isOwnerBurnOnly\": false\n            },\n            \"confirmations\": \"4369891\",\n            \"firstSnapshotHash\": \"462da9711b54219036d26b6cf8533a510e75680089a2a1ec54201bf14bdce16c\",\n            \"receiveBlockHeight\": null,\n            \"receiveBlockHash\": null,\n            \"timestamp\": 1562206877\n        },\n        {\n            \"blockType\": 4,\n            \"height\": \"21844\",\n            \"hash\": \"4d2c1bc90e235b5a5fdec69bda0ebe6494f0c01b2af53accaa1beff00b9fa976\",\n            \"previousHash\": \"b91ce0f015e7d89e87925762a8996326a979b27f7d2d7ed8d22c327937584ee4\",\n            \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"publicKey\": \"O4QZHbAsZQ4KHHzxEPuLdnVT+DiJomRrG6+zYSUSZRc=\",\n            \"producer\": \"vite_10513d54e0c38a304ad9e7902c82277328b4df76dd31871f37\",\n            \"fromAddress\": \"vite_f74d18fc6431cb9d813c62a47a9063c4b9488219dc22c2736d\",\n            \"toAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"sendBlockHash\": \"080b41f1cb5194df8d5b8903a6ed987f36291d172f93a8c67c75a87a3769308d\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"amount\": \"16000000000000000000\",\n            \"fee\": \"0\",\n            \"data\": \"wao4N2P26LmbJEmmYuINTMJoQ1MX0+EWEXSTK5CHCh4A\",\n            \"difficulty\": null,\n            \"nonce\": null,\n            \"signature\": \"RUo6punEG3XzqO/2bL3vOlOMXM9xpvUxToEBgqtP7GLYYr/9ZxrK5GamaaUHA/OyXq8jwrrX5hf1z/F8nT1BCw==\",\n            \"quotaByStake\": \"116522\",\n            \"totalQuota\": \"116522\",\n            \"vmLogHash\": \"e449ac3a53689813ef73d149f8ebb83f3fdc77812d21aaf399575dca353de895\",\n            \"triggeredSendBlockList\": [\n                {\n                    \"blockType\": 2,\n                    \"height\": \"0\",\n                    \"hash\": \"1a92be3b93725056f9df1906e1fcd1fc123f704d879b020f836daa41eacc42dd\",\n                    \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"publicKey\": null,\n                    \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                    \"fromAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                    \"toAddress\": \"vite_f74d18fc6431cb9d813c62a47a9063c4b9488219dc22c2736d\",\n                    \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"amount\": \"4000000000000000000\",\n                    \"fee\": \"0\",\n                    \"data\": null,\n                    \"difficulty\": null,\n                    \"nonce\": null,\n                    \"signature\": null,\n                    \"quotaByStake\": \"0\",\n                    \"totalQuota\": \"0\",\n                    \"vmLogHash\": null,\n                    \"triggeredSendBlockList\": null,\n                    \"tokenInfo\": {\n                        \"tokenName\": \"VITE\",\n                        \"tokenSymbol\": \"VITE\",\n                        \"totalSupply\": \"1000032113155962510026863838\",\n                        \"decimals\": 18,\n                        \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                        \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                        \"ownerBurnOnly\": false,\n                        \"isReIssuable\": true,\n                        \"index\": 0,\n                        \"isOwnerBurnOnly\": false\n                    },\n                    \"confirmations\": \"4369916\",\n                    \"firstSnapshotHash\": \"dd23c7d1c866311a41977fc008830558ad34d9bcd790ce4dad6367ee52dfedc6\",\n                    \"receiveBlockHeight\": \"545\",\n                    \"receiveBlockHash\": \"6172267c757d6234c833aaa05f393ba4a733e584a83ac8c43acf2c6c2da8510f\",\n                    \"timestamp\": 1562206856\n                }\n            ],\n            \"tokenInfo\": {\n                \"tokenName\": \"VITE\",\n                \"tokenSymbol\": \"VITE\",\n                \"totalSupply\": \"1000032113155962510026863838\",\n                \"decimals\": 18,\n                \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                \"ownerBurnOnly\": false,\n                \"isReIssuable\": true,\n                \"index\": 0,\n                \"isOwnerBurnOnly\": false\n            },\n            \"confirmations\": \"4369913\",\n            \"firstSnapshotHash\": \"dd23c7d1c866311a41977fc008830558ad34d9bcd790ce4dad6367ee52dfedc6\",\n            \"receiveBlockHeight\": null,\n            \"receiveBlockHash\": null,\n            \"timestamp\": 1562206856\n        }\n    ]\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getaccountblocksbyheightrange","title":"<code>ledger_getAccountBlocksByHeightRange</code>","text":"<p>Retrieve account blocks by height range, sorted in descending order by height.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>address</code>: <code>address</code> The account address.</li> <li><code>startHeight</code>: <code>uint64</code> The starting height, inclusive.</li> <li><code>endHeight</code>: <code>uint64</code> The ending height, inclusive. Must satisfy $endHeight-StartHeight \\le 1000$.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>List&lt;AccountBlock&gt;</code> See AccountBlock for details.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_getAccountBlocksByHeightRange\",\n    \"params\": [\n        \"vite_8cf2663cc949442db2d3f78f372621733292d1fb0b846f1651\",\n        2,\n        3\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": [\n        {\n            \"blockType\": 4,\n            \"height\": \"3\",\n            \"hash\": \"77a73b411c8c91018f17f4b5009f275aaa88ec2c0f99b9e3afd7fca4926838d8\",\n            \"previousHash\": \"8d3c065c82d3a9641fef93cc3bf03d8a15481ccdd6dc52f3d9ef059defd45e17\",\n            \"address\": \"vite_8cf2663cc949442db2d3f78f372621733292d1fb0b846f1651\",\n            \"publicKey\": \"nnm7Tj1o/2MFDqPquG4NRZBVzilImBmaP3XstaOx/rg=\",\n            \"producer\": \"vite_e7a01e66d920c6c5ce82e9353ca57267f6534e357bbee63063\",\n            \"fromAddress\": \"vite_4bbc86782244caef6ba50ebc9418777a3abf2de4de527acbf4\",\n            \"toAddress\": \"vite_8cf2663cc949442db2d3f78f372621733292d1fb0b846f1651\",\n            \"sendBlockHash\": \"e050c1ca6d740098696b9c0442f57ce2163b70cd93109461ca2693cde3fbdafb\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"amount\": \"0\",\n            \"fee\": \"0\",\n            \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\n            \"difficulty\": null,\n            \"nonce\": null,\n            \"signature\": \"rHGYUV+yBPlfCfTFGlace288E5Y07WQNTvZ2R5jJ7Z9Qo0SGoZE7JkV6c9TMEWF9PSIuDv18kDibAntEnQswAw==\",\n            \"quotaByStake\": \"92012\",\n            \"totalQuota\": \"92012\",\n            \"vmLogHash\": null,\n            \"triggeredSendBlockList\": [\n                {\n                    \"blockType\": 2,\n                    \"height\": \"0\",\n                    \"hash\": \"fe79d57a6f5f943993428c8b9730dde3980925e88a7caf1833e570a2e3f812b3\",\n                    \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"address\": \"vite_8cf2663cc949442db2d3f78f372621733292d1fb0b846f1651\",\n                    \"publicKey\": null,\n                    \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                    \"fromAddress\": \"vite_8cf2663cc949442db2d3f78f372621733292d1fb0b846f1651\",\n                    \"toAddress\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                    \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"tokenId\": \"tti_2445f6e5cde8c2c70e446c83\",\n                    \"amount\": \"0\",\n                    \"fee\": \"0\",\n                    \"data\": \"QvLu5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApWaXRlX1NCUDAzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n                    \"difficulty\": null,\n                    \"nonce\": null,\n                    \"signature\": null,\n                    \"quotaByStake\": \"0\",\n                    \"totalQuota\": \"0\",\n                    \"vmLogHash\": null,\n                    \"triggeredSendBlockList\": null,\n                    \"tokenInfo\": null,\n                    \"confirmations\": \"42727483\",\n                    \"firstSnapshotHash\": \"136db1f87a0614b9ea95f02c3fe48797b308d9b0480276b62c79c62a71a31538\",\n                    \"firstSnapshotHeight\": \"57514560\",\n                    \"receiveBlockHeight\": \"82378\",\n                    \"receiveBlockHash\": \"94aea19bf80ae3da9848b323d53f0a3a4193f6607b6562599c20ec0484071cf2\",\n                    \"timestamp\": 1617288661\n                }\n            ],\n            \"tokenInfo\": {\n                \"tokenName\": \"VITE\",\n                \"tokenSymbol\": \"VITE\",\n                \"totalSupply\": \"1046262261897786596300087194\",\n                \"decimals\": 18,\n                \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                \"ownerBurnOnly\": false,\n                \"isReIssuable\": true,\n                \"index\": 0,\n                \"isOwnerBurnOnly\": false\n            },\n            \"confirmations\": \"42727483\",\n            \"firstSnapshotHash\": \"136db1f87a0614b9ea95f02c3fe48797b308d9b0480276b62c79c62a71a31538\",\n            \"firstSnapshotHeight\": \"57514560\",\n            \"receiveBlockHeight\": null,\n            \"receiveBlockHash\": null,\n            \"timestamp\": 1617288661\n        },\n        {\n            \"blockType\": 4,\n            \"height\": \"2\",\n            \"hash\": \"8d3c065c82d3a9641fef93cc3bf03d8a15481ccdd6dc52f3d9ef059defd45e17\",\n            \"previousHash\": \"b28f2fc25e64fd1ae15eaefcc6c75aefe5455ccccf3e87efedc2789230f8b5ea\",\n            \"address\": \"vite_8cf2663cc949442db2d3f78f372621733292d1fb0b846f1651\",\n            \"publicKey\": \"Xxb2uqw1KnkjQDAs9IODnPIze8GKmras7xf/rBUxudI=\",\n            \"producer\": \"vite_5e9ba7ab0a8144717de75bb93b32322bef00a3b42ff35efca2\",\n            \"fromAddress\": \"vite_4bbc86782244caef6ba50ebc9418777a3abf2de4de527acbf4\",\n            \"toAddress\": \"vite_8cf2663cc949442db2d3f78f372621733292d1fb0b846f1651\",\n            \"sendBlockHash\": \"829fa207fe4c26610520034848b5664f66615e09b17dc023b795f13e0cfe63c1\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"amount\": \"0\",\n            \"fee\": \"0\",\n            \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\n            \"difficulty\": null,\n            \"nonce\": null,\n            \"signature\": \"cNratdbDlM1Bwc4TbqFh07HFhVFhSeb6Se/bgj6ZY66fl5AY1BIJG96yoK5sXJq2yo3NXdQ/aUC0+y8ZMLW0Cg==\",\n            \"quotaByStake\": \"92012\",\n            \"totalQuota\": \"92012\",\n            \"vmLogHash\": null,\n            \"triggeredSendBlockList\": [\n                {\n                    \"blockType\": 2,\n                    \"height\": \"0\",\n                    \"hash\": \"5c5cd3ea5c919746d4d73108e1481139557bd8421dc439ea64114867a4fd7155\",\n                    \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"address\": \"vite_8cf2663cc949442db2d3f78f372621733292d1fb0b846f1651\",\n                    \"publicKey\": null,\n                    \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                    \"fromAddress\": \"vite_8cf2663cc949442db2d3f78f372621733292d1fb0b846f1651\",\n                    \"toAddress\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                    \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"tokenId\": \"tti_2445f6e5cde8c2c70e446c83\",\n                    \"amount\": \"0\",\n                    \"fee\": \"0\",\n                    \"data\": \"QvLu5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxGdWxsTm9kZVBvb2wAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n                    \"difficulty\": null,\n                    \"nonce\": null,\n                    \"signature\": null,\n                    \"quotaByStake\": \"0\",\n                    \"totalQuota\": \"0\",\n                    \"vmLogHash\": null,\n                    \"triggeredSendBlockList\": null,\n                    \"tokenInfo\": null,\n                    \"confirmations\": \"42727593\",\n                    \"firstSnapshotHash\": \"4b0ed157a1e09e468fa36215284046ae9891161bf01e1c5be01bf2e2e9ac7d34\",\n                    \"firstSnapshotHeight\": \"57514450\",\n                    \"receiveBlockHeight\": \"82377\",\n                    \"receiveBlockHash\": \"8a598e294b665621a6b8bc7c8dc2e0b6f50e818fd43c13a96cb3e8620d4b10da\",\n                    \"timestamp\": 1617288551\n                }\n            ],\n            \"tokenInfo\": {\n                \"tokenName\": \"VITE\",\n                \"tokenSymbol\": \"VITE\",\n                \"totalSupply\": \"1046262261897786596300087194\",\n                \"decimals\": 18,\n                \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                \"ownerBurnOnly\": false,\n                \"isReIssuable\": true,\n                \"index\": 0,\n                \"isOwnerBurnOnly\": false\n            },\n            \"confirmations\": \"42727593\",\n            \"firstSnapshotHash\": \"4b0ed157a1e09e468fa36215284046ae9891161bf01e1c5be01bf2e2e9ac7d34\",\n            \"firstSnapshotHeight\": \"57514450\",\n            \"receiveBlockHeight\": null,\n            \"receiveBlockHash\": null,\n            \"timestamp\": 1617288551\n        }\n    ]\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getcompleteblockbyhash","title":"<code>ledger_getCompleteBlockByHash</code>","text":"<p>Retrieve an RS block containing the response block by account block hash.</p> <p>Note: If the given account block is not an RS block, the result will be the same as ledger_getAccountBlockByHash.</p> <ul> <li> <p>Parameters:</p> </li> <li> <p>Returns:</p> <ul> <li><code>AccountBlock</code></li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_getCompleteBlockByHash\",\n    \"params\": [\n        \"dda7b2c0d2d6c1c1ca3c9bdb061dd4a14ee892d29ab0cdd7fc552c1e57d6f0d2\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": {\n        \"blockType\": 4,\n        \"height\": \"21846\",\n        \"hash\": \"7c534db9946950197dbce8654c0538278ec38e2b1bb3e229c84df26cf936a739\",\n        \"previousHash\": \"5a78365f4f7e9c29d57c8f087c9691bfff63a4889cde5d03a89cb24d34abbdf3\",\n        \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        \"publicKey\": \"dTwfba0WWN2amkGLuMaanCNiGgJsT0ArM//zaDO3Mro=\",\n        \"producer\": \"vite_8370865362e739fb71615b8b33f9e394d85743093bdfaede6c\",\n        \"fromAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n        \"toAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        \"sendBlockHash\": \"37702663fbad5d405d78b9c53bd3206f4040ac17843852fef0d125973030318c\",\n        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n        \"amount\": \"0\",\n        \"fee\": \"0\",\n        \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\n        \"difficulty\": null,\n        \"nonce\": null,\n        \"signature\": \"FLPFkplSkoq31iJpYeNho2MyZR1BKmOD3V54U9XV3PTRWnjm5e7sOnCNWW8EgCMPbK+WYImxPueYfnZXEcnDAw==\",\n        \"quotaByStake\": \"33184\",\n        \"totalQuota\": \"33184\",\n        \"vmLogHash\": null,\n        \"triggeredSendBlockList\": [\n            {\n                \"blockType\": 2,\n                \"height\": \"0\",\n                \"hash\": \"dda7b2c0d2d6c1c1ca3c9bdb061dd4a14ee892d29ab0cdd7fc552c1e57d6f0d2\",\n                \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                \"publicKey\": null,\n                \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                \"fromAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                \"toAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n                \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"amount\": \"61984000000000000000000\",\n                \"fee\": \"0\",\n                \"data\": null,\n                \"difficulty\": null,\n                \"nonce\": null,\n                \"signature\": null,\n                \"quotaByStake\": \"0\",\n                \"totalQuota\": \"0\",\n                \"vmLogHash\": null,\n                \"triggeredSendBlockList\": null,\n                \"tokenInfo\": {\n                    \"tokenName\": \"VITE\",\n                    \"tokenSymbol\": \"VITE\",\n                    \"totalSupply\": \"999369292029736282857580488\",\n                    \"decimals\": 18,\n                    \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                    \"ownerBurnOnly\": false,\n                    \"isReIssuable\": true,\n                    \"index\": 0,\n                    \"isOwnerBurnOnly\": false\n                },\n                \"confirmations\": \"3622745\",\n                \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n                \"receiveBlockHeight\": \"38\",\n                \"receiveBlockHash\": \"7a6e4ab1420c3a1d319431ba77757f780578622c938afd1eb7bc8bdc4fe947fc\",\n                \"timestamp\": 1562208615\n            }\n        ],\n        \"tokenInfo\": {\n            \"tokenName\": \"VITE\",\n            \"tokenSymbol\": \"VITE\",\n            \"totalSupply\": \"999369292029736282857580488\",\n            \"decimals\": 18,\n            \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n            \"ownerBurnOnly\": false,\n            \"isReIssuable\": true,\n            \"index\": 0,\n            \"isOwnerBurnOnly\": false\n        },\n        \"confirmations\": \"3622745\",\n        \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n        \"receiveBlockHeight\": null,\n        \"receiveBlockHash\": null,\n        \"timestamp\": 1562208615\n    }\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getlatestaccountblock","title":"<code>ledger_getLatestAccountBlock</code>","text":"<p>Fetch the latest account block by address.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>address</code>: <code>address</code> The account address.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>AccountBlock</code></li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_getLatestAccountBlock\",\n    \"params\": [\n        \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": {\n        \"blockType\": 4,\n        \"height\": \"21846\",\n        \"hash\": \"7c534db9946950197dbce8654c0538278ec38e2b1bb3e229c84df26cf936a739\",\n        \"previousHash\": \"5a78365f4f7e9c29d57c8f087c9691bfff63a4889cde5d03a89cb24d34abbdf3\",\n        \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        \"publicKey\": \"dTwfba0WWN2amkGLuMaanCNiGgJsT0ArM//zaDO3Mro=\",\n        \"producer\": \"vite_8370865362e739fb71615b8b33f9e394d85743093bdfaede6c\",\n        \"fromAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n        \"toAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        \"sendBlockHash\": \"37702663fbad5d405d78b9c53bd3206f4040ac17843852fef0d125973030318c\",\n        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n        \"amount\": \"0\",\n        \"fee\": \"0\",\n        \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\",\n        \"difficulty\": null,\n        \"nonce\": null,\n        \"signature\": \"FLPFkplSkoq31iJpYeNho2MyZR1BKmOD3V54U9XV3PTRWnjm5e7sOnCNWW8EgCMPbK+WYImxPueYfnZXEcnDAw==\",\n        \"quotaByStake\": \"33184\",\n        \"totalQuota\": \"33184\",\n        \"vmLogHash\": null,\n        \"triggeredSendBlockList\": [\n            {\n                \"blockType\": 2,\n                \"height\": \"0\",\n                \"hash\": \"dda7b2c0d2d6c1c1ca3c9bdb061dd4a14ee892d29ab0cdd7fc552c1e57d6f0d2\",\n                \"previousHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                \"publicKey\": null,\n                \"producer\": \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\",\n                \"fromAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n                \"toAddress\": \"vite_ea6a2f80f3469a001586cca12ac1676bb24484153c419d3db9\",\n                \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"amount\": \"61984000000000000000000\",\n                \"fee\": \"0\",\n                \"data\": null,\n                \"difficulty\": null,\n                \"nonce\": null,\n                \"signature\": null,\n                \"quotaByStake\": \"0\",\n                \"totalQuota\": \"0\",\n                \"vmLogHash\": null,\n                \"triggeredSendBlockList\": null,\n                \"tokenInfo\": {\n                    \"tokenName\": \"VITE\",\n                    \"tokenSymbol\": \"VITE\",\n                    \"totalSupply\": \"1000045942413038967590996145\",\n                    \"decimals\": 18,\n                    \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                    \"ownerBurnOnly\": false,\n                    \"isReIssuable\": true,\n                    \"index\": 0,\n                    \"isOwnerBurnOnly\": false\n                },\n                \"confirmations\": \"4420249\",\n                \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n                \"receiveBlockHeight\": \"38\",\n                \"receiveBlockHash\": \"7a6e4ab1420c3a1d319431ba77757f780578622c938afd1eb7bc8bdc4fe947fc\",\n                \"timestamp\": 1562208615\n            }\n        ],\n        \"tokenInfo\": {\n            \"tokenName\": \"VITE\",\n            \"tokenSymbol\": \"VITE\",\n            \"totalSupply\": \"1000045942413038967590996145\",\n            \"decimals\": 18,\n            \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n            \"ownerBurnOnly\": false,\n            \"isReIssuable\": true,\n            \"index\": 0,\n            \"isOwnerBurnOnly\": false\n        },\n        \"confirmations\": \"4420245\",\n        \"firstSnapshotHash\": \"33d527c8f6ba7fdef69a6bf6171b53ae000460e08486bb25fb88d44f4c789147\",\n        \"receiveBlockHeight\": null,\n        \"receiveBlockHash\": null,\n        \"timestamp\": 1562208615\n    }\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getsnapshotchainheight","title":"<code>ledger_getSnapshotChainHeight</code>","text":"<p>Get the current snapshot chain height.</p> <ul> <li> <p>Parameters: none</p> </li> <li> <p>Returns:</p> <ul> <li><code>height</code>: <code>uint64 string</code> The current snapshot chain height.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ledger_getSnapshotChainHeight\",\n    \"params\": null\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"1816565\"\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getsnapshotblockbyhash","title":"<code>ledger_getSnapshotBlockByHash</code>","text":"<p>Fetch a snapshot block by its hash.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>blockHash</code>: <code>hash</code> The hash of the snapshot block.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>SnapshotBlock</code></li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"ledger_getSnapshotBlockByHash\",\n    \"params\": [\n        \"579db20cb0ef854bba4636d6eaff499ae106ecd918826072a75d47f3e7cbe857\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"result\": {\n        \"producer\": \"vite_94badf80abab06dc1cdb4d21038a6799040bb2feb154f730cb\",\n        \"hash\": \"579db20cb0ef854bba4636d6eaff499ae106ecd918826072a75d47f3e7cbe857\",\n        \"previousHash\": \"18cf03a6c5d5128bc0a419f23713689cb279165d057759640c700c28c9315470\",\n        \"height\": 1807756,\n        \"publicKey\": \"zpwPhKs0jClH2JYqn3HieI3SPqm97PMKZlsive8PjBw=\",\n        \"signature\": \"EzgWq2h2h+qkIHhsKSHK7IMIn3M9bAVR3Sy8ZpaLx2U7BJ6mjVhKIuerEKLcEsY9qbPfc9IYgJ9YYpd1uVK4Dw==\",\n        \"seed\": 15994478024988707574,\n        \"nextSeedHash\": \"360f20aa86891f67fdab4da09fc4068521c7ffb581f54761f602c2771ecdb097\",\n        \"snapshotData\": {\n            \"vite_61088b1d4d334271f0ead08a1eec17b08e7ef25141dd427787\": {\n                \"height\": 9596,\n                \"hash\": \"b8a272bcebb5176fc5b918b6d1e4fc9aca5fd6a0be1fcea99386c6f8ae98a5c1\"\n            },\n            \"vite_866d14993fd17f8090d1b0b99e13318c0f99fdd180d3b6cca9\": {\n                \"height\": 777,\n                \"hash\": \"c78843e347f5927d255f4b57704335dc43222041bf5f27d45980ac83fcf1dbb3\"\n            }\n        },\n        \"timestamp\": 1560422154,\n        \"version\": 9\n    }\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getsnapshotblockbyheight","title":"<code>ledger_getSnapshotBlockByHeight</code>","text":"<p>Fetch a snapshot block by its height.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>height</code>: <code>uint64</code> The height of the snapshot block.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>SnapshotBlock</code></li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"ledger_getSnapshotBlockByHeight\",\n    \"params\": [\n        6363411\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": {\n        \"hash\": \"1cf965e7b9a8ab4a3758e7c2fa97890ce8724cfd071cd0b0966c1be17cfc48ad\",\n        \"previousHash\": \"ce0e8595aace97b2732126afd104c889d71f87586740f401135f1ff58309363e\",\n        \"height\": 6363411,\n        \"publicKey\": \"uPBd4umnBsp0rGrKQWWsabcawNYEjPh3MKXnGNVTMWs=\",\n        \"signature\": \"JcYfU1LWuZTgKgpMrQ1T6uUuw3krUImikmgTqoyEDXubYt00ND/loABQ7KoQkBh8PYQOvVrPZtBjVlTGWJx6DQ==\",\n        \"timestamp\": \"1558012705\",\n        \"seed\": 15994478024988707574,\n        \"nextSeedHash\": \"360f20aa86891f67fdab4da09fc4068521c7ffb581f54761f602c2771ecdb097\",\n        \"snapshotData\": {\n            \"vite_56fd05b23ff26cd7b0a40957fb77bde60c9fd6ebc35f809c23\": {\n                \"height\": 31578,\n                \"hash\": \"91fa958eb01f82b93ef4077a938fe9f9b5e1c2555979045e0a3c3b06721e69cc\"\n            },\n            \"vite_eef384a5fc40e0fbe282411e1d8e70c0f3c0e4a4f783448780\": {\n                \"height\": 894,\n                \"hash\": \"347a08b2e7666db832b1e0f69972f9dd1875fe6c1d3fc03aa55ab07e9a4858ae\"\n            }\n        },\n        \"version\": 9\n    }\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getsnapshotblocks","title":"<code>ledger_getSnapshotBlocks</code>","text":"<p>Fetch a number of snapshot blocks by start height and count in descending order.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>height</code>: <code>uint64 string</code> The start block height.</li> <li><code>count</code>: <code>uint64</code> The number of blocks to fetch. Maximum 1000.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>List&lt;SnapshotBlock&gt;</code> See SnapshotBlock for details.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"ledger_getSnapshotBlocks\",\n    \"params\": [100, 2]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": [\n        {\n            \"producer\": \"vite_c1d11e6eda9a9b80e388a38e0ac541cbc3333736233b4eaaab\",\n            \"hash\": \"ca09e12f7a14bce2d22cfe87f557536fd3a4d77d1b3e84e6a46dd0820d9d3c58\",\n            \"height\": 100,\n            \"publicKey\": \"h3B0rM7qM8ZZzfLwFxfmrEFlO8J4X7dP8j+TDxfEgyc=\",\n            \"signature\": \"9INk9B3b3ZF3iOCU9mY2RYy0kEpGMSxx/ohiDwPqz9MLOA7R7C4Lo5ioROXV5DdhRhaEm+xca2RApmoM9vfrAA==\",\n            \"seed\": 0,\n            \"version\": 0,\n            \"previousHash\": \"75e9e5212729d9df18a402166b7125a5b0557bd3485d21d61ec146f07309a539\",\n            \"nextSeedHash\": null,\n            \"snapshotData\": null,\n            \"timestamp\": 1558458875\n        },\n        {\n            \"producer\": \"vite_c1d11e6eda9a9b80e388a38e0ac541cbc3333736233b4eaaab\",\n            \"hash\": \"75e9e5212729d9df18a402166b7125a5b0557bd3485d21d61ec146f07309a539\",\n            \"height\": 99,\n            \"publicKey\": \"h3B0rM7qM8ZZzfLwFxfmrEFlO8J4X7dP8j+TDxfEgyc=\",\n            \"signature\": \"Fjtf1gSpmyhAYtbK7B8P3aJahxbvzTTpAu/MbUOAtGJscY5IeBDDi8MWpiQEUD7iWOR1Fuk9c/rgUAElxz2UBw==\",\n            \"seed\": 0,\n            \"version\": 0,\n            \"previousHash\": \"f2fd5242876461a625e18fb26ab48e011a0fa6bf3002796d3417a3a09365f376\",\n            \"nextSeedHash\": null,\n            \"snapshotData\": null,\n            \"timestamp\": 1558458874\n        }\n    ]\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getchunks","title":"<code>ledger_getChunks</code>","text":"<p>Fetch a number of snapshot blocks with snapshotted account blocks by height range.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>startHeight</code>: <code>uint64 string</code> The start height, inclusive.</li> <li><code>endHeight</code>: <code>uint64 string</code> The end height, inclusive. Must satisfy $\\le StartHeight + 1000$.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>List&lt;SnapshotChunk&gt;</code><ul> <li><code>SnapshotBlock</code> See SnapshotBlock</li> <li><code>List&lt;AccountBlock&gt;</code> See AccountBlock</li> </ul> </li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ledger_getChunks\",\n    \"params\": [\n        \"100\",\n        \"101\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            \"AccountBlocks\": null,\n            \"SnapshotBlock\": {\n                \"producer\": \"vite_c1d11e6eda9a9b80e388a38e0ac541cbc3333736233b4eaaab\",\n                \"hash\": \"ca09e12f7a14bce2d22cfe87f557536fd3a4d77d1b3e84e6a46dd0820d9d3c58\",\n                \"height\": 100,\n                \"publicKey\": \"h3B0rM7qM8ZZzfLwFxfmrEFlO8J4X7dP8j+TDxfEgyc=\",\n                \"signature\": \"9INk9B3b3ZF3iOCU9mY2RYy0kEpGMSxx/ohiDwPqz9MLOA7R7C4Lo5ioROXV5DdhRhaEm+xca2RApmoM9vfrAA==\",\n                \"seed\": 0,\n                \"version\": 0,\n                \"previousHash\": \"75e9e5212729d9df18a402166b7125a5b0557bd3485d21d61ec146f07309a539\",\n                \"nextSeedHash\": null,\n                \"snapshotData\": null,\n                \"timestamp\": 1558458875\n            }\n        },\n        {\n            \"AccountBlocks\": [\n                {\n                    \"blockType\": 2,\n                    \"hash\": \"603e64f972960cd886a1dc77308b9a7d127cb462567b1ecd2ef68b4330a6d0c0\",\n                    \"prevHash\": \"592a1e46ad746fd7d0b12b6e51ad62ffaea42574e494f8ffeab611f11021efc0\",\n                    \"height\": 4,\n                    \"accountAddress\": \"vite_483eed4ba0b5cd984d480ca048d5ee8ef5fa6b0ae23774c09b\",\n                    \"publicKey\": \"oDxoxc75R4NnzWb4Vj3P9kmSercIquNzZlPlDnhRN2M=\",\n                    \"toAddress\": \"vite_0000000000000000000000000000000000000003f6af7459b9\",\n                    \"amount\": 1000000000000000000000,\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"fromBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"data\": \"jefc/QAAAAAAAAAAAAAA14lDHx2CBQbIP9U5oK6YY9aWE4IB\",\n                    \"quota\": 82000,\n                    \"fee\": 0,\n                    \"logHash\": null,\n                    \"difficulty\": null,\n                    \"nonce\": null,\n                    \"sendBlockList\": [],\n                    \"signature\": \"hWfLf7vXqIevTPdu6acc0PVVyNYxGtN9OU73F7Vn8+ZJ5vN6Lo76q1yalt5+OdqDRA4IzlQ8ruTNgvuwT0ooCw==\"\n                },\n                {\n                    \"blockType\": 2,\n                    \"hash\": \"76840a3fd02e42d3d141d740c68739f5bec13a9acbc5d78e64777e6965df382c\",\n                    \"prevHash\": \"c28bdd238e71dec3c86110d95f5a4d091ea8573242535d75e212aa1613ce2fc9\",\n                    \"height\": 21,\n                    \"accountAddress\": \"vite_a78e37a7212980a20c9d9e0c59463f1cb10f344555510a70ff\",\n                    \"publicKey\": \"HDfU0xOGFVuvdvluB498hPgB8vMbK/ONUQyE3qGb82E=\",\n                    \"toAddress\": \"vite_a9226a1f7bd6d97950f694c2de815573326528bfe0680495f3\",\n                    \"amount\": 0,\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"fromBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                    \"data\": null,\n                    \"quota\": 0,\n                    \"fee\": 0,\n                    \"logHash\": null,\n                    \"difficulty\": 67108863,\n                    \"nonce\": \"Vn6bHNt5P34=\",\n                    \"sendBlockList\": [],\n                    \"signature\": \"p+Bb5JjLFT8NyZ3grmHZN42n5iZ5Erru8e8l/++UPX60QmG+JbLT946ZNf9tSJxKQhq6J85GmCjnmm+PGHZRBg==\"\n                },\n                {\n                    \"blockType\": 4,\n                    \"hash\": \"3a92628fdff90bf3b597f7f293f77ed8f722753e6f904475fe2c47f772569ad5\",\n                    \"prevHash\": \"3fe8600baef2c93b3ac4744c775f4abb956bd5e70cea749bc653501582febdb1\",\n                    \"height\": 2,\n                    \"accountAddress\": \"vite_a9226a1f7bd6d97950f694c2de815573326528bfe0680495f3\",\n                    \"publicKey\": \"h8odG95Y8cUuxzTO7Z5UTssVIYxyBi7vEAT5SGdPjCs=\",\n                    \"toAddress\": \"vite_0000000000000000000000000000000000000000a4f3a0cb58\",\n                    \"amount\": null,\n                    \"tokenId\": \"tti_000000000000000000004cfd\",\n                    \"fromBlockHash\": \"76840a3fd02e42d3d141d740c68739f5bec13a9acbc5d78e64777e6965df382c\",\n                    \"data\": null,\n                    \"quota\": 0,\n                    \"fee\": 0,\n                    \"logHash\": null,\n                    \"difficulty\": 67108863,\n                    \"nonce\": \"smmvZ4YAbt0=\",\n                    \"sendBlockList\": [],\n                    \"signature\": \"JeI89sAgiuuPKRwDrrtRU+A7zMyNMp82rzfxllB/+r3sGm8rhs0qu6sxMY9a3qtIjo7N0A/rlldJYFTi9ImEDg==\"\n                }\n            ],\n            \"SnapshotBlock\": {\n                \"producer\": \"vite_995769283a01ba8d00258dbb5371c915df59c8657335bfb1b2\",\n                \"hash\": \"a5ff0bfb140599d4509ec33b122ff0902b4f528d78b6d95c6805789f4480bba5\",\n                \"height\": 101,\n                \"publicKey\": \"OIlqJYQZ4AEMjdU1qjQDFOeSph5Alnk4tkYE78I+Cg4=\",\n                \"signature\": \"F9uB7hr+rgBFLEzjM7Y1DWhXTfn5NueHRwQiojwRraGJ14/OARMSVZME6/v+59P/fcuV5Id2Y/AAUdXGLZQ6BQ==\",\n                \"seed\": 16825645928731316356,\n                \"version\": 0,\n                \"previousHash\": \"ca09e12f7a14bce2d22cfe87f557536fd3a4d77d1b3e84e6a46dd0820d9d3c58\",\n                \"nextSeedHash\": \"5196cce99462b1b80c988b3a787077897d5a517822095db8ce8e98f5f6fe1f90\",\n                \"snapshotData\": {\n                    \"vite_483eed4ba0b5cd984d480ca048d5ee8ef5fa6b0ae23774c09b\": {\n                        \"height\": 4,\n                        \"hash\": \"603e64f972960cd886a1dc77308b9a7d127cb462567b1ecd2ef68b4330a6d0c0\"\n                    },\n                    \"vite_a78e37a7212980a20c9d9e0c59463f1cb10f344555510a70ff\": {\n                        \"height\": 21,\n                        \"hash\": \"76840a3fd02e42d3d141d740c68739f5bec13a9acbc5d78e64777e6965df382c\"\n                    },\n                    \"vite_a9226a1f7bd6d97950f694c2de815573326528bfe0680495f3\": {\n                        \"height\": 2,\n                        \"hash\": \"3a92628fdff90bf3b597f7f293f77ed8f722753e6f904475fe2c47f772569ad5\"\n                    }\n                },\n                \"timestamp\": 1558458924\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getaccountinfobyaddress","title":"<code>ledger_getAccountInfoByAddress</code>","text":"<p>Get account information by address.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>address</code>: <code>address</code> The account address.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>AccountInfo</code></li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_getAccountInfoByAddress\",\n    \"params\": [\n        \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": {\n        \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        \"blockCount\": \"21846\",\n        \"balanceInfoMap\": {\n            \"tti_5649544520544f4b454e6e40\": {\n                \"tokenInfo\": {\n                    \"tokenName\": \"VITE\",\n                    \"tokenSymbol\": \"VITE\",\n                    \"totalSupply\": \"1001699224353751966255398604\",\n                    \"decimals\": 18,\n                    \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                    \"ownerBurnOnly\": false,\n                    \"isReIssuable\": true,\n                    \"index\": 0,\n                    \"isOwnerBurnOnly\": false\n                },\n                \"balance\": \"0\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getlatestsnapshothash","title":"<code>ledger_getLatestSnapshotHash</code>","text":"<p>Get the current snapshot block hash.</p> <ul> <li> <p>Parameters: none</p> </li> <li> <p>Returns:</p> <ul> <li><code>hash</code> The hash of the current snapshot block.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_getLatestSnapshotHash\",\n    \"params\": null\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": \"d580deefe3ce5ec9340d163543f93130f2e40ccd4546da8246baba6d0dc25d1f\"\n}\n</code></pre>"},{"location":"api/ledger/#ledger_sendrawtransaction","title":"<code>ledger_sendRawTransaction</code>","text":"<p>Send a raw transaction.</p> <ul> <li>Parameters:<ul> <li><code>block</code>: <code>AccountBlock</code> The account block to send.</li> </ul> </li> </ul> Field Type Description <code>blockType</code> Mandatory See <code>AccountBlock</code> <code>height</code> Mandatory See <code>AccountBlock</code> <code>hash</code> Mandatory See <code>AccountBlock</code> <code>previousHash</code> Mandatory See <code>AccountBlock</code> <code>address</code> Mandatory See <code>AccountBlock</code> <code>publicKey</code> Mandatory See <code>AccountBlock</code> <code>signature</code> Mandatory See <code>AccountBlock</code> <code>difficulty</code> Mandatory for using PoW See <code>AccountBlock</code> <code>nonce</code> Mandatory for using PoW See <code>AccountBlock</code> <code>sendBlockHash</code> Mandatory for response See <code>AccountBlock</code> <code>toAddress</code> Mandatory for request See <code>AccountBlock</code> <code>tokenId</code> Mandatory for request See <code>AccountBlock</code> <code>amount</code> Mandatory for request See <code>AccountBlock</code> <code>fee</code> Mandatory for request Use \"10000000000000000000\" (10 VITE) for deploying a contract. For other cases, use \"0\" <code>data</code> Optional A base64 encoding string used as comment/memo or encoded function call/result of a smart contract <ul> <li>Returns: none</li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_sendRawTransaction\",\n    \"params\": [{\n        \"blockType\": 2,\n        \"height\": \"2\",\n        \"hash\": \"67f4d528a5194c46d594221d3d992257a3004ccdee7c5d7b2748d77e06a80caf\",\n        \"previousHash\": \"d517e8d4dc9c676876b72ad0cbb4c45890804aa438edd1f171ffc66276202a95\",\n        \"address\": \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\",\n        \"publicKey\": \"WHZinxslscE+WaIqrUjGu2scOvorgD4Q+DQOOcDBv4M=\",\n        \"toAddress\": \"vite_0000000000000000000000000000000000000003f6af7459b9\",\n        \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n        \"amount\": \"1000000000000000000000000\",\n        \"fee\": \"0\",\n        \"data\": \"jefc/QAAAAAAAAAAAAAAqyTvaLhOZCwN3KBr7sgcmssZd7sA\",\n        \"signature\": \"F5VzYwsNSr6ex2sl9hDaX67kP9g4TewMWcw7Tp57VkE1LQZO0i1toYEsXJ3MgcZdsvP67EymXXn1wpwhxnS3CQ==\"\n    }]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": null\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getunreceivedblocksbyaddress","title":"<code>ledger_getUnreceivedBlocksByAddress</code>","text":"<p>Fetch a number of unreceived blocks by address.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>address</code>: <code>address</code> The account address.</li> <li><code>pageIndex</code>: <code>uint64</code> The page index, starting from 0.</li> <li><code>pageSize</code>: <code>uint64</code> The page size. Maximum 1000.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>List&lt;AccountBlock&gt;</code> See AccountBlock for details.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"ledger_getUnreceivedBlocksByAddress\",\n    \"params\": [\n        \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        0, \n        1\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"result\": [\n        {\n            \"blockType\": 2,\n            \"height\": \"556\",\n            \"hash\": \"12ec1d40a6c7560ba77b3764977c609189299dcf63d6586b50374714d0b8e013\",\n            \"previousHash\": \"9a6c20d7d7fc927d89de6d9991a7904330007751f9d7d24dec141cbdb8b9e5ef\",\n            \"address\": \"vite_f74d18fc6431cb9d813c62a47a9063c4b9488219dc22c2736d\",\n            \"publicKey\": \"yNr85NJpkjKoaobFuWwIcoIdQR+ZRPrG5myrBhGxG5Q=\",\n            \"producer\": \"vite_f74d18fc6431cb9d813c62a47a9063c4b9488219dc22c2736d\",\n            \"fromAddress\": \"vite_f74d18fc6431cb9d813c62a47a9063c4b9488219dc22c2736d\",\n            \"toAddress\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"amount\": \"16000000000000000000\",\n            \"fee\": \"0\",\n            \"data\": \"9HgjCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABvBbWdOyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG8FtZ07IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbwW1nTsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABvBbWdOyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG8FtZ07IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbwW1nTsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABvBbWdOyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG8FtZ07IAAA=\",\n            \"difficulty\": \"124419654\",\n            \"nonce\": \"QxyYTRkNbco=\",\n            \"signature\": \"sgcYMzD3L0KsEOeA9DckCPcOHeC7tTjiJdEcjS97guMKkOqHznnZ1naWkmDFJrtaNij1weRWMZ/27Y4rYc/DAw==\",\n            \"quotaByStake\": \"0\",\n            \"totalQuota\": \"38680\",\n            \"vmLogHash\": null,\n            \"triggeredSendBlockList\": null,\n            \"tokenInfo\": {\n                \"tokenName\": \"VITE\",\n                \"tokenSymbol\": \"VITE\",\n                \"totalSupply\": \"1001186579383872099206960787\",\n                \"decimals\": 18,\n                \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                \"ownerBurnOnly\": false,\n                \"isReIssuable\": true,\n                \"index\": 0,\n                \"isOwnerBurnOnly\": false\n            },\n            \"confirmations\": \"5345754\",\n            \"firstSnapshotHash\": \"ab88339a58d481a3b132f5c3c69ba14ab5b31d77b8860985b17951e990e190b4\",\n            \"receiveBlockHeight\": null,\n            \"receiveBlockHash\": null,\n            \"timestamp\": 1562219525\n        }\n    ]\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getunreceivedblocksinbatch","title":"<code>ledger_getUnreceivedBlocksInBatch</code>","text":"<p>Fetch unreceived blocks in batch.</p> <ul> <li> <p>Parameters: <code>Array&lt;PagingQueryBatch&gt;</code></p> <ul> <li><code>address</code>: <code>address</code> The account address.</li> <li><code>pageIndex</code>: <code>uint64</code> The page index, starting from 0.</li> <li><code>pageSize</code>: <code>uint64</code> The page size. Maximum 1000.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>map&lt;Address, List&lt;AccountBlock&gt;&gt;</code> See AccountBlock for details.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"ledger_getUnreceivedBlocksInBatch\",\n    \"params\": [\n        [\n            {\n                \"address\": \"vite_00000000000000000000000000000000000000042d7ef71894\",\n                \"pageNumber\": 0,\n                \"pageCount\": 1\n            },\n            {\n                \"address\": \"vite_68c5edf9069efe327e01e925790d868c7f7972d815016cf18a\",\n                \"pageNumber\": 0,\n                \"pageCount\": 1\n            }\n        ]\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"result\": {\n        \"vite_68c5edf9069efe327e01e925790d868c7f7972d815016cf18a\": [\n            {\n                \"blockType\": 2,\n                \"height\": \"170\",\n                \"hash\": \"81a9a5e2747e28584db752a814bde0ee8894604df3707a9067e13f8297a090d5\",\n                \"previousHash\": \"55e7088d3405aebed75c9e311303f52bbbc1827b11d86fd7840406e4f4bc42f8\",\n                \"address\": \"vite_ba2ae946be1f56a8c83ce3e1d80a53d8137c264684d5dd7610\",\n                \"publicKey\": \"u7OxKqv0EqysClekERWf8FK3NgsEVnS6dq0Cu53en4o=\",\n                \"producer\": \"vite_ba2ae946be1f56a8c83ce3e1d80a53d8137c264684d5dd7610\",\n                \"fromAddress\": \"vite_ba2ae946be1f56a8c83ce3e1d80a53d8137c264684d5dd7610\",\n                \"toAddress\": \"vite_68c5edf9069efe327e01e925790d868c7f7972d815016cf18a\",\n                \"sendBlockHash\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"amount\": \"0\",\n                \"fee\": \"0\",\n                \"data\": \"6SXjDQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbwW1nTsgAAA\",\n                \"difficulty\": null,\n                \"nonce\": null,\n                \"signature\": \"8qNYBI2+rQOH6LmS+Skl5/lXCLaW3bZHVGfS8IFraol5LiGuukmjfzsiNGQTDpB7MN006K9VcCGE05eZKeyVAg==\",\n                \"quotaByStake\": \"23448\",\n                \"totalQuota\": \"23448\",\n                \"vmLogHash\": null,\n                \"triggeredSendBlockList\": null,\n                \"tokenInfo\": {\n                    \"tokenName\": \"VITE\",\n                    \"tokenSymbol\": \"VITE\",\n                    \"totalSupply\": \"1001186579383872099206960787\",\n                    \"decimals\": 18,\n                    \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                    \"ownerBurnOnly\": false,\n                    \"isReIssuable\": true,\n                    \"index\": 0,\n                    \"isOwnerBurnOnly\": false\n                },\n                \"confirmations\": \"5257692\",\n                \"firstSnapshotHash\": \"9c9a436d1d8b06c8a9955955890877b40c5e493c4054f59d36a3bfabf315772f\",\n                \"receiveBlockHeight\": null,\n                \"receiveBlockHash\": null,\n                \"timestamp\": 1562309573\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getunreceivedtransactionsummarybyaddress","title":"<code>ledger_getUnreceivedTransactionSummaryByAddress</code>","text":"<p>Get unreceived transaction summary by address.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>address</code>: <code>address</code> The account address.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>AccountInfo</code></li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"ledger_getUnreceivedTransactionSummaryByAddress\",\n    \"params\": [\n        \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"result\": {\n        \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n        \"blockCount\": \"6\",\n        \"balanceInfoMap\": {\n            \"tti_5649544520544f4b454e6e40\": {\n                \"tokenInfo\": {\n                    \"tokenName\": \"VITE\",\n                    \"tokenSymbol\": \"VITE\",\n                    \"totalSupply\": \"1001186579383872099206960787\",\n                    \"decimals\": 18,\n                    \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                    \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                    \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                    \"ownerBurnOnly\": false,\n                    \"isReIssuable\": true,\n                    \"index\": 0,\n                    \"isOwnerBurnOnly\": false\n                },\n                \"balance\": \"96000000000000000000\",\n                \"transactionCount\": \"6\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getunreceivedtransactionsummaryinbatch","title":"<code>ledger_getUnreceivedTransactionSummaryInBatch</code>","text":"<p>Get unreceived transaction summary in batch.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>addressList</code>: <code>Array&lt;address&gt;</code> An array of account addresses.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>Array&lt;AccountInfo&gt;</code> See AccountInfo for details.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"ledger_getUnreceivedTransactionSummaryInBatch\",\n    \"params\": [\n        [\n            \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"vite_68c5edf9069efe327e01e925790d868c7f7972d815016cf18a\"\n        ]\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"result\": [\n        {\n            \"address\": \"vite_0b573f9d1fca7d830fc0d1552e3ff7b7f44455e38c8218fd10\",\n            \"blockCount\": \"6\",\n            \"balanceInfoMap\": {\n                \"tti_5649544520544f4b454e6e40\": {\n                    \"tokenInfo\": {\n                        \"tokenName\": \"VITE\",\n                        \"tokenSymbol\": \"VITE\",\n                        \"totalSupply\": \"1001186579383872099206960787\",\n                        \"decimals\": 18,\n                        \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                        \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                        \"ownerBurnOnly\": false,\n                        \"isReIssuable\": true,\n                        \"index\": 0,\n                        \"isOwnerBurnOnly\": false\n                    },\n                    \"balance\": \"96000000000000000000\",\n                    \"transactionCount\": \"6\"\n                }\n            }\n        },\n        {\n            \"address\": \"vite_68c5edf9069efe327e01e925790d868c7f7972d815016cf18a\",\n            \"blockCount\": \"1\",\n            \"balanceInfoMap\": {\n                \"tti_5649544520544f4b454e6e40\": {\n                    \"tokenInfo\": {\n                        \"tokenName\": \"VITE\",\n                        \"tokenSymbol\": \"VITE\",\n                        \"totalSupply\": \"1001186579383872099206960787\",\n                        \"decimals\": 18,\n                        \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                        \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                        \"ownerBurnOnly\": false,\n                        \"isReIssuable\": true,\n                        \"index\": 0,\n                        \"isOwnerBurnOnly\": false\n                    },\n                    \"balance\": \"0\",\n                    \"transactionCount\": \"1\"\n                }\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getvmlogs","title":"<code>ledger_getVmLogs</code>","text":"<p>Get event logs by account block hash.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>blockHash</code>: <code>hash</code> The hash of the account block.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>Array&lt;VmLog&gt;</code> See VmLog for details.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_getVmLogs\",\n    \"params\": [\n        \"5a78365f4f7e9c29d57c8f087c9691bfff63a4889cde5d03a89cb24d34abbdf3\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": [\n        {\n            \"topics\": [\n                \"00d73e74672366b05e8980c144e4c523f171cee9fcae60041d97ae1f540a4de5\",\n                \"0000000000000000000000f74d18fc6431cb9d813c62a47a9063c4b948821900\"\n            ],\n            \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABoFVpDZ24AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\"\n        }\n    ]\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getvmloglistbyhash","title":"<code>ledger_getVmLogListByHash</code>","text":"<p>Get event logs by log hash.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>logHash</code>: <code>hash</code> The log hash.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>Array&lt;VmLog&gt;</code> See VmLog for details.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"ledger_getVmLogListByHash\",\n    \"params\": [\n        \"56d05270b0d62a8dac3a01908177ed6e47899eced76bc9fa7716e808d6068705\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": [\n        {\n            \"topics\": [\n                \"00d73e74672366b05e8980c144e4c523f171cee9fcae60041d97ae1f540a4de5\",\n                \"0000000000000000000000f74d18fc6431cb9d813c62a47a9063c4b948821900\"\n            ],\n            \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABoFVpDZ24AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\"\n        }\n    ]\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getvmlogsbyfilter","title":"<code>ledger_getVmLogsByFilter</code>","text":"<p>Get event logs by account address, account block height range, and topics.</p> <ul> <li> <p>Parameters: <code>FilterParam</code></p> <ul> <li><code>addressHeightRange</code>: <code>map[address]Range</code> A map of contract address and height range. At least one address must be specified.<ul> <li><code>fromHeight</code>: <code>uint64 string</code> The start height. <code>0</code> means starting from the latest account block.</li> <li><code>toHeight</code>: <code>uint64 string</code> The end height. <code>0</code> means fetching till the latest account block (no ending height).</li> </ul> </li> <li><code>topics</code>: <code>&lt;Array&lt;Array&lt;hash&gt;&gt;</code> Event topics, optional. See here for details.</li> <li><code>pageIndex</code>: <code>uint64</code> The page index.</li> <li><code>pageSize</code>: <code>uint64</code> The page size. Maximum 1000.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>Array&lt;Logs&gt;</code> See Logs for details.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ledger_getVmLogsByFilter\",\n    \"params\": [\n        {\n            \"addressHeightRange\": {\n                \"vite_79ac3daebdfed6947c0aaeacd418eadf38a94dddefbd4acec1\": {\n                    \"fromHeight\": \"1\",\n                    \"toHeight\": \"0\"\n                }\n            },\n            \"topics\": [\n                [\n                    \"360bba44e4490fae37d6444482aa67cf5ec7418850531522450c3805b8e5425c\",\n                    \"1d8e14596183a6d73bc8760a43cdaf6992e6cb318cecec67f4b6bcb31fe039d5\"\n                ],\n                [\n                    \"91ac0b2bf8c6dc8d37d0bc48a0eacaf6a7ed5bec9be59086116c6f23eca8aaf0\",\n                    \"3adaf70d6a60eba6aaa6a1884c382ae32b223557ccaa2f3fcab6aec6c2fca21f\"\n                ]\n            ]\n        }\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            \"vmlog\": {\n                \"topics\": [\n                    \"1d8e14596183a6d73bc8760a43cdaf6992e6cb318cecec67f4b6bcb31fe039d5\",\n                    \"91ac0b2bf8c6dc8d37d0bc48a0eacaf6a7ed5bec9be59086116c6f23eca8aaf0\"\n                ],\n                \"data\": null\n            },\n            \"accountBlockHash\": \"24d9700990ce9a503736b0a0504bbabf6e36c0228ef73c06344089a630971f02\",\n            \"accountBlockHeight\": \"1\",\n            \"address\": \"vite_79ac3daebdfed6947c0aaeacd418eadf38a94dddefbd4acec1\"\n        },\n        {\n            \"vmlog\": {\n                \"topics\": [\n                    \"360bba44e4490fae37d6444482aa67cf5ec7418850531522450c3805b8e5425c\",\n                    \"3adaf70d6a60eba6aaa6a1884c382ae32b223557ccaa2f3fcab6aec6c2fca21f\"\n                ],\n                \"data\": null\n            },\n            \"accountBlockHash\": \"24d9700990ce9a503736b0a0504bbabf6e36c0228ef73c06344089a630971f02\",\n            \"accountBlockHeight\": \"1\",\n            \"address\": \"vite_79ac3daebdfed6947c0aaeacd418eadf38a94dddefbd4acec1\"\n        }\n    ]\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getpowdifficulty","title":"<code>ledger_getPoWDifficulty</code>","text":"<p>Get PoW difficulty for sending the transaction.</p> <p>Note: This method will calculate the required amount of quota according to transaction parameters and check whether the account has enough quota. If not, it returns the difficulty for the transaction; otherwise, it returns an empty string.</p> <p>Warning</p> <p>Can NOT use PoW twice in one snapshot block!</p> <p>If the method returns with an error, it is usually because the transaction data is too long, or the transaction cannot obtain quota through PoW.  For example, if PoW was once used for a previous transaction, the account is not allowed to use PoW twice within the same snapshot block.</p> <ul> <li> <p>Parameters: <code>GetPoWDifficultyParams</code></p> <ul> <li><code>address</code>: <code>address</code> The address of the account.</li> <li><code>previousHash</code>: <code>hash</code> The hash of the previous account block.</li> <li><code>blockType</code>: <code>byte</code> The block type.</li> <li><code>toAddress</code>: <code>address</code> The address of the recipient, required for request transactions.</li> <li><code>data</code>: <code>base64</code> Additional block data.</li> </ul> </li> <li> <p>Returns: <code>GetPoWDifficultyResult</code></p> <ul> <li><code>requiredQuota</code>: <code>uint64 string</code> The raw quota required for sending the transaction.</li> <li><code>difficulty</code>: <code>bigint string</code> The PoW difficulty. Returns an empty string if sending the transaction does not need PoW.</li> <li><code>qc</code>: <code>bigint string</code> The congestion factor, in 18 decimals.</li> <li><code>isCongestion</code>: <code>bool</code> <code>true</code> means sending the transaction will consume more quota.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ledger_getPoWDifficulty\",\n    \"params\": [\n        {\n            \"address\": \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\",\n            \"previousHash\": \"7b5dcb470889997100e0e09cd292d221ad1c11bb0daf8b9fa39a2d1f90210aa0\",\n            \"blockType\": 2,\n            \"toAddress\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n            \"data\": \"8pxs4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAICy1ooG9SwPu0VPZ17lQ1+3hyUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFc3VwZXIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n        }\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"requiredQuota\": 32152,\n        \"difficulty\": \"102920708\",\n        \"qc\": \"1000000000000000000\",\n        \"isCongestion\": false\n    }\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getrequiredquota","title":"<code>ledger_getRequiredQuota</code>","text":"<p>Calculate the quota required for sending the transaction.</p> <ul> <li> <p>Parameters: <code>GetPoWDifficultyParams</code></p> <ul> <li><code>address</code>: <code>address</code> The address of the account.</li> <li><code>previousHash</code>: <code>hash</code> The hash of the previous account block.</li> <li><code>blockType</code>: <code>byte</code> The block type.</li> <li><code>toAddress</code>: <code>address</code> The address of the recipient, required for request transactions.</li> <li><code>data</code>: <code>base64</code> Additional block data.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>requiredQuota</code>: <code>uint64 string</code> The raw quota required for sending the transaction.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"ledger_getPoWDifficulty\",\n    \"params\": [\n        {\n            \"address\": \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\",\n            \"previousHash\": \"7b5dcb470889997100e0e09cd292d221ad1c11bb0daf8b9fa39a2d1f90210aa0\",\n            \"blockType\": 2,\n            \"toAddress\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n            \"data\": \"8pxs4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAAAAAAAAAAAAAICy1ooG9SwPu0VPZ17lQ1+3hyUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFc3VwZXIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\",\n        }\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"requiredQuota\": \"168000\"\n    }\n}\n</code></pre>"},{"location":"api/ledger/#ledger_getseed","title":"<code>ledger_getSeed</code>","text":"<p>Get a random seed in the snapshot block according to the seed hash.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>snapshotHash</code>: <code>hash</code> The snapshot block hash.</li> <li><code>seedHash</code>: <code>hash</code> The seed hash.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>uint64</code> The random seed contained in the snapshot block.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"ledger_getSeed\",\n    \"params\": [\n        \"c072c35dcf8a677f0e12c595c8e947b1635b5990ae95433bb693675d4a6ca2e0\",\n        \"8d9f30cdc6cd3f36faf473337c66049035345b0f2c27a8689796db3ce15b00bf\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": 10204928941006602038\n}\n</code></pre>"},{"location":"api/net/","title":"Net API","text":"<p>Tip</p> <p>To enable the Net RPC API on a node, add <code>\"net\"</code> to the <code>PublicModules</code> section in <code>node_config.json</code>.</p> <p>Definitions: * Node ID: A 32-byte Ed25519 public key derived from the 64-byte private key stored in <code>~/.gvite/maindata/net/peerKey</code> or specified as <code>PeerKey</code> in <code>node_config.json</code>. * Node Name: A human-readable name specified as <code>Identity</code> in <code>node_config.json</code>. * Node Address: The IP address and port of the node. * Network ID: Configured as <code>NetID</code> in <code>node_config.json</code>. <code>1</code> represents the mainnet. * Block Propagation Delay: The time difference, in milliseconds, between the broadcast of a snapshot block and its timestamp. * Reliable Node: A node is considered reliable if its height does not exceed the maximum height in the <code>WhiteBlockList</code> by more than 86400 and all snapshot blocks in the list are validated by the node. If <code>BlackBlockHashList</code> is configured and a node provides a block in the blacklist, it is deemed unreliable. By default, all nodes are considered reliable. * Sync Start Height: The starting height of the current sync cycle, calculated as the node's current height rounded down to the nearest 100 plus 1. If the snapshot block at this height cannot be retrieved, the synchronizer will attempt up to 100 blocks backward or start from the node's irreversible height. For new nodes, this value is <code>0</code>. * Sync End Height: The ending height of the current sync cycle, determined as the median height of all connected nodes. For new nodes, this value is <code>0</code>. * Irreversible Height: The height at which more than two-thirds of SBPs have produced blocks in a round. This height is considered irreversible. * Block Segment: A continuous range of snapshot blocks represented by a start and end block.</p> <p>Note</p> <p>For fully synced nodes (state = 2), the sync start and end heights remain unchanged.</p>"},{"location":"api/net/#net_syncinfo","title":"<code>net_syncInfo</code>","text":"<p>Retrieve the sync status of the node.</p> <ul> <li> <p>Parameters: None</p> </li> <li> <p>Returns: <code>SyncInfo</code></p> <ul> <li><code>from</code>: <code>string</code> The sync start height.</li> <li><code>to</code>: <code>string</code> The sync end height.</li> <li><code>current</code>: <code>string</code> The current height of the node.</li> <li><code>state</code>: <code>uint</code> The sync state: 0 - Not started, 1 - Syncing, 2 - Completed, 3 - Error, 4 - Canceled.</li> <li><code>status</code>: <code>string</code> A description of the sync state.</li> </ul> </li> <li> <p>Example:</p> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"net_syncInfo\",\n    \"params\": null\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"result\": {\n        \"from\": \"100917901\",\n        \"to\": \"100918103\",\n        \"current\": \"100917954\",\n        \"state\": 1,\n        \"status\": \"Syncing\"\n    }\n}\n</code></pre>"},{"location":"api/net/#net_syncdetail","title":"<code>net_syncDetail</code>","text":"<p>Retrieve the detailed sync status of the node.</p> <ul> <li> <p>Parameters: None</p> </li> <li> <p>Returns: <code>SyncDetail</code></p> <ul> <li><code>from</code>: <code>string</code> The sync start height.</li> <li><code>to</code>: <code>string</code> The sync end height.</li> <li><code>current</code>: <code>string</code> The current height of the node.</li> <li><code>state</code>: <code>string</code> The sync state. This field returns the same value as <code>status</code>.</li> <li><code>status</code>: <code>string</code> A description of the sync state.</li> <li><code>tasks</code>: <code>Array&lt;string&gt;</code> The current download tasks. Only nodes in the syncing state have download tasks.</li> <li><code>connections</code>: <code>Array&lt;SyncConnectionStatus&gt;</code><ul> <li><code>address</code>: <code>string</code> The address of the connected node, composed of the first 16 bytes of the node ID + \"@\" + the node's IP address and port.</li> <li><code>speed</code>: <code>string</code> The download speed from the node.</li> <li><code>task</code>: <code>string</code> The current download task.</li> </ul> </li> <li><code>chunks</code>: <code>Array&lt;SnapshotRange&gt;</code> Verified snapshot block segments waiting to be inserted into the local ledger.<ul> <li><code>height</code>: <code>uint64</code> The height of the snapshot block.</li> <li><code>hash</code>: <code>hash</code> The hash of the snapshot block.</li> </ul> </li> <li><code>caches</code>: <code>Array&lt;Segment&gt;</code> Unverified snapshot block segments stored in the cache.<ul> <li><code>From</code>: <code>uint64</code> The starting height of the snapshot block segment.</li> <li><code>To</code>: <code>uint64</code> The ending height of the snapshot block segment.</li> <li><code>Hash</code>: <code>hash</code> The hash of the block segment.</li> <li><code>PreHash</code>: <code>hash</code> The hash of the previous block segment.</li> <li><code>Points</code>: <code>Array&lt;HashHeight&gt;</code> The hash height points contained in the block segment.<ul> <li><code>height</code>: <code>uint64</code> The height of the snapshot block.</li> <li><code>hash</code>: <code>hash</code> The hash of the snapshot block.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Example:</p> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"net_syncDetail\",\n    \"params\": null\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"result\": {\n        \"from\": 692001,\n        \"to\": 727000,\n        \"current\": 692084,\n        \"state\": \"Syncing\",\n        \"status\": \"Syncing\",\n        \"tasks\": [\n            \"692001-693000 Completed\",\n            \"693001-694000 Pending\"\n        ],\n        \"connections\": [\n            {\n                \"address\": \"24a160122317e6e4940ef2a91242b07f@118.25.49.80:8484\",\n                \"speed\": \"0.00 Byte/s\",\n                \"task\": \"\"\n            },\n            {\n                \"address\": \"04508fbe0512c01a48c8a450425547de@118.24.112.185:8484\",\n                \"speed\": \"0.00 Byte/s\",\n                \"task\": \"\"\n            }\n        ],\n        \"chunks\": [\n            [\n                {\n                    \"height\": 692000,\n                    \"hash\": \"74add6f7f61c33dd741276d97d8ade4456c47485da78752587aef8a209fe7e88\"\n                },\n                {\n                    \"height\": 693000,\n                    \"hash\": \"b6af1c6fb3b502268b17928b1d91206e71003f614c134f8865bf6886d88d8e30\"\n                }\n            ]\n        ],\n        \"caches\": [\n            {\n                \"From\": 691001,\n                \"To\": 693000,\n                \"Hash\": \"b6af1c6fb3b502268b17928b1d91206e71003f614c134f8865bf6886d88d8e30\",\n                \"PrevHash\": \"028e2730c8fad34b53b8d8f5a41881024fa8b87a97a9cfc61f0e0c83984336a0\"\n            },\n            {\n                \"From\": 694001,\n                \"To\": 696000,\n                \"Hash\": \"e14662c3e9a9751b28822f2640be79cf13bd778c6b3158c8f6ff584fbf89fa24\",\n                \"PrevHash\": \"c6cd65717345f017309ee961a6bcda9ba021e0ed5913d8111471ff09fc95590c\"\n            },\n            {\n                \"From\": 698001,\n                \"To\": 699000,\n                \"Hash\": \"4e067e54b9e966b264053c271c7d976065b8a0796d6995b9dda45e11339e0b57\",\n                \"PrevHash\": \"26a6bdcfd3d9f58951eb76ebd4784160e98098564cc31e236618f045cb90f365\"\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"api/net/#net_nodeinfo","title":"<code>net_nodeInfo</code>","text":"<p>Retrieve detailed information about the node and its connected peers.</p> <ul> <li> <p>Parameters: None</p> </li> <li> <p>Returns: <code>NodeInfo</code></p> <ul> <li><code>id</code>: <code>string</code> The node ID.</li> <li><code>name</code>: <code>string</code> The node name.</li> <li><code>netId</code>: <code>int</code> The network ID.</li> <li><code>version</code>: <code>int</code> The node version. All nodes return <code>0</code>.</li> <li><code>address</code>: <code>string</code> The node address. Not implemented. Currently returns an empty string.</li> <li><code>peerCount</code>: <code>int</code> The number of connected peers.</li> <li><code>peers</code>: <code>Array&lt;PeerInfo&gt;</code> The connected peers.<ul> <li><code>id</code>: <code>string</code> The peer ID.</li> <li><code>name</code>: <code>string</code> The peer name.</li> <li><code>version</code>: <code>int</code> The peer version. All peers return <code>0</code>.</li> <li><code>height</code>: <code>int</code> The current height of the peer.</li> <li><code>address</code>: <code>string</code> The IP address and port of the peer.</li> <li><code>flag</code>: <code>byte</code> The connection type. <code>0</code> - Inbound, <code>1</code> - Outbound.</li> <li><code>superior</code>: <code>bool</code> <code>true</code> if the peer is an SBP.</li> <li><code>reliable</code>: <code>bool</code> <code>true</code> if the peer is reliable.</li> <li><code>createAt</code>: <code>string</code> The time the peer connected.</li> <li><code>readQueue</code>: <code>int</code> The current length of the peer's message read queue.</li> <li><code>writeQueue</code>: <code>int</code> The current length of the peer's message write queue.</li> <li><code>peers</code>: <code>Array&lt;string&gt;</code> The list of peer IDs currently connected to the peer.</li> </ul> </li> <li><code>height</code>: <code>uint64</code> The node height.</li> <li><code>nodes</code>: <code>int</code> The size of the node table. Not implemented. Currently returns <code>0</code>.</li> <li><code>latency</code>: <code>Array&lt;int&gt;</code> An array of four integers representing the current block broadcast delay, the average block broadcast delay over the past hour, the average block broadcast delay over the past 12 hours, and the average block broadcast delay over the past 24 hours, respectively. The unit is milliseconds.</li> <li><code>broadCheckFailedRatio</code>: <code>float32</code> The ratio of accounts that received more than 100 confirmations within 16 seconds.</li> <li><code>server</code>: <code>Array&lt;SyncConnectionStatus&gt;</code> Not implemented. Currently returns an empty array.</li> </ul> </li> <li> <p>Example:</p> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 3,\n    \"method\": \"net_nodeInfo\",\n    \"params\": null\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": {\n        \"id\": \"91590a7475ec17834eae6119afe750f11c4e103e2fb78d1986bdd86a8980de43\",\n        \"name\": \"ESP-FullNode.001\",\n        \"netId\": 1,\n        \"version\": 0,\n        \"address\": \"\",\n        \"peerCount\": 3,\n        \"peers\": [\n            {\n                \"id\": \"8d8b0b17411b85e943043759ddca4e641a8cc9f6ae47d4b3f767635358c42e76\",\n                \"name\": \"MIK33\",\n                \"version\": 0,\n                \"height\": 100933254,\n                \"address\": \"173.212.248.239:56996\",\n                \"flag\": 0,\n                \"superior\": false,\n                \"reliable\": true,\n                \"createAt\": \"2022-08-19 16:07:16\",\n                \"readQueue\": 0,\n                \"writeQueue\": 0,\n                \"peers\": [\n                    \"836c6ccf6582a9c8d2bc96aa7d2aed8e8e693e4050af0b4f01ad7375d9739aac\",\n                    \"918a47b9b0958412659723a3459c50e0197dc4239eafa57e540cacd2ab418f96\",\n                    \"8e1521741c92b2b9c502996d3c7424c6e500e52ed1c065ffa0378b2835a12dc1\",\n                    \"aa0e28a73212030ce62cf2c2090134ca90fb5e5a37e98513266551462e0dcf25\",\n                    \"bf14738360ff11517769b3a6f09fc41f81be77f8d8e4494cba9a7a5ddd845929\",\n                    \"9e41b1a3ff686074515db5fdf7de9515d04adc110b4ceefaa84409dfa5bc759e\",\n                    \"91590a7475ec17834eae6119afe750f11c4e103e2fb78d1986bdd86a8980de43\",\n                    \"e3245a342927df824aa72ec392a74ea5312f165700552057c9f40a9ff22f0589\",\n                    \"9a85aa364ae14c6b9c64180ce1fb97d0debd1b433f5aa734f42d73feeba52b6c\"\n                ]\n            },\n            {\n                \"id\": \"9402381bbdc2cbc3280e38dbcbb76cc293f802789e6c4fcb0f339f540ba47548\",\n                \"name\": \"concat0\",\n                \"version\": 0,\n                \"height\": 100933253,\n                \"address\": \"144.91.84.68:39782\",\n                \"flag\": 0,\n                \"superior\": false,\n                \"reliable\": true,\n                \"createAt\": \"2022-03-01 14:05:47\",\n                \"readQueue\": 0,\n                \"writeQueue\": 0,\n                \"peers\": [\n                    \"a5df8cab8c6996322553c360f490adca265bdbaccf964425f8137283d7f89272\",\n                    \"db9ec3aa4c8637c2dadb8f2898e84d91ab29795ae56b2b2b05dd5a8b39d977df\",\n                    \"9e067c62c8bf64322a039165eb2431a3b5c6405faf5dfe9133d147a6752eac08\",\n                    \"e2c87c9eb5966f1d7de679bc9d72abdd19557c6ca235b85de38565a4e7cca7e7\",\n                    \"a15e0067d90ff678052ebe55fbbf89468b1d80e8ffc1b76cd0d6e0285117f70d\",\n                    \"9c560323d72b643742f120f498791cc7a0d107e55e632d3dc8244f3feba95833\",\n                    \"89d433317c349235a429966a47b17039708429b3ab06283e6ad43af1312e0ab9\",\n                    \"91590a7475ec17834eae6119afe750f11c4e103e2fb78d1986bdd86a8980de43\",\n                    \"d13da3047b319c7da19f96200473a8cd08e43641081d37a93691ff38c13587e2\",\n                    \"9ffb393ba09f56db9aea74300562360911b64fddfdc463b262dbc37ecad6fb86\"\n                ]\n            },\n            {\n                \"id\": \"9508ce5c35989d6df24757f5c14cfe775449fe03fae69da4a96e001aacd4a426\",\n                \"name\": \"nimu\",\n                \"version\": 0,\n                \"height\": 100933253,\n                \"address\": \"207.180.250.64:51858\",\n                \"flag\": 0,\n                \"superior\": false,\n                \"reliable\": true,\n                \"createAt\": \"2022-08-19 06:46:23\",\n                \"readQueue\": 0,\n                \"writeQueue\": 0,\n                \"peers\": [\n                    \"91590a7475ec17834eae6119afe750f11c4e103e2fb78d1986bdd86a8980de43\",\n                    \"8e20a38270d2e19c186d37f113f075bf6cd6b6949ffa9790b4c0281e215de1b2\",\n                    \"99f746721c7aeacfb3587859e0cdfae1049b7b0875400e58c7d476fefa7155c8\",\n                    \"9dc1ba02d3592de3f1506a09c4c416b7e6cb4ffae5fc8654432b3efcedf799f7\",\n                    \"08e69aca38eb71c155234a93a32a7a642f4bb2efebd9837227dcf57892ff1d26\",\n                    \"0f6c334025afa0db6583f1d86b314ed0778031b9e42a5f6bf834ef4e102feb70\",\n                    \"96feeb78b2bcd4fd55bc47b4fb49f039e12e3a68a7acac78b909dbace39f0954\",\n                    \"97266099862560c6cde73e767add04e391e37fc86fe52fdd9372b01ac9e4af38\",\n                    \"805dcb1cdc2514b4fdecfd9cbfd2291e2bfb17a75fcad46153703db08fdbd341\",\n                    \"97275bef2b7dcaf023c75fa5b8fea4fb9550d6b74b7a18faa9b4e12caf33df49\"\n                ]\n            }\n        ],\n        \"height\": 100933262,\n        \"nodes\": 0,\n        \"latency\": [\n            23,\n            77,\n            74,\n            72\n        ],\n        \"broadCheckFailedRatio\": 0.027027028,\n        \"server\": {\n            \"connections\": []\n        }\n    }\n}\n</code></pre>"},{"location":"api/net/#net_nodes","title":"<code>net_nodes</code>","text":"<p>Retrieve all live nodes in the node table.</p> <p>Note: Live nodes are not necessarily connected nodes. Live nodes are those stored in the node table and reachable via ping.</p> <ul> <li> <p>Parameters: None</p> </li> <li> <p>Returns:</p> <ul> <li><code>Count</code>: <code>int</code> The number of live nodes.</li> <li><code>Nodes</code>: <code>Array&lt;Node&gt;</code><ul> <li><code>id</code>: <code>string</code> The node ID.</li> <li><code>address</code>: <code>string</code> The IP address and port of the node.</li> <li><code>net</code>: <code>int</code> The network ID.</li> <li><code>ext</code>: <code>Array&lt;byte&gt;</code> Additional information. Defaults to null.</li> </ul> </li> </ul> </li> <li> <p>Example:</p> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"net_nodes\",\n    \"params\": null\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": {\n        \"Count\": 13,\n        \"Nodes\": [\n            {\n                \"id\": \"95d52a0b506cd29a8153b4777a9c1d3852a15ae604daeb3376260201661c0259\",\n                \"address\": \"173.249.53.109:8483\",\n                \"net\": 1,\n                \"ext\": null\n            },\n            {\n                \"id\": \"c537033862e4a4178260536bfebfc5898d94dcde0a2c7c894df341c6871974dd\",\n                \"address\": \"144.91.86.89:8483\",\n                \"net\": 1,\n                \"ext\": null\n            },\n            {\n                \"id\": \"e9dcad1603c29de4fb636707d60c76c9f1ff28eb4040d5602576aab78c94db69\",\n                \"address\": \"161.35.129.182:8483\",\n                \"net\": 1,\n                \"ext\": \"3MLy0o+z4lmDN4NrF8yK65PFtM9A683ElMU7Y55bXY2w4oNw9O3aGQQ5r+8Bf8E91lFATMrT1DrD4spEmHgRs/GoSCdKX16t8d3TU9oBVgrQW2Hk6QQ4gh2dHBLzb9QC\"\n            },\n            {\n                \"id\": \"f738db16fb0b8b15efff3e367c05d49d3993b67b2cd3b8ddd96a6b01cf6a7af7\",\n                \"address\": \"163.47.117.157:8483\",\n                \"net\": 1,\n                \"ext\": null\n            },\n            {\n                \"id\": \"8ff65551f0dbe604f8cf9c18322cd85ddf5bfc0362e1df3e426d3032fd843b94\",\n                \"address\": \"173.249.45.46:8483\",\n                \"net\": 1,\n                \"ext\": null\n            },\n            {\n                \"id\": \"874c9e4f5b34d0c26b7e6ad27bec231948c11157f1dc2977dffed88361280d31\",\n                \"address\": \"95.216.50.183:8483\",\n                \"net\": 1,\n                \"ext\": null\n            },\n            {\n                \"id\": \"9fb855389ddb6fb9b3a3e6ec4f3121e2216354a12203581105889323518ba812\",\n                \"address\": \"161.97.153.45:8483\",\n                \"net\": 1,\n                \"ext\": null\n            },\n            {\n                \"id\": \"993d43801d63433657cb35d4f5c75bdd92a62f646e19ef961a193a558c4ab007\",\n                \"address\": \"173.249.5.87:8483\",\n                \"net\": 1,\n                \"ext\": null\n            },\n            {\n                \"id\": \"9c724d1179c5b6e09733651ff83a61227320bee604d6cd220d67799556b8f19f\",\n                \"address\": \"5.189.150.247:8483\",\n                \"net\": 1,\n                \"ext\": null\n            },\n            {\n                \"id\": \"9d1bfbbdd92e8c520703a4f76da9ce8cc5954dc584eb21663606cfbc78d381bd\",\n                \"address\": \"3.143.25.47:8483\",\n                \"net\": 1,\n                \"ext\": null\n            },\n            {\n                \"id\": \"9e067c62c8bf64322a039165eb2431a3b5c6405faf5dfe9133d147a6752eac08\",\n                \"address\": \"161.97.118.202:8483\",\n                \"net\": 1,\n                \"ext\": null\n            },\n            {\n                \"id\": \"9d0f2f7545c0f997cc752d72c2a1f37bb294bd9293e2ff489c4a31fe646cfaff\",\n                \"address\": \"62.171.182.175:8483\",\n                \"net\": 1,\n                \"ext\": null\n            },\n            {\n                \"id\": \"99c52026f5469c95c85796c4495c5e804ec57fbfc306f09a512d83fdfdb9ab93\",\n                \"address\": \"135.181.51.68:8483\",\n                \"net\": 1,\n                \"ext\": null\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"api/net/#net_peercount","title":"<code>net_peerCount</code>","text":"<p>Retrieve the number of connected peers.</p> <ul> <li> <p>Parameters: None</p> </li> <li> <p>Returns:</p> <ul> <li><code>int</code> The number of connected peers.</li> </ul> </li> <li> <p>Example:</p> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"net_peerCount\",\n    \"params\": null\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": 8\n}\n</code></pre>"},{"location":"api/subscribe/","title":"Subscription API","text":"<p>Vite nodes provide two types of subscription RPC APIs: Polling API and WebSocket API.</p> <ul> <li>Polling API returns a subscription filter. The client must periodically call <code>subscribe_getChangesByFilterId</code> with the filter ID to fetch new events. If no new events have occurred since the last request, the server returns <code>null</code>.</li> </ul> <p>Note: Filters expire if unused for more than 5 minutes. If the client does not send a request within this time, the subscription will close, and the client must re-subscribe.</p> <p>Polling APIs include: - <code>subscribe_newSnapshotBlockFilter</code> - <code>subscribe_newAccountBlockFilter</code> - <code>subscribe_newAccountBlockByAddressFilter</code> - <code>subscribe_newUnreceivedBlockByAddressFilter</code> - <code>subscribe_newVmLogFilter</code> - <code>subscribe_uninstallFilter</code> - <code>subscribe_getChangesByFilterId</code></p> <ul> <li>WebSocket API subscribes to new events via a WebSocket connection. When a new event occurs, it is automatically pushed to the client through callbacks. The subscription ends if the connection is broken.</li> </ul> <p>Note</p> <p>WebSocket APIs require \"ws\" or \"wss\" RPC endpoints and cannot be used with HTTP.</p> <p>The WebSocket API <code>subscribe_subscribe</code> supports the following events: - <code>newSnapshotBlock</code> - <code>newAccountBlock</code> - <code>newAccountBlockByAddress</code> - <code>newUnreceivedBlockByAddress</code> - <code>newVmLog</code></p> <p>Note: Events may be reverted. If an event is reverted, the <code>removed</code> field of the event is set to <code>true</code>.</p> <p>Tip</p> <p>Add the \"subscribe\" namespace to \"PublicModules\" and set <code>\"SubscribeEnabled\": true</code> in <code>node_config.json</code> to enable subscription APIs</p>"},{"location":"api/subscribe/#topics","title":"Topics","text":"<p>Topics are 32-byte event signatures or indexed parameters of a smart contract. For a non-anonymous Solidity++ event, the first topic is the event signature, and the rest (if any) are encoded indexed fields.</p> <p>Topics are often used to search for specific event logs.</p>"},{"location":"api/subscribe/#topic-matching-rules","title":"Topic Matching Rules","text":"<ul> <li><code>[]</code> matches all event logs</li> <li><code>[[A]]</code> matches event logs with \"A\" as the first topic</li> <li><code>[[], [B]]</code> matches event logs with \"B\" as the second topic</li> <li><code>[[A], [B]]</code> matches event logs with \"A\" as the first topic and \"B\" as the second topic</li> <li><code>[[A, B], [C, D]]</code> matches event logs with \"A\" or \"B\" as the first topic, and \"C\" or \"D\" as the second topic</li> <li><code>[[A, B], [C, D], [E]]</code> matches event logs with \"A\" or \"B\" as the first topic, \"C\" or \"D\" as the second topic, and \"E\" as the third topic</li> <li><code>[[T11, T12, ... , T1M], [T21, T22, ... , T2M], ... , [TN1, TN2, ... , TNM]]</code> matches event logs with T<sub>11</sub>, T<sub>12</sub> ... or T<sub>1M</sub> as the first topic, T<sub>21</sub>, T<sub>22</sub> ... or T<sub>2M</sub> as the second topic, ... and T<sub>N1</sub>, T<sub>N2</sub> ... or T<sub>NM</sub> as the N topic (N &lt;= 4)</li> </ul> <p>Note</p> <p>Solidity++ allows a maximum of 4 topics, including one event signature and three indexed parameters </p> <p>Tip</p> <p>Use an SDK like Vite.js to generate topic filters</p>"},{"location":"api/subscribe/#example","title":"Example","text":"<p>Assume address \"vite_f48f811a1800d9bde268e3d2eacdc4b4f8b9110e017bd7a76f\" is a smart contract and we want to obtain its event logs.</p>"},{"location":"api/subscribe/#using-websocket-api","title":"Using WebSocket API","text":"<p>Create a <code>newVmLog</code> subscription on the contract address by calling <code>subscribe_subscribe</code> with event type <code>newVmLog</code>.  <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_subscribe\",\n    \"params\": [\n        \"newVmLog\",\n        {\n            \"addressHeightRange\": {\n                \"vite_f48f811a1800d9bde268e3d2eacdc4b4f8b9110e017bd7a76f\": {\n                    \"fromHeight\": \"0\",\n                    \"toHeight\": \"0\"\n                }\n            }\n        }\n    ]\n}\n</code></pre> It returns a subscription id \"0x4b97e0674a5ebef942dbb07709c4a608\" <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0x4b97e0674a5ebef942dbb07709c4a608\"\n}\n</code></pre> When a new event log is generated, it will be returned in a callback named <code>subscribe_subscription</code> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"subscribe_subscription\",\n    \"params\": {\n        \"subscription\": \"0x4b97e0674a5ebef942dbb07709c4a608\",\n        \"result\": [\n            {\n                \"vmlog\": {\n                    \"topics\": [\n                        \"aa65281f5df4b4bd3c71f2ba25905b907205fce0809a816ef8e04b4d496a85bb\",\n                        \"000000000000000000000000bb6ad02107a4422d6a324fd2e3707ad53cfed935\"\n                    ],\n                    \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo=\"\n                },\n                \"accountBlockHash\": \"23ea04b0dea4b9d0aa4d1f84b246b298a30faba753fa48303ad2deb29cd27f40\",\n                \"accountBlockHeight\": \"10\",\n                \"address\": \"vite_f48f811a1800d9bde268e3d2eacdc4b4f8b9110e017bd7a76f\",\n                \"removed\": false\n            }\n        ]\n    }\n}\n</code></pre></p> <p>Tip</p> <p>A broken network connection may cause the WebSocket subscription to close accidentally. In this situation, you should resume the subscription first. To get the missing blocks or events, call the corresponding Ledger API <code>ledger_getSnapshotBlocks</code>, <code>ledger_getAccountBlocks</code>, <code>ledger_getUnreceivedBlocksByAddress</code>, or <code>ledger_getVmLogsByFilter</code> to fetch the missing blocks during the downtime.</p>"},{"location":"api/subscribe/#using-polling-api","title":"Using Polling API","text":"<p>First, create a filter for the contract address <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_newVmLogFilter\",\n    \"params\": [\n        {\n            \"addressHeightRange\": {\n                \"vite_f48f811a1800d9bde268e3d2eacdc4b4f8b9110e017bd7a76f\": {\n                    \"fromHeight\": \"0\",\n                    \"toHeight\": \"0\"\n                }\n            }\n        }\n    ]\n}\n</code></pre> It returns a filter id \"0x61d780619649fb0872e1f94a40cec713\" <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0x61d780619649fb0872e1f94a40cec713\"\n}\n</code></pre> We call <code>subscribe_getChangesByFilterId</code> to poll for new events with the filter id <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"subscribe_getChangesByFilterId\",\n    \"params\": [\n        \"0x61d780619649fb0872e1f94a40cec713\"\n    ]\n}\n</code></pre> If there are new event logs generated since the last polling, the logs will be returned <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"result\": {\n        \"result\": [\n            {\n                \"vmlog\": {\n                    \"topics\": [\n                        \"96a65b1cd08da045d0318cafda7b8c8436092851d5a4b7e75054c005a296e3fb\",\n                        \"0000000000000000000000ab24ef68b84e642c0ddca06beec81c9acb1977bb00\"\n                    ],\n                    \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN4Lazp2QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAF\"\n                },\n                \"accountBlockHash\": \"802b82821ec52bdadb8b79a53363bf2f90645caef95a83c34af20c640a6c320b\",\n                \"accountBlockHeight\": \"10\",\n                \"address\": \"vite_f48f811a1800d9bde268e3d2eacdc4b4f8b9110e017bd7a76f\",\n                \"removed\": false\n            }\n        ],\n        \"subscription\": \"0x61d780619649fb0872e1f94a40cec713\"\n    }\n}\n</code></pre> Note that if <code>subscribe_getChangesByFilterId</code> is not called for more than 5 minutes, the filter will expire. Always remember to call the API within every 5 minutes to keep it alive.</p> <p>Additionally, we can call <code>subscribe_uninstallFilter</code> to stop a filter if necessary.  <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_uninstallFilter\",\n    \"params\": [\n        \"0x61d780619649fb0872e1f94a40cec713\"\n    ]\n}\n</code></pre></p>"},{"location":"api/subscribe/#subscribe_newsnapshotblockfilter","title":"<code>subscribe_newSnapshotBlockFilter</code>","text":"<p>Create a filter for new snapshot blocks.</p> <ul> <li> <p>Parameters: none</p> </li> <li> <p>Returns:  </p> <ul> <li><code>string</code> Filter Id</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_newSnapshotBlockFilter\",\n    \"params\": []\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0xf90906914486a9c22d620e50022b38d5\"\n}\n</code></pre>"},{"location":"api/subscribe/#subscribe_newaccountblockfilter","title":"<code>subscribe_newAccountBlockFilter</code>","text":"<p>Create a filter for new transactions (account blocks) for all accounts</p> <ul> <li> <p>Parameters: none</p> </li> <li> <p>Returns:  </p> <ul> <li><code>string</code> Filter Id</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_newAccountBlockFilter\",\n    \"params\": []\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0xf90906914486a9c22d620e50022b38d5\"\n}\n</code></pre>"},{"location":"api/subscribe/#subscribe_newaccountblockbyaddressfilter","title":"<code>subscribe_newAccountBlockByAddressFilter</code>","text":"<p>Create a filter for new account blocks by address</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>address</code>: <code>address</code>  Address of account</li> </ul> </li> <li> <p>Returns:  </p> <ul> <li><code>string</code> Filter Id</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_newAccountBlockByAddressFilter\",\n    \"params\": [\n        \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0x4f18a08c6e6801aeb7a8cfbad0ca90af\"\n}\n</code></pre>"},{"location":"api/subscribe/#subscribe_newunreceivedblockbyaddressfilter","title":"<code>subscribe_newUnreceivedBlockByAddressFilter</code>","text":"<p>Create a filter for new unreceived blocks by address</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>address</code>: <code>address</code>  Address of account</li> </ul> </li> <li> <p>Returns:  </p> <ul> <li><code>string</code> Filter Id</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_newUnreceivedBlockByAddressFilter\",\n    \"params\": [\n        \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0x64e1eb3d26517a0d736b3d85ae9ce299\"\n}\n</code></pre>"},{"location":"api/subscribe/#subscribe_newvmlogfilter","title":"<code>subscribe_newVmLogFilter</code>","text":"<p>Create a filter for new event logs</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>VmLogFilterParam</code><ul> <li><code>addressHeightRange</code>: <code>map&lt;address, Range&gt;</code>  Map of address and account block height range. At least one address should be specified.<ul> <li><code>fromHeight</code>: <code>uint64 string</code>  Start height. <code>0</code> means starting from the latest account block</li> <li><code>toHeight</code>: <code>uint64 string</code>  End height. <code>0</code> means no ending account block height</li> </ul> </li> <li><code>topics</code>: <code>Array&lt;Array&lt;hash&gt;&gt;</code> Event topics to match. See here for details.</li> </ul> </li> </ul> </li> <li> <p>Returns:  </p> <ul> <li><code>string</code> Filter Id</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_newVmLogFilter\",\n    \"params\": [\n        {\n            \"addressHeightRange\": {\n                \"vite_79ac3daebdfed6947c0aaeacd418eadf38a94dddefbd4acec1\": {\n                    \"fromHeight\": \"1\",\n                    \"toHeight\": \"0\"\n                }\n            },\n            \"topics\": [\n                [\n                    \"360bba44e4490fae37d6444482aa67cf5ec7418850531522450c3805b8e5425c\",\n                    \"1d8e14596183a6d73bc8760a43cdaf6992e6cb318cecec67f4b6bcb31fe039d5\"\n                ],\n                [\n                    \"91ac0b2bf8c6dc8d37d0bc48a0eacaf6a7ed5bec9be59086116c6f23eca8aaf0\",\n                    \"3adaf70d6a60eba6aaa6a1884c382ae32b223557ccaa2f3fcab6aec6c2fca21f\"\n                ]\n            ]\n        }\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0x8f34ddeb22b87fdfd2acb6c9f5a2b50d\"\n}\n</code></pre>"},{"location":"api/subscribe/#subscribe_uninstallfilter","title":"<code>subscribe_uninstallFilter</code>","text":"<p>Uninstall the filter and stop subscription</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>string</code>  Filter id</li> </ul> </li> <li> <p>Returns:  </p> <ul> <li><code>bool</code> <code>true</code> means the subscription is stopped</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_uninstallFilter\",\n    \"params\": [\n        \"0x8f34ddeb22b87fdfd2acb6c9f5a2b50d\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": true\n}\n</code></pre>"},{"location":"api/subscribe/#subscribe_getchangesbyfilterid","title":"<code>subscribe_getChangesByFilterId</code>","text":"<p>Poll for new snapshot blocks, account blocks, unreceived blocks, or event logs by filter id. Returns an empty array if no update.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>string</code>  Filter id</li> </ul> </li> <li> <p>Returns for case <code>subscribe_newSnapshotBlockFilter</code>: </p> <ul> <li><code>subscription</code>: <code>string</code>  Filter id</li> <li><code>result</code>: <code>Array&lt;SnapshotBlockMessage&gt;</code><ul> <li><code>hash</code>: <code>hash</code>  Hash of snapshot block</li> <li><code>height</code>: <code>uint64 string</code>  Height of snapshot block</li> <li><code>removed</code>: <code>bool</code> <code>true</code> means the snapshot block was reverted. For new snapshot blocks, the field is <code>false</code></li> </ul> </li> </ul> </li> <li> <p>Returns for case <code>subscribe_newAccountBlockFilter</code>: </p> <ul> <li><code>subscription</code>: <code>string</code>  Filter id</li> <li><code>result</code>: <code>Array&lt;AccountBlockMessage&gt;</code><ul> <li><code>hash</code>: <code>hash</code>  Hash of account block</li> <li><code>removed</code>: <code>bool</code> <code>true</code> means the account block was reverted. For new account block, the field is <code>false</code></li> </ul> </li> </ul> </li> <li> <p>Returns for case <code>subscribe_newAccountBlockByAddressFilter</code>: </p> <ul> <li><code>subscription</code>: <code>string</code>  Filter id</li> <li><code>result</code>: <code>Array&lt;AccountBlockWithHeightMessage&gt;</code><ul> <li><code>hash</code>: <code>hash</code>  Hash of account block</li> <li><code>height</code>: <code>uint64 string</code>  Height of account block</li> <li><code>removed</code>: <code>bool</code> <code>true</code> means the account block was reverted. For new account block, the field is <code>false</code></li> </ul> </li> </ul> </li> <li> <p>Returns for case <code>subscribe_newUnreceivedBlockByAddressFilter</code>: </p> <ul> <li><code>subscription</code>: <code>string</code>  Filter id</li> <li><code>result</code>: <code>Array&lt;UnreceivedBlockMessage&gt;</code><ul> <li><code>hash</code>: <code>hash</code>  Hash of unreceived block</li> <li><code>received</code>: <code>bool</code> <code>true</code> means the block has been received</li> <li><code>removed</code>: <code>bool</code> <code>true</code> means the unreceived block was reverted. For new unreceived blocks, both <code>removed</code> and <code>received</code> is <code>false</code>. </li> </ul> </li> </ul> </li> <li> <p>Returns for case <code>subscribe_newVmLogFilter</code>:</p> <ul> <li><code>subscription</code>: <code>string</code>  Filter id</li> <li><code>result</code>: <code>Array&lt;VmlogMessage&gt;</code><ul> <li><code>accountBlockHash</code>: <code>hash</code>  Hash of account block</li> <li><code>accountBlockHeight</code>: <code>uint64 string</code>  Height of account block</li> <li><code>address</code>: <code>address</code>  Address of account</li> <li><code>vmlog</code>: <code>VmLog</code>  Event logs<ul> <li><code>topics</code>: <code>Array&lt;hash&gt;</code>  Event signature and indexed fields</li> <li><code>data</code>: <code>base64</code>  Encoded non-indexed parameters in base64 format</li> </ul> </li> <li><code>removed</code>: <code>bool</code> <code>true</code> means the event log was reverted</li> </ul> </li> </ul> </li> </ul> <p>Example</p> Requestsubscribe_newSnapshotBlockFiltersubscribe_newAccountBlockFiltersubscribe_newAccountBlockByAddressFiltersubscribe_newUnreceivedBlockByAddressFiltersubscribe_newVmLogFilter <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_getChangesByFilterId\",\n    \"params\": [\n        \"0xf90906914486a9c22d620e50022b38d5\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n    \"result\": [\n        {\n            \"hash\": \"5d47f2e0a532923f7ee53e7b465381f197a669e86155d541b3b7f3d63f07a0e2\",\n            \"height\": \"124\",\n            \"removed\": false\n        },\n        {\n            \"hash\": \"78b19cb84ac293d4af3f36e741938929f6d3311362e1265e87bbaa74e5fcef09\",\n            \"height\": \"125\",\n            \"removed\": false\n        },\n        {\n            \"hash\": \"94437996b3e70afd5d8593e2020ae56f63dbbc538df1ead1633340393bd52c1a\",\n            \"height\": \"126\",\n            \"removed\": false\n        }\n    ],\n    \"subscription\": \"0xf90906914486a9c22d620e50022b38d5\"\n    }\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n    \"result\": [\n        {\n            \"hash\": \"9cc9ba996a4192e35ddbfe3ba448611fc06f6342463e21d3300e58e9772b348f\",\n            \"removed\": false\n        },\n        {\n            \"hash\": \"8b9f8067ef09aa09c8f9d652f0d9ac5e99d083722089a6d91323cffd8b2dcf08\",\n            \"removed\": false\n        }\n    ],\n    \"subscription\": \"0xf90906914486a9c22d620e50022b38d5\"\n    }\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n    \"result\": [\n        {\n            \"hash\": \"72ec861cb2f6c32a48632407f3aa1b05d5ad450ef75fa7660dd39d7be6d3ab68\",\n            \"height\": \"15\",\n            \"removed\": false\n        }\n    ],\n    \"subscription\": \"0xf90906914486a9c22d620e50022b38d5\"\n    }\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n    \"result\": [\n        {\n            \"hash\": \"72ec861cb2f6c32a48632407f3aa1b05d5ad450ef75fa7660dd39d7be6d3ab68\",\n            \"received\": false,\n            \"removed\": false\n        },\n        {\n            \"hash\": \"72ec861cb2f6c32a48632407f3aa1b05d5ad450ef75fa7660dd39d7be6d3ab68\",\n            \"received\": true,\n            \"removed\": false\n        },\n        {\n            \"hash\": \"72ec861cb2f6c32a48632407f3aa1b05d5ad450ef75fa7660dd39d7be6d3ab68\",\n            \"received\": false,\n            \"removed\": true\n        }\n    ],\n    \"subscription\": \"0xf90906914486a9c22d620e50022b38d5\"\n    }\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n    \"result\": [\n        {\n            \"vmlog\": {\n                \"topics\": [\n                    \"aa65281f5df4b4bd3c71f2ba25905b907205fce0809a816ef8e04b4d496a85bb\",\n                    \"000000000000000000000000bb6ad02107a4422d6a324fd2e3707ad53cfed935\"\n                ],\n                \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo=\"\n            },\n            \"accountBlockHash\": \"de8cd1dc188fd4bf44c0cb90958ffbcccab5766840d56f7b35443a1a1c5c9d3e\",\n            \"accountBlockHeight\": \"10\",\n            \"address\": \"vite_78926f48bccef67a3b9cc64fdfe864f2a708ebce1d0bbe9aef\",\n            \"removed\": false\n        }\n    ],\n    \"subscription\": \"0xf90906914486a9c22d620e50022b38d5\"\n    }\n}\n</code></pre>"},{"location":"api/subscribe/#subscribe_subscribe","title":"<code>subscribe_subscribe</code>","text":"<p>This WebSocket API should be used with the following event types. A single callback returns up to 128 blocks or logs.</p>"},{"location":"api/subscribe/#newsnapshotblock","title":"<code>newSnapshotBlock</code>","text":"<p>Subscribe to new snapshot blocks. New snapshot blocks will be returned in callback</p> <ul> <li> <p>Parameters: none</p> </li> <li> <p>Returns:  </p> <ul> <li><code>string</code>  Subscription id</li> </ul> </li> <li> <p>Callback:  </p> <ul> <li><code>subscription</code>: <code>string</code>  Subscription id</li> <li><code>result</code>: <code>Array&lt;SnapshotBlockMessage&gt;</code><ul> <li><code>hash</code>: <code>hash</code>  Hash of snapshot block</li> <li><code>height</code>: <code>uint64 string</code>  Height of snapshot block</li> <li><code>removed</code>: <code>bool</code> <code>true</code> means the snapshot block was reverted. For new snapshot block, the field is <code>false</code></li> </ul> </li> </ul> </li> </ul> <p>Example</p> RequestResponseCallback <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_subscribe\",\n    \"params\": [\"newSnapshotBlock\"]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0xa809145803ebb2a52229aefcbd52a99d\"\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"subscribe_subscription\",\n    \"params\": {\n        \"subscription\": \"0xa809145803ebb2a52229aefcbd52a99d\",\n        \"result\": [\n            {\n                \"hash\": \"22c38acb79e2de0de3c5a09618054b93ac7c7e82f41f9e15d754e58694eefe16\",\n                \"height\": \"250\", \n                \"removed\": false\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"api/subscribe/#newaccountblock","title":"<code>newAccountBlock</code>","text":"<p>Subscribe to new account blocks. New account blocks will be returned in callback</p> <ul> <li> <p>Parameters: none</p> </li> <li> <p>Returns:  </p> <ul> <li><code>string</code>  Subscription id</li> </ul> </li> <li> <p>Callback:  </p> <ul> <li><code>subscription</code>: <code>string</code>  Subscription id</li> <li><code>result</code>: <code>Array&lt;AccountBlockMessage&gt;</code><ul> <li><code>hash</code>: <code>hash</code>  Hash of account block</li> <li><code>removed</code>: <code>bool</code> <code>true</code> means the account block was reverted. For new account block, the field is <code>false</code></li> </ul> </li> </ul> </li> </ul> <p>Example</p> RequestResponseCallback <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_subscribe\",\n    \"params\": [\"newAccountBlock\"]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0xa809145803ebb2a52229aefcbd52a99d\"\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"subscribe_subscription\",\n    \"params\": {\n        \"subscription\": \"0xa809145803ebb2a52229aefcbd52a99d\",\n        \"result\": [\n            {\n                \"hash\": \"20009ee78d5f77122d215c3021f839b4024e4f2701e57bdb574e0cae1ae44e6c\",\n                \"removed\": false\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"api/subscribe/#newaccountblockbyaddress","title":"<code>newAccountBlockByAddress</code>","text":"<p>Subscribe to new account blocks by address. New account blocks will be returned in callback</p> <ul> <li>Parameters:</li> <li> <p><code>address</code>  Address of account</p> </li> <li> <p>Returns:  </p> <ul> <li><code>string</code>  Subscription id</li> </ul> </li> <li> <p>Callback:  </p> <ul> <li><code>subscription</code>: <code>string</code>  Subscription id</li> <li><code>result</code>: <code>Array&lt;AccountBlockWithHeightMessage&gt;</code><ul> <li><code>hash</code>: <code>hash</code>  Hash of account block</li> <li><code>height</code>: <code>uint64 string</code>  Height of account block</li> <li><code>removed</code>: <code>bool</code> <code>true</code> means the account block was reverted. For new account block, the field is <code>false</code></li> </ul> </li> </ul> </li> </ul> <p>Example</p> RequestResponseCallback <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_subscribe\",\n    \"params\": [\"newAccountBlockByAddress\", \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\"]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0xa809145803ebb2a52229aefcbd52a99d\"\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"subscribe_subscription\",\n    \"params\": {\n        \"subscription\": \"0xa809145803ebb2a52229aefcbd52a99d\",\n        \"result\": [\n            {\n                \"hash\": \"20009ee78d5f77122d215c3021f839b4024e4f2701e57bdb574e0cae1ae44e6c\",\n                \"height\": \"1\",\n                \"removed\": false\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"api/subscribe/#newunreceivedblockbyaddress","title":"<code>newUnreceivedBlockByAddress</code>","text":"<p>Subscribe to unreceived blocks by address. New unreceived blocks will be returned in callback</p> <ul> <li>Parameters:</li> <li> <p><code>address</code>  Address of account</p> </li> <li> <p>Returns:  </p> <ul> <li><code>string</code>  Subscription id</li> </ul> </li> <li> <p>Callback:  </p> <ul> <li><code>subscription</code>: <code>string</code>  Subscription id</li> <li><code>result</code>: <code>Array&lt;UnreceivedBlockMessage&gt;</code><ul> <li><code>hash</code>: <code>string hash</code>  Hash of unreceived block</li> <li><code>received</code>: <code>bool</code> <code>true</code> means the block was received</li> <li><code>removed</code>: <code>bool</code> <code>true</code> means the unreceived block was reverted. For new unreceived blocks, both <code>removed</code> and <code>received</code> is <code>false</code>. </li> </ul> </li> </ul> </li> </ul> <p>Example</p> RequestResponseCallback <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_subscribe\",\n    \"params\": [\"newUnreceivedBlockByAddress\", \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\"]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0xa809145803ebb2a52229aefcbd52a99d\"\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"subscribe_subscription\",\n    \"params\": {\n        \"subscription\": \"0xa809145803ebb2a52229aefcbd52a99d\",\n        \"result\": [\n            {\n                \"hash\": \"20009ee78d5f77122d215c3021f839b4024e4f2701e57bdb574e0cae1ae44e6c\",\n                \"received\": false,\n                \"removed\": false\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"api/subscribe/#newvmlog","title":"<code>newVmLog</code>","text":"<p>Subscribe to smart contract event logs. New event logs will be returned in callback</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>VmLogFilterParam</code><ul> <li><code>addressHeightRange</code>: <code>map&lt;address, Range&gt;</code>  Map of address and account block height range. At least one address should be specified.<ul> <li><code>fromHeight</code>: <code>uint64 string</code>  Start height. <code>0</code> means starting from the latest account block</li> <li><code>toHeight</code>: <code>uint64 string</code>  End height. <code>0</code> means no ending account block height</li> </ul> </li> <li><code>topics</code>: <code>Array&lt;Array&lt;hash&gt;&gt;</code> Event topics to match. See here for details.</li> </ul> </li> </ul> </li> <li> <p>Returns:  </p> <ul> <li><code>string</code>  Subscription id</li> </ul> </li> <li> <p>Callback:  </p> <ul> <li><code>subscription</code>: <code>string</code>  Subscription id</li> <li><code>result</code>: <code>Array&lt;VmlogMessage&gt;</code><ul> <li><code>accountBlockHash</code>: <code>hash</code>  Hash of account block</li> <li><code>accountBlockHeight</code>: <code>uint64 string</code>  Height of account block</li> <li><code>address</code>: <code>address</code>  Address of account</li> <li><code>vmlog</code>: <code>VmLog</code>  Event logs<ul> <li><code>topics</code>: <code>Array&lt;hash&gt;</code>  Event signature and indexed fields</li> <li><code>data</code>: <code>base64</code>  Encoded non-indexed parameters in base64 string</li> </ul> </li> <li><code>removed</code>: <code>bool</code> <code>true</code> means the event log was reverted</li> </ul> </li> </ul> </li> </ul> <p>Example</p> RequestResponseCallback <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"subscribe_subscribe\",\n    \"params\": [\n        \"newVmLog\",\n        {\n            \"addressHeightRange\": {\n                \"vite_f48f811a1800d9bde268e3d2eacdc4b4f8b9110e017bd7a76f\": {\n                    \"fromHeight\": \"0\",\n                    \"toHeight\": \"0\"\n                }\n            }\n        }\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"0x4b97e0674a5ebef942dbb07709c4a608\"\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"subscribe_subscription\",\n    \"params\": {\n        \"subscription\": \"0x4b97e0674a5ebef942dbb07709c4a608\",\n        \"result\": [\n            {\n                \"vmlog\": {\n                    \"topics\": [\n                        \"aa65281f5df4b4bd3c71f2ba25905b907205fce0809a816ef8e04b4d496a85bb\",\n                        \"000000000000000000000000bb6ad02107a4422d6a324fd2e3707ad53cfed935\"\n                    ],\n                    \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo=\"\n                },\n                \"accountBlockHash\": \"23ea04b0dea4b9d0aa4d1f84b246b298a30faba753fa48303ad2deb29cd27f40\",\n                \"accountBlockHeight\": \"10\",\n                \"address\": \"vite_f48f811a1800d9bde268e3d2eacdc4b4f8b9110e017bd7a76f\",\n                \"removed\": false\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"api/util/","title":"Util and Dashboard API","text":"<p>Tip</p> <p>To enable the Util and/or Dashboard RPC API on the node, add the \"util\" and/or \"dashboard\" namespaces to \"PublicModules\" in <code>node_config.json</code>.</p>"},{"location":"api/util/#util_getpownonce","title":"<code>util_getPoWNonce</code>","text":"<p>Calculate the PoW nonce based on the difficulty. See here for more details.</p> <ul> <li>Parameters: <ul> <li><code>difficulty</code>: <code>bigint string</code>  PoW difficulty.</li> <li><code>hash</code>: <code>hash</code>  32-byte $Blake2b(address + previousHash)$ hash.</li> </ul> </li> </ul> <p>For example, if the address is \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\" and the previousHash is \"0000000000000000000000000000000000000000000000000000000000000000\", then the hash is \"8689fc3e7d0bcad0a1213fd90ab53437ce745408750f7303a16c75bad28da8c3\".</p> <ul> <li>Returns: <ul> <li><code>base64</code>:  Nonce.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"util_getPoWNonce\",\n    \"params\": [\n        \"67108863\",\n        \"35c82fe515c2982c5ef75226eab35f3fb14952f8ef59005f02893cd3dca4db09\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"e5WeaVy7tSs=\"\n}\n</code></pre>"},{"location":"api/util/#dashboard_processinfo","title":"<code>dashboard_processInfo</code>","text":"<p>Get go-vite information</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>id</code>: <code>string</code>  Optional request id</li> </ul> </li> <li> <p>Returns: </p> <ul> <li><code>reqId</code>: <code>string</code>  Request id</li> <li><code>build_version</code>: <code>string</code>  Go-vite version</li> <li><code>commit_version</code>: <code>string</code>  Go-vite commit id</li> <li><code>nodeName</code>: <code>string</code>  Node name</li> <li><code>rewardAddress</code>: <code>string</code>  If the node has registered for full node reward program, this field is the address to receive rewards, otherwise returns an empty string.</li> <li><code>pid</code>: <code>int</code>  Go-vite process id</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"dashboard_processInfo\",\n    \"params\": [\"233\"]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": {\n        \"build_version\": \"v2.11.3-nightly-202207201142\",\n        \"commit_version\": \"af5b3bf85a76212304872b6c60381df5b50e6532\",\n        \"nodeName\": \"s1\",\n        \"pid\": 1,\n        \"reqId\": \"233\",\n        \"rewardAddress\": \"\"\n    }\n}\n</code></pre>"},{"location":"api/util/#dashboard_runtimeinfo","title":"<code>dashboard_runtimeInfo</code>","text":"<p>Get go-vite runtime information</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>id</code>: <code>string</code>  Optional request id</li> </ul> </li> <li> <p>Returns: </p> <ul> <li><code>reqId</code>: <code>string</code>  Request id</li> <li><code>peersNum</code>: <code>int</code>  Number of connected peers</li> <li><code>snapshotPendingNum</code>: <code>uint64 string</code>  Number of snapshot blocks in mempool</li> <li><code>accountPendingNum</code>: <code>bigint string</code>  Number of account blocks in mempool</li> <li><code>latestSnapshot</code>: <code>hashHeightTime</code><ul> <li><code>Hash</code>: <code>string</code>  Current snapshot block hash</li> <li><code>Height</code>: <code>uint64</code>  Current snapshot block height</li> <li><code>Time</code>: <code>int64</code>  Current snapshot block timestamp. In milliseconds.</li> </ul> </li> <li><code>updateTime</code>: <code>int64</code>  Node's time. In milliseconds.</li> <li><code>delayTime</code>: <code>Array&lt;int&gt;</code>  Block Propagate Latency. See <code>net_nodeInfo</code> for details</li> <li><code>producer</code>: <code>address</code>  Block creation address if the node is SBP. Optional</li> <li><code>signData</code>: <code>hex</code>  64 byte signature of the current snapshot block hash signed by node's PeerKey </li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"dashboard_runtimeInfo\",\n    \"params\": [\"56678abcd\"]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": {\n        \"accountPendingNum\": \"0\",\n        \"delayTime\": [\n            11659,\n            12311,\n            0,\n            0\n        ],\n        \"latestSnapshot\": {\n            \"Hash\": \"405ff8f0c48b838e293a640eccc13e3ce150fe7e472d8ccf6c87c09ff448a816\",\n            \"Height\": 22655149,\n            \"Time\": 1661708711000\n        },\n        \"peersNum\": 2,\n        \"producer\": \"vite_360232b0378111b122685a15e612143dc9a89cfa7e803f4b5a\",\n        \"reqId\": \"56678abcd\",\n        \"signData\": \"0x30b146b755c1b29ff3492df0ab079875a585fb4aa3080306149cfa1ef997f39f412f592058ed6b561f860300997c8620828d4830041a58177c760faed14af808\",\n        \"snapshotPendingNum\": 0,\n        \"updateTime\": 1661708719144\n    }\n}\n</code></pre>"},{"location":"api/util/#dashboard_osinfo","title":"<code>dashboard_osInfo</code>","text":"<p>Get node's operating system information</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>id</code>: <code>string</code>  Optional request id</li> </ul> </li> <li> <p>Returns: </p> <ul> <li><code>reqId</code>: <code>string</code>  Request id</li> <li><code>os</code>: <code>string</code>  Node's operating system</li> <li><code>platform</code>: <code>string</code>  Operating system platform</li> <li><code>platformFamily</code>: <code>string</code>  Operating system family</li> <li><code>platformVersion</code>: <code>string</code>  Operating system version</li> <li><code>kernelVersion</code>: <code>string</code>  Operating system kernel version</li> <li><code>memTotal</code>: <code>uint64</code>  Total memory. In bytes</li> <li><code>memFree</code>: <code>uint64</code>  Free memory. In bytes</li> <li><code>cpuNum</code>: <code>int</code>  Number of CPU cores</li> <li><code>gorountine</code>: <code>int</code>  Number of Go routines</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"dashboard_osInfo\",\n    \"params\": [\"111\"]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": {\n        \"cpuNum\": 4,\n        \"gorountine\": 106,\n        \"kernelVersion\": \"5.4.0-70-generic\",\n        \"memFree\": 5318713344,\n        \"memTotal\": 8348397568,\n        \"os\": \"linux\",\n        \"platform\": \"ubuntu\",\n        \"platformFamily\": \"debian\",\n        \"platformVersion\": \"20.04\",\n        \"reqId\": \"111\"\n    }\n}\n</code></pre>"},{"location":"api/util/#dashboard_netid","title":"<code>dashboard_netId</code>","text":"<p>Get network id</p> <ul> <li> <p>Parameters:  none</p> </li> <li> <p>Returns: </p> <ul> <li><code>string</code>  Vite Network id. 1 is the mainnet.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"dashboard_netId\",\n    \"params\": []\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": 1\n}\n</code></pre>"},{"location":"api/wallet/","title":"Wallet API","text":"<p>Note</p> <p>To enable the Wallet RPC API on the node, add the \"wallet\" namespace to \"PublicModules\" in <code>node_config.json</code>.</p> <p>Dangerous RPC calls</p> <p>Exposing the wallet module to the public Internet (e.g., setting <code>\"HttpHost\": \"0.0.0.0\"</code>) is risky. Configure \"HttpHost\" and \"WSHost\" to \"127.0.0.1\" or remove the wallet namespace from \"PublicModules\" in <code>node_config.json</code> after setup.</p> <p>Definitions: * Standard Directory: The default wallet directory on the node. For a mainnet node on Linux or Mac, this directory is <code>~/.gvite/maindata/wallet</code>. * Entropy File: A JSON keystore file that stores entropy encrypted with the AES-256 algorithm. * Passphrase: A Scrypt password used to derive the AES-256 key for entropy encryption. Note: This is NOT the bip39 passphrase. By default, the wallet module uses an empty bip39 passphrase (<code>''</code>) when creating seeds from mnemonics, and this value cannot be customized. * Primary Address: For each entropy file, the first Vite address at index 0 is called the primary address.</p>"},{"location":"api/wallet/#wallet_getentropyfilesinstandarddir","title":"<code>wallet_getEntropyFilesInStandardDir</code>","text":"<p>List all entropy files in the default wallet directory.</p> <ul> <li> <p>Parameters: None</p> </li> <li> <p>Returns:</p> <ul> <li><code>Array&lt;string&gt;</code>: Absolute paths of entropy files.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"method\": \"wallet_getEntropyFilesInStandardDir\",\n    \"params\": []\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"result\": [\n        \"/Users/xxx/Library/GVite/testdata/wallet/vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\",\n        \"/Users/xxx/Library/GVite/testdata/wallet/vite_5b013ec4f3c235da12e47b525713e2f5edd0b04df965fafc22\",\n        \"/Users/xxx/Library/GVite/testdata/wallet/vite_67de981eff372d4a757541b05f0e8a269eee11c2f6c9fbdae6\",\n        \"/Users/xxx/Library/GVite/testdata/wallet/vite_f24bb4eceadc65020de5de6a4aeb22c52edd6cb72ee2279a97\"\n    ]\n}\n</code></pre>"},{"location":"api/wallet/#wallet_getallentropyfiles","title":"<code>wallet_getAllEntropyFiles</code>","text":"<p>List all entropy files installed on the node.</p> <ul> <li> <p>Parameters: None</p> </li> <li> <p>Returns:</p> <ul> <li><code>Array&lt;string&gt;</code>: Absolute paths of entropy files.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"wallet_getAllEntropyFiles\",\n    \"params\": []\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"result\": [\n        \"/Users/xxx/Library/GVite/testdata/wallet/vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\",\n        \"/Users/xxx/Library/GVite/testdata/wallet/vite_5b013ec4f3c235da12e47b525713e2f5edd0b04df965fafc22\",\n        \"/Users/xxx/Library/GVite/testdata/wallet/vite_67de981eff372d4a757541b05f0e8a269eee11c2f6c9fbdae6\"\n    ]\n}\n</code></pre>"},{"location":"api/wallet/#wallet_exportmnemonic","title":"<code>wallet_exportMnemonic</code>","text":"<p>Export mnemonic phrase from entropy file</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file, or primary address if the file is under standard directory. </li> <li><code>passphrase</code>: <code>string</code>  Entropy file passphrase</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>string</code>  Mnemonic phrase</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"method\": \"wallet_exportMnemonic\",\n    \"params\": [\n        \"vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\",\n        \"123456\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"result\": \"goddess crush pattern cluster level combine survey give seminar uniform invite beach\"\n}\n</code></pre>"},{"location":"api/wallet/#wallet_unlock","title":"<code>wallet_unlock</code>","text":"<p>Unlock an entropy file with passphrase</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file, or primary address if the file is under standard directory. </li> <li><code>passphrase</code>: <code>string</code>  Entropy file passphrase</li> </ul> </li> <li> <p>Returns: null</p> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"method\": \"wallet_unlock\",\n    \"params\": [\n        \"vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\",\n        \"123456\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"result\": null\n}\n</code></pre>"},{"location":"api/wallet/#wallet_lock","title":"<code>wallet_lock</code>","text":"<p>Lock an entropy file</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file, or primary address if the file is under standard directory. </li> </ul> </li> <li> <p>Returns: null</p> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"method\": \"wallet_lock\",\n    \"params\": [\n        \"vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"result\": null\n}\n</code></pre>"},{"location":"api/wallet/#wallet_deriveaddressesbyindexrange","title":"<code>wallet_deriveAddressesByIndexRange</code>","text":"<p>Derive addresses from an entropy file by index range. The entropy file must be unlocked or the method will return an error.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file, or primary address if the file is under standard directory. </li> <li><code>startIndex</code>: <code>uint32</code>  Start index, included</li> <li><code>endIndex</code>: <code>uint32</code>  End index, excluded. It must hold $endIndex - startIndex \\le 5000$</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>Array&lt;address&gt;</code>  Addresses derived</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"method\": \"wallet_deriveAddressesByIndexRange\",\n    \"params\": [\n        \"/Users/xxx/Library/GVite/testdata/wallet/vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\",\n        0,\n        10\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"result\": [\n        \"vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\",\n        \"vite_659fbce2a908bdab3b7c46348f249c90c812e36b9ceac67aa0\",\n        \"vite_cc373442a471a8dd4b2240d5a74f8e4037177a8795d30bdfd7\",\n        \"vite_1beb02f13af1b16a317c927d470ca3118ba738e22da3f8bf6e\",\n        \"vite_d1c10321319de24bcbd865e7f4127f5873bf9c251f0a4abb00\",\n        \"vite_acf35393ba47b8216ebbc5252e8884d518971a57c11b5866e1\",\n        \"vite_87df61f0feddb6121fecf7d5ba8d7e56443d53ead06da90a06\",\n        \"vite_8de52abce25c65116b08d84966d67e3dd7860848b52f388d23\",\n        \"vite_ed346025dc7196ed000caa429306bbed1bda42010597d63676\",\n        \"vite_783baa0caccff4d365f09873660208ee727bfc5d9710b267e5\"\n    ]\n}\n</code></pre>"},{"location":"api/wallet/#wallet_createentropyfile","title":"<code>wallet_createEntropyFile</code>","text":"<p>Create a new entropy file</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>passphrase</code>: <code>string</code>  A passphrase to encrypt the entropy file</li> </ul> </li> <li> <p>Returns: <code>CreateEntropyFileResponse</code></p> <ul> <li><code>mnemonics</code>: <code>string</code>  Mnemonic phrase</li> <li><code>primaryAddress</code>: <code>address</code>  Address at index 0</li> <li><code>filePath</code>: <code>string</code>  Absolute path of the entropy file</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"wallet_createEntropyFile\",\n    \"params\": [\n        \"123456\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"result\": {\n        \"mnemonics\": \"pear lonely piece base local lift material damp animal siege error throw ride flag version dumb parent clever upper toe lumber great wild vivid\",\n        \"primaryAddress\": \"vite_f646dc1f32b0ea88289bbfe4e4138d26edc9f9eac33a9e5292\",\n        \"filePath\": \"/Users/xxx/Library/GVite/testdata/wallet/vite_f646dc1f32b0ea88289bbfe4e4138d26edc9f9eac33a9e5292\"\n    }\n}\n</code></pre>"},{"location":"api/wallet/#wallet_deriveaddressbyindex","title":"<code>wallet_deriveAddressByIndex</code>","text":"<p>Derive address from an entropy file by index. The entropy file must be unlocked or the method will return an error.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file, or primary address if the file is under standard directory. </li> <li><code>index</code>: <code>uint32</code>  Index of address</li> </ul> </li> <li> <p>Returns: <code>DeriveResult</code></p> <ul> <li><code>bip44Path</code>: <code>string</code>  Address's BIP44 path</li> <li><code>address</code>: <code>address</code>  Derived address</li> <li><code>privateKey</code>: <code>base64</code>  Address's private key in base64 format</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"wallet_deriveAddressByIndex\",\n    \"params\": [\n        \"vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\",\n        0\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"result\": {\n        \"bip44Path\": \"m/44'/666666'/1'\",\n        \"address\": \"vite_8431a5acb599da19529c3e8bd099087a9d550fb29039dada28\",\n        \"privateKey\": \"SKxAWibv4u85xMdRByCaveOwjw0bhempG9/zi59TjJUESNFMNvoE+wP/X/Zz+Tc3ObdZVO53UQT5BS8xATefbg==\"\n    }\n}\n</code></pre>"},{"location":"api/wallet/#wallet_deriveaddressbypath","title":"<code>wallet_deriveAddressByPath</code>","text":"<p>Derive address from an entropy file by bip44 path. The entropy file must be unlocked or the method will return an error.</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file, or primary address if the file is under standard directory. </li> <li><code>bip44Path</code>: <code>string</code>  BIP44 path</li> </ul> </li> <li> <p>Returns: <code>DeriveResult</code></p> <ul> <li><code>bip44Path</code>: <code>string</code>  Address's BIP44 path</li> <li><code>address</code>: <code>address</code>  Derived address</li> <li><code>privateKey</code>: <code>base64</code>  Address's private key in base64 format</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"wallet_deriveAddressByPath\",\n    \"params\": [\n        \"vite_b1c00ae7dfd5b935550a6e2507da38886abad2351ae78d4d9a\",\n        \"m/44'/666666'/2'/4'\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"result\": {\n        \"bip44Path\": \"m/44'/666666'/2'/4'\",\n        \"address\": \"vite_a5efba49303b46c42c7e89b6cf5facd897d3a444fdb37af64e\",\n        \"privateKey\": \"HSe4vB20dKTHYz+xzlAJ+wDhQQTJnJfemLTjbkPBb6ql/LS+lob/77NOdRfky3VWjai4g81mGR8L+goQDgEKoA==\"\n    }\n}\n</code></pre>"},{"location":"api/wallet/#wallet_recoverentropyfile","title":"<code>wallet_recoverEntropyFile</code>","text":"<p>Restore an entropy file from mnemonic phrase</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>mnemonics</code>: <code>string</code>  Mnemonic phrase</li> <li><code>passphrase</code>: <code>string</code>  A passphrase to encrypt the entropy file</li> </ul> </li> <li> <p>Returns: <code>CreateEntropyFileResponse</code></p> <ul> <li><code>mnemonics</code>: <code>string</code>  Mnemonic phrase</li> <li><code>primaryAddress</code>: <code>address</code>  Address at index 0</li> <li><code>filePath</code>: <code>string</code>  Absolute path of the entropy file</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"method\": \"wallet_recoverEntropyFile\",\n    \"params\": [\n        \"utility client point estate auction region jump hat sick blast tomorrow pottery detect mixture clog able person matrix blast volume decide april congress resource\",\n        \"123456\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"result\": {\n        \"mnemonics\": \"utility client point estate auction region jump hat sick blast tomorrow pottery detect mixture clog able person matrix blast volume decide april congress resource\",\n        \"primaryAddress\": \"vite_981bca7a348de85bd431b842d4b6c17044335f71e5f3da59c0\",\n        \"filePath\": \"/Users/xxx/Library/GVite/testdata/wallet/vite_981bca7a348de85bd431b842d4b6c17044335f71e5f3da59c0\"\n    }\n}\n</code></pre>"},{"location":"api/wallet/#wallet_isunlocked","title":"<code>wallet_isUnlocked</code>","text":"<p>Check if the entropy file is unlocked</p> <ul> <li> <p>Parameters:</p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file, or primary address if the file is under standard directory. </li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>bool</code>: <code>true</code> means the entropy file is unlocked</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"method\": \"wallet_isUnlocked\",\n    \"params\": [\n        \"vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"result\": true\n}\n</code></pre>"},{"location":"api/wallet/#wallet_findaddressinentropyfile","title":"<code>wallet_findAddressInEntropyFile</code>","text":"<p>Find an address in entropy file and return the index. Returns an error if the entropy file is locked or the address is not found in the entropy file.</p> <ul> <li> <p>Parameters:  </p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file, or primary address if the file is under standard directory. </li> <li><code>address</code>: <code>address</code>\uff1a Address to find</li> </ul> </li> <li> <p>Returns: <code>FindAddrResponse</code></p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file</li> <li><code>index</code>: <code>uint32</code>  Index of address</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"method\": \"wallet_findAddressInEntropyFile\",\n    \"params\": [\n        \"/Users/xxx/Library/GVite/testdata/wallet/vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\",\n        \"vite_3fd41bb6ba4f15d5e74214a16153ff2f5abce67f73dc0dc07b\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"result\": {\n        \"entropyFile\": \"/Users/xxx/Library/GVite/testdata/wallet/vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\",\n        \"index\": 84\n    }\n}\n</code></pre>"},{"location":"api/wallet/#wallet_findaddress","title":"<code>wallet_findAddress</code>","text":"<p>Find an address in current unlocked entropy file and return the index. Returns an error if the address is not found.</p> <ul> <li> <p>Parameters:  </p> <ul> <li><code>address</code>: <code>address</code>\uff1a Address to find</li> </ul> </li> <li> <p>Returns: <code>FindAddrResponse</code></p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file</li> <li><code>index</code>: <code>uint32</code>  Index of address</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"method\": \"wallet_findAddress\",\n    \"params\": [\n        \"vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 4,\n    \"result\": {\n        \"entropyFile\": \"/Users/xxx/Library/GVite/testdata/wallet/vite_15391ac8b09d4e8ad78bfe5f9f9ab9682fe689572f6f53655e\",\n        \"index\": 84\n    }\n}\n</code></pre>"},{"location":"api/wallet/#wallet_createtransaction","title":"<code>wallet_createTransaction</code>","text":"<p>Send a transaction with the address in entropy file. If entropy file is not specified, this method will search in all entropy files with the passphrase for the address.</p> <p>Note: Despite <code>entropyFile</code> can be omitted, <code>passphrase</code> is a mandatory field to unlock the entropy file</p> <ul> <li> <p>Parameters: <code>CreateTransferTxParms</code></p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file, or primary address if the file is under standard directory. Optional</li> <li><code>address</code>: <code>address</code>  Address of sending account. Mandatory</li> <li><code>toAddress</code>: <code>address</code>  Address of recipient. Mandatory</li> <li><code>tokenId</code>: <code>tokenId</code>  Token id. Mandatory</li> <li><code>passphrase</code>: <code>string</code>  Entropy file passphrase. Mandatory</li> <li><code>amount</code>: <code>bigint string</code>  Transfer amount. Mandatory</li> <li><code>data</code>: <code>base64</code>  Transaction data. Optional</li> <li><code>difficulty</code>: <code>bigint string</code>  PoW difficulty. Optional</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>hash</code>  Hash of the account block that has been sent</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"wallet_createTransaction\",\n    \"params\": [{\n        \"entropyFile\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n        \"address\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n        \"toAddress\": \"vite_086f3decd9d08cc06162b20482ea6eff323667f4bf7fcbe7bf\",\n        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n        \"passphrase\": \"123\",\n        \"amount\": \"10000000000000000000\"\n    }]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": \"3dca3d96d0c0d1bb09d1f3ff9e4743a88d427e5c38e853f928b451f2183ff0f3\"\n}\n</code></pre>"},{"location":"api/wallet/#wallet_addentropystore","title":"<code>wallet_addEntropyStore</code>","text":"<p>Install a new entropy file on the node. This method is used to add an entropy file not in standard directory.</p> <ul> <li> <p>Parameters:  </p> <ul> <li><code>entropyFile</code>: <code>string</code>  Absolute path of the entropy file, or primary address if the file is under standard directory. </li> </ul> </li> <li> <p>Returns: null</p> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"wallet_addEntropyStore\",\n    \"params\": [\n        \"/Users/xxx/Library/GVite/testdata/anotherFolder/vite_086f3decd9d08cc06162b20482ea6eff323667f4bf7fcbe7bf\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": null\n}\n</code></pre>"},{"location":"api/wallet/#wallet_signdata","title":"<code>wallet_signData</code>","text":"<p>Sign a 32 byte hex string with private key of the address. The address must be found in the current unlocked entropy file or the method will return an error.</p> <p>Note</p> <p>The common use case of this method is to sign an account block hash to obtain the signature of the block</p> <ul> <li> <p>Parameters:  </p> <ul> <li><code>address</code>: <code>address</code>  Signing address</li> <li><code>hexMsg</code>: <code>string</code>  32 byte hex message or account block hash</li> </ul> </li> <li> <p>Returns: <code>HexSignedTuple</code></p> <ul> <li><code>message</code>: <code>string</code>  Original message</li> <li><code>signedData</code>: <code>string</code>  64-byte signature in hex format</li> <li><code>pubkey</code>: <code>string</code>  Public key in hex format</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"wallet_signData\",\n    \"params\": [\"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\", \"e039dfc08f5c5e13a480dc598f9ec75797b3ac721ef7af371509cedd5cc64542\"]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": {\n        \"message\": \"e039dfc08f5c5e13a480dc598f9ec75797b3ac721ef7af371509cedd5cc64542\",\n        \"signedData\": \"cbe51cde010b9c18aca33bd0cd05554af5410a23f077782ff7e9a7b039486c161aa8a7a148ad3e29d55321ef2012c4d3dca679d07a0d0c83c47d0e65bd9f1d0c\",\n        \"pubkey\": \"660329bffc2f328cf183e1b7cae3f8b6545548f8e913adab3229492732e0ba56\"\n    }\n}\n</code></pre>"},{"location":"api/contract/","title":"Get Started","text":"<p>Tip</p> <p>It is easier to use an SDK, such as Vite.js or ViteJ, to create or call smart contracts.</p>"},{"location":"api/contract/#create-smart-contract","title":"Create Smart Contract","text":"<p>To create a contract, follow these steps to send a transaction with block type 1:</p> <ol> <li>Call <code>contract_createContractToAddress</code> to generate a new contract address.</li> <li>If the contract constructor has input parameters, encode the arguments according to ABI.</li> <li>Compose block data. The data consists of a prefix of 14 bytes (10-byte consensus group id + 1-byte contract type + 1-byte response latency + 1-byte random degree + 1-byte quota multiplier), the contract's compiled code, and encoded arguments.</li> <li>Create an account block and set all necessary fields. Note that <code>toAddress</code> is the contract address generated in step 1. Set <code>blockType</code> to 1 and <code>fee</code> to 10 VITE. Also, set <code>amount</code> and <code>tokenId</code> if you want to transfer some tokens to the contract (the constructor must be payable).</li> <li>Call <code>ledger_sendRawTransaction</code> to send the transaction.</li> </ol> <p>See here for more information.</p>"},{"location":"api/contract/#call-contract","title":"Call Contract","text":"<p>To call a contract, follow these steps to send a transaction to the smart contract with the encoded method name and arguments:</p> <ol> <li>Encode the function call according to ABI.</li> <li>Create an account block and set all necessary fields. Note that <code>toAddress</code> is the contract address and <code>data</code> is the output from step 1. Set <code>blockType</code> to 2. Also, set <code>amount</code> and <code>tokenId</code> if you want to transfer some tokens (the calling function must be payable).</li> <li>Call <code>ledger_sendRawTransaction</code> to send the transaction.</li> </ol>"},{"location":"api/contract/#read-contract-states","title":"Read Contract States","text":"<p>A contract's public states can be accessed off-chain through the API <code>contract_query</code> (or <code>contract_callOffChainMethod</code> in Solidity++ 0.4) with the following steps:</p> <ol> <li>Encode the view function call (or off-chain method in Solidity++ 0.4) according to ABI.</li> <li>Call <code>contract_query</code> or <code>contract_callOffChainMethod</code> to read contract states.</li> </ol>"},{"location":"api/contract/#call-built-in-contract","title":"Call Built-in Contract","text":"<p>Calling a built-in contract is exactly the same as calling an ordinary contract.</p> <p>Vite has three built-in contracts: Built-in Quota Contract, Built-in Asset Contract, and Built-in Consensus Contract, which will be covered in the next chapters.</p> <p>Note</p> <p>ViteX is also implemented as built-in contracts.</p>"},{"location":"api/contract/#built-in-contract-callbacks","title":"Built-in Contract Callbacks","text":"<p>Some built-in contracts have declared callbacks. The callbacks are used to receive async calling results and should be implemented by the contract that calls the built-in contract. For example, the following ABI declares a function <code>StakeForQuotaWithCallback</code> with a callback of the same name.  Let's assume a contract A calls the function to acquire quota for beneficiary B. To receive the staking result, A implements the callback so the built-in Quota contract can send the result back.</p> <p>Tip</p> <p>In Vite's VM, callbacks are implemented as external functions by adding a trailing \"Callback\" to the original name.</p> <pre><code>[\n  {\"type\":\"function\",\"name\":\"StakeForQuotaWithCallback\", \"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"stakeHeight\",\"type\":\"uint64\"}]},\n  {\"type\":\"callback\",\"name\":\"StakeForQuotaWithCallback\", \"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"success\",\"type\":\"bool\"}]}\n]\n</code></pre> <p>Example</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0;\n\ninterface IQuotaBuiltIn {\n    function StakeForQuotaWithCallback(address beneficiary, uint64 stakeHeight) payable external;\n}\n\ncontract A {\n    IQuotaBuiltIn constant Contract = IQuotaBuiltIn(\"vite_0000000000000000000000000000000000000003f6af7459b9\");\n\n    event StakeSuccess(bytes32 indexed id);\n\n    function requestForQuota(address beneficiary) external payable {\n        Contract.StakeForQuotaWithCallback{value: 134 vite}(beneficiary, 259200); \n    }\n\n    // Will be called back by quota contract\n    function StakeForQuotaWithCallbackCallback(bytes32 id, bool success) external {\n        require(msg.sender == address(\"vite_0000000000000000000000000000000000000003f6af7459b9\"));\n        if (success) {\n            emit StakeSuccess(id);\n        } \n    }\n}\n</code></pre> <p>In this example, <code>StakeForQuotaWithCallbackCallback</code> is the callback for the function <code>StakeForQuotaWithCallback</code>.</p>"},{"location":"api/contract/contract/","title":"Contract API","text":"<p>Tip</p> <p>To enable the Contract RPC API on the node, add the \"contract\" namespace in \"PublicModules\" in node_config.json</p>"},{"location":"api/contract/contract/#contract_createcontractaddress","title":"<code>contract_createContractAddress</code>","text":"<p>Create a new contract address</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>address</code>: <code>address</code>  Account address</li> <li><code>height</code>: <code>uint64 string</code>  Height of the account block</li> <li><code>previousHash</code>: <code>hash</code>  Hash of the previous account block</li> </ul> </li> <li> <p>Returns: </p> <ul> <li><code>address</code>  New contract address</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_createContractAddress\",\n    \"params\": [\n        \"vite_a5a7f08011c2f0e40ccd41b5b79afbfb818d565f566002d3c6\",\n        \"2\",\n        \"3a56babeb0a8140b12ac55e91d2e05c41f908ebe99767b0e4aa5cd7af22d6de7\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"vite_96a7911037179451bada2ab05ee070ba83dcfa2fac2ad6d770\"\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getcontractinfo","title":"<code>contract_getContractInfo</code>","text":"<p>Get contract information by address</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>address</code>: <code>address</code>  Address of the contract</li> </ul> </li> <li> <p>Returns: <code>ContractInfo</code></p> <ul> <li><code>code</code>: <code>base64</code>  Binary code of the contract</li> <li><code>gid</code>: <code>gid</code>  Consensus group id. Default is <code>00000000000000000002</code></li> <li><code>responseLatency</code>: <code>uint8</code> Response latency</li> <li><code>randomDegree</code>: <code>uint8</code> Random degree</li> <li><code>quotaMultiplier</code>: <code>uint8</code> Quota multiplier</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getContractInfo\",\n    \"params\": [\"vite_22f4f195b6b0f899ea263241a377dbcb86befb8075f93eeac8\"]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"code\": \"AWCAYEBSYAQ2EGEAQVdgADV8AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQBGP/////FoBjkabLSxRhAEZXW2AAgP1bYQCJYASANgNgIIEQFWEAXFdgAID9W4EBkICANXT///////////////////////////8WkGAgAZCSkZBQUFBhAItWWwBbgHT///////////////////////////8WRmn/////////////FjRgQFFgQFGAggOQg4WH8VBQUFCAdP///////////////////////////xZ/qmUoH130tL08cfK6JZBbkHIF/OCAmoFu+OBLTUlqhbs0YEBRgIKBUmAgAZFQUGBAUYCRA5CiUFb+oWVienpyMFgg5BEYZploBADsJutGp1y0+UwegyI5VjOkuA+v2lg7JFoAKQ==\",\n        \"gid\": \"00000000000000000002\",\n        \"responseLatency\": 2,\n        \"randomDegree\": 1,\n        \"quotaMultiplier\": 10\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_calloffchainmethod","title":"<code>contract_callOffChainMethod</code>","text":"<p>Call an offchain method in Solidity++ 0.4</p> <ul> <li> <p>Parameters: <code>CallOffChainMethodParam</code></p> <ul> <li><code>address</code>:<code>address</code> Contract address</li> <li><code>code</code>:<code>base64</code> Binary code of the offchain method</li> <li><code>data</code>:<code>base64</code> Encoded arguments</li> </ul> </li> <li> <p>Returns: </p> <ul> <li><code>base64</code> Encoded calling result in base64 format</li> </ul> </li> </ul> <p>Note: Offchain method has been replaced by view functions in Solidity++ 0.8</p> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_callOffChainMethod\",\n    \"params\": [{\n    \"address\": \"vite_22f4f195b6b0f899ea263241a377dbcb86befb8075f93eeac8\",\n    \"code\": \"YIBgQFJgBDYQYEJXYAA1fAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkARj/////xaAY8GjSGUUYERXYEJWWwBbYEpgYFZbYEBRgIKBUmAgAZFQUGBAUYCRA5DzW2AAYABgAFBUkFBgblZbkFb+oWVienpyMFggSaCBXUGf/Mh5lfHDLvGQt9g3K+aLjE2PrRxcLb6RSWQAKQ==\",\n    \"data\": \"waNIZQ==\"\n    }]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\"\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_query","title":"<code>contract_query</code>","text":"<p>Call a view function in Solidity++ 0.8</p> <ul> <li> <p>Parameters: <code>QueryParam</code></p> <ul> <li><code>address</code>:<code>address</code>  Contract address</li> <li><code>data</code>:<code>base64</code>  Encoded arguments</li> </ul> </li> <li> <p>Returns: </p> <ul> <li><code>base64</code>  Encoded calling result in base64 string</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_query\",\n    \"params\": [{\n    \"address\": \"vite_22f4f195b6b0f899ea263241a377dbcb86befb8075f93eeac8\",\n    \"data\": \"waNIZQ==\"\n    }]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\"\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getcontractstorage","title":"<code>contract_getContractStorage</code>","text":"<p>Query for a contract's states by search key</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>addr</code>: <code>address</code>  Address of the contract</li> <li><code>prefix</code>: <code>hex</code>  Search key or prefix of the search key of the state. An empty string means to fetch all states.</li> </ul> </li> <li> <p>Returns: </p> <ul> <li><code>map&lt;hex, hex&gt;</code>  Map of key-state in hex format</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"method\": \"contract_getContractStorage\",\n    \"params\": [\"vite_8cf2663cc949442db2d3f78f372621733292d1fb0b846f1651\",\"ffe6859e\"]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 0,\n    \"result\": {\n        \"ffe6859e4c369fdb232c625fc49ab073dc558f710b2b46f15e2387418b70b2c5\": \"10a160f67e2e49af69dbe44e1836a68eaf63942000\",\n        \"ffe6859e4c369fdb232c625fc49ab073dc558f710b2b46f15e2387418b70b2c6\": \"057dc3fa\",\n        \"ffe6859e4c369fdb232c625fc49ab073dc558f710b2b46f15e2387418b70b2c7\": \"021e19e0c9bab2400000\"\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getquotabyaccount","title":"<code>contract_getQuotaByAccount</code>","text":"<p>Get the quota of an account. The returned result is in raw quota.</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>addr</code>: <code>address</code>  Address of the account</li> </ul> </li> <li> <p>Returns: <code>QuotaInfo</code></p> <ul> <li><code>currentQuota</code>: <code>uint64 string</code>  Account's available quota</li> <li><code>maxQuota</code>: <code>uint64 string</code>  Account's maximum quota. It refers to the maximum quota the account can use in an Epoch</li> <li><code>stakeAmount</code>: <code>bigint string</code>  Amount of VITE coins staked for the account</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getQuotaByAccount\",\n    \"params\": [\n        \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"currentQuota\": \"1554000\",\n        \"maxQuota\": \"1575000\",\n        \"stakeAmount\": \"10000000000000000000000\"\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getstakelist","title":"<code>contract_getStakeList</code>","text":"<p>Get the staking records of an account. The returned result is in ascending order by expiration height</p> <p>Note: This method does not return legacy delegated staking records. To get an old delegated staking record, use <code>contract_getDelegatedStakeInfo</code></p> <ul> <li> <p>Parameters: </p> <ul> <li><code>address</code>: <code>address</code>  Address of the account</li> <li><code>pageIndex</code>: <code>int</code>  Page index, starting with 0</li> <li><code>pageSize</code>: <code>int</code>  Page size. Maximum 1000.</li> </ul> </li> <li> <p>Returns: <code>StakeInfoList</code></p> <ul> <li><code>totalStakeAmount</code>: <code>bigint string</code>  Total staking amount</li> <li><code>totalStakeCount</code>: <code>int</code>  Total staking records</li> <li><code>stakeList</code>: <code>Array&lt;StakeInfo&gt;</code><ul> <li><code>stakeAddress</code>: <code>address</code>  Address of the staking account</li> <li><code>stakeAmount</code>: <code>bigint string</code>  Staking amount</li> <li><code>expirationHeight</code>: <code>uint64 string</code>  Lock-up expiration height</li> <li><code>beneficiary</code>: <code>address</code>  Quota beneficiary</li> <li><code>expirationTime</code>: <code>int64</code>  Estimated lock-up expiration time. In seconds.</li> <li><code>id</code>: <code>hash</code> Staking Id. For legacy staking, this field is null.</li> <li><code>isDelegated</code>: <code>bool</code>  Deprecated. Returns false for all records</li> <li><code>delegateAddress</code>: <code>address</code>  Deprecated. Returns \"vite_0000000000000000000000000000000000000000a4f3a0cb58\" (zero address) for all records</li> <li><code>bid</code>: <code>uint8</code>  Deprecated. Returns 0 for all records</li> </ul> </li> </ul> </li> </ul> <p>Note: <code>isDelegated</code>, <code>delegateAddress</code> and <code>bid</code> are deprecated</p> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"1.0\",\n    \"id\": 1,\n    \"method\": \"contract_getStakeList\",\n    \"params\": [\n        \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\",\n        0,\n        10\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"totalStakeAmount\": \"1000000000000000000000\",\n        \"totalStakeCount\": 1,\n        \"stakeList\": [\n            {\n                \"stakeAmount\": \"1000000000000000000000\",\n                \"beneficiary\": \"vite_bd756f144d6aba40262c0d3f282b521779378f329198b591c3\",\n                \"expirationHeight\": \"1360\",\n                \"expirationTime\": 1567490923,\n                \"isDelegated\": false,\n                \"delegateAddress\": \"vite_0000000000000000000000000000000000000000a4f3a0cb58\",\n                \"stakeAddress\": \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\",\n                \"bid\": 0,\n                \"id\": \"349ec3cec028b9768b05d75a384402dfbd790d406b1d2e54841f5bd3b8bdbf67\"\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getrequiredstakeamount","title":"<code>contract_getRequiredStakeAmount</code>","text":"<p>Calculate the minimum required staking amount of Vite coins in order to obtain the quota</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>uint64 string</code>: Per-second raw quota supply. For example, in order to send a transaction that consumes 21,000 raw quota, a minimum of 280 (=21000/75) raw quota supply for every second in an epoch is required</li> </ul> </li> <li> <p>Returns: </p> <ul> <li><code>string bigint</code>: Minimum staking amount</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getRequiredStakeAmount\",\n    \"params\": [\n        \"280\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": \"134000000000000000000\"\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getdelegatedstakeinfo","title":"<code>contract_getDelegatedStakeInfo</code>","text":"<p>Get a legacy delegated staking record. </p> <p>Note: Delegated staking is deprecated</p> <ul> <li> <p>Parameters: <code>StakeQueryParams</code></p> <ul> <li><code>stakeAddress</code>: <code>address</code>  Original staking address</li> <li><code>delegateAddress</code>: <code>address</code>  Delegate address. This often is the contract address that stakes on behalf of the original address</li> <li><code>beneficiary</code>: <code>address</code>  Quota beneficiary</li> <li><code>bid</code>: <code>uint8</code>   Business id, used to mark different staking purposes.</li> </ul> </li> <li> <p>Returns: <code>StakeInfo</code></p> <ul> <li><code>stakeAddress</code>: <code>address</code>  Address of the staking account</li> <li><code>stakeAmount</code>: <code>bigint string</code>  Staking amount</li> <li><code>expirationHeight</code>: <code>uint64 string</code>  Lock-up expiration height</li> <li><code>beneficiary</code>: <code>address</code>  Quota beneficiary</li> <li><code>expirationTime</code>: <code>int64</code>  Estimated lock-up expiration time. In seconds.</li> <li><code>id</code>: <code>hash</code>  For delegated staking, the staking id is null.</li> <li><code>isDelegated</code>: <code>bool</code> <code>true</code> means it is delegated staking  </li> <li><code>delegateAddress</code>: <code>address</code>  Delegate address</li> <li><code>bid</code>: <code>uint8</code>  Business id</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"method\": \"contract_getDelegatedStakeInfo\",\n    \"params\": [\n        {\n            \"stakeAddress\": \"vite_56d8bd5c897ebd7e606c23b392d4a336222dd908437565a43c\",\n            \"delegateAddress\": \"vite_0000000000000000000000000000000000000006e82b8ba657\",\n            \"beneficiary\": \"vite_0000000000000000000000000000000000000006e82b8ba657\",\n            \"bid\": 1\n        }\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 17,\n    \"result\": {\n        \"stakeAmount\": \"502000000000000000000\",\n        \"beneficiary\": \"vite_0000000000000000000000000000000000000006e82b8ba657\",\n        \"expirationHeight\": \"9503969\",\n        \"expirationTime\": 1570194042,\n        \"isDelegated\": true,\n        \"delegateAddress\": \"vite_0000000000000000000000000000000000000006e82b8ba657\",\n        \"stakeAddress\": \"vite_56d8bd5c897ebd7e606c23b392d4a336222dd908437565a43c\",\n        \"bid\": 1,\n        \"id\": null\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getsbplist","title":"<code>contract_getSBPList</code>","text":"<p>Get all SBPs registered by address. The returned result also includes the ones that have been cancelled in history</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>address</code>: <code>address</code>  SBP registration address</li> </ul> </li> <li> <p>Returns: <code>Array&lt;SBPInfo&gt;</code></p> <ul> <li><code>name</code>: <code>string</code>  SBP name</li> <li><code>blockProducingAddress</code>: <code>address</code>  Block creation address</li> <li><code>rewardWithdrawAddress</code>: <code>address</code>  Reward withdrawal address</li> <li><code>stakeAddress</code>: <code>address</code>  Registration address</li> <li><code>stakeAmount</code>: <code>bigint string</code>  Staking amount. In the mainnet, it is 1 million VITE.</li> <li><code>expirationHeight</code>: <code>uint64 string</code>  Lock-up expiration height</li> <li><code>expirationTime</code>: <code>int64</code>  Estimated lock-up expiration time. In seconds.</li> <li><code>revokeTime</code>: <code>int64</code>  The timestamp when the SBP was canceled. For valid SBP this field is 0.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getSBPList\",\n    \"params\": [\n        \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            \"name\": \"s1\",\n            \"blockProducingAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n            \"rewardWithdrawAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n            \"stakeAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n            \"stakeAmount\": \"1000000000000000000000000\",\n            \"expirationHeight\": \"7776000\",\n            \"expirationTime\": 1575266076,\n            \"revokeTime\": 0\n        }\n    ]\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getsbprewardpendingwithdrawal","title":"<code>contract_getSBPRewardPendingWithdrawal</code>","text":"<p>Query for an SBP's unclaimed rewards</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>name</code>: <code>string</code>  SBP name</li> </ul> </li> <li> <p>Returns: <code>SBPReward</code></p> <ul> <li><code>totalReward</code>: <code>bigint string</code>  Total unclaimed rewards</li> <li><code>blockProducingReward</code>: <code>bigint string</code>  Block creation rewards</li> <li><code>votingReward</code>: <code>bigint string</code>  Candidate additional rewards (voting rewards)</li> <li><code>producedBlocks</code>: <code>uint64 string</code>  Not implemented. Returns \"0\"</li> <li><code>targetBlocks</code>: <code>uint64 string</code>  Not implemented. Returns \"0\"</li> <li><code>allRewardWithdrawed</code>: <code>bool</code> <code>true</code> means the SBP has been cancelled and there is no unclaimed rewards left</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getSBPRewardPendingWithdrawal\",\n    \"params\": [\n        \"s1\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"blockProducingReward\": \"1499714611872146118517\",\n        \"votingReward\": \"746306845207209076970\",\n        \"totalReward\": \"2246021457079355195487\",\n        \"producedBlocks\": \"0\",\n        \"targetBlocks\": \"0\",\n        \"allRewardWithdrawed\": false\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getsbprewardbytimestamp","title":"<code>contract_getSBPRewardByTimestamp</code>","text":"<p>Query for all SBP rewards according to the cycle of the timestamp. The method maps the given timestamp to the cycle and returns the SBP rewards generated in the cycle. </p> <ul> <li> <p>Parameters: </p> <ul> <li><code>timestamp</code>: <code>int64</code>  Timestamp. In seconds</li> </ul> </li> <li> <p>Returns: <code>SBPRewardInfo</code> </p> <ul> <li><code>rewardMap</code>: <code>map&lt;string, SBPReward&gt;</code><ul> <li><code>totalReward</code>: <code>bigint string</code>  Total rewards</li> <li><code>blockProducingReward</code>: <code>bigint string</code>  Block creation rewards</li> <li><code>votingReward</code>: <code>bigint string</code>  Candidate additional rewards (voting rewards)</li> <li><code>producedBlocks</code>: <code>uint64 string</code>  Actual blocks produced in the cycle</li> <li><code>targetBlocks</code>: <code>uint64 string</code>  Blocks should be produced in the cycle</li> </ul> </li> <li><code>startTime</code>: <code>int64</code>  Cycle start time. In seconds</li> <li><code>endTime</code>: <code>int64</code>  Cycle end time. In seconds</li> <li><code>cycle</code>: <code>uint64 string</code>  Cycle index</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getSBPRewardByTimestamp\",\n    \"params\": [\n        1567440000\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"rewardMap\": {\n            \"s1\": {\n                \"blockProducingReward\": \"1499714611872146118517\",\n                \"votingReward\": \"746306845207209076970\",\n                \"totalReward\": \"2246021457079355195487\",\n                \"producedBlocks\": \"3153\",\n                \"targetBlocks\": \"3168\",\n                \"allRewardWithdrawed\": false\n            },\n            \"s2\": {\n                \"blockProducingReward\": \"0\",\n                \"votingReward\": \"0\",\n                \"totalReward\": \"0\",\n                \"producedBlocks\": \"0\",\n                \"targetBlocks\": \"3168\",\n                \"allRewardWithdrawed\": false\n            }\n        },\n        \"startTime\": 1567396800,\n        \"endTime\": 1567483200,\n        \"cycle\": \"104\"\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getsbprewardbycycle","title":"<code>contract_getSBPRewardByCycle</code>","text":"<p>Query for all SBP rewards by cycle</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>cycle</code>: <code>uint64 string</code>  Cycle index</li> </ul> </li> <li> <p>Returns: <code>SBPRewardInfo</code> </p> <ul> <li><code>rewardMap</code>: <code>map&lt;string, SBPReward&gt;</code><ul> <li><code>totalReward</code>: <code>bigint string</code>  Total rewards</li> <li><code>blockProducingReward</code>: <code>bigint string</code>  Block creation rewards</li> <li><code>votingReward</code>: <code>bigint string</code>  Candidate additional rewards (voting rewards)</li> <li><code>producedBlocks</code>: <code>uint64 string</code>  Actual blocks produced in the cycle</li> <li><code>targetBlocks</code>: <code>uint64 string</code>  Blocks should be produced in the cycle</li> </ul> </li> <li><code>startTime</code>: <code>int64</code>  Cycle start time. In seconds</li> <li><code>endTime</code>: <code>int64</code>  Cycle end time. In seconds</li> <li><code>cycle</code>: <code>uint64 string</code>  Cycle index</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getSBPRewardByCycle\",\n    \"params\": [\n        \"104\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"rewardMap\": {\n            \"s1\": {\n                \"blockProducingReward\": \"1499714611872146118517\",\n                \"votingReward\": \"746306845207209076970\",\n                \"totalReward\": \"2246021457079355195487\",\n                \"producedBlocks\": \"3153\",\n                \"targetBlocks\": \"3168\",\n                \"allRewardWithdrawed\": false\n            },\n            \"s2\": {\n                \"blockProducingReward\": \"0\",\n                \"votingReward\": \"0\",\n                \"totalReward\": \"0\",\n                \"producedBlocks\": \"0\",\n                \"targetBlocks\": \"3168\",\n                \"allRewardWithdrawed\": false\n            }\n        },\n        \"startTime\": 1567396800,\n        \"endTime\": 1567483200,\n        \"cycle\": \"104\"\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getsbp","title":"<code>contract_getSBP</code>","text":"<p>Get SBP information by name</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>name</code>: <code>string</code>  SBP name</li> </ul> </li> <li> <p>Returns: <code>SBPInfo</code></p> <ul> <li><code>name</code>: <code>string</code>  SBP name</li> <li><code>blockProducingAddress</code>: <code>address</code>  Block creation address</li> <li><code>rewardWithdrawAddress</code>: <code>address</code>  Reward withdrawal address</li> <li><code>stakeAddress</code>: <code>address</code>  Registration address</li> <li><code>stakeAmount</code>: <code>bigint string</code>  Staking amount. In the mainnet, it is 1 million VITE.</li> <li><code>expirationHeight</code>: <code>uint64 string</code>  Lock-up expiration height</li> <li><code>expirationTime</code>: <code>int64</code>  Estimated lock-up expiration time. In seconds.</li> <li><code>revokeTime</code>: <code>int64</code>  The timestamp when the SBP was canceled. For valid SBP this field is 0.</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getSBP\",\n    \"params\": [\n        \"s1\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"name\": \"s1\",\n        \"blockProducingAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n        \"rewardWithdrawAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n        \"stakeAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n        \"stakeAmount\": \"500000000000000000000000\",\n        \"expirationHeight\": \"7776000\",\n        \"expirationTime\": 1575268146,\n        \"revokeTime\": 0\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getsbpvotelist","title":"<code>contract_getSBPVoteList</code>","text":"<p>Get all SBP's current votes</p> <ul> <li> <p>Parameters: none</p> </li> <li> <p>Returns: <code>Array&lt;SBPVoteInfo&gt;</code></p> <ul> <li><code>sbpName</code>: <code>string</code>  SBP name</li> <li><code>blockProducingAddress</code>: <code>address</code>  Block creation address</li> <li><code>votes</code>: <code>bigint string</code>  Number of votes</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getSBPVoteList\",\n    \"params\": []\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            \"sbpName\": \"s1\",\n            \"blockProducingAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n            \"votes\": \"100000000000000000000\"\n        },\n        {\n            \"sbpName\": \"s2\",\n            \"blockProducingAddress\": \"vite_0acbb1335822c8df4488f3eea6e9000eabb0f19d8802f57c87\",\n            \"votes\": \"50000000000000000000\"\n        }\n    ]\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getvotedsbp","title":"<code>contract_getVotedSBP</code>","text":"<p>Get the current voted SBP by account</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>address</code>: <code>address</code>  Address of the account</li> </ul> </li> <li> <p>Returns: <code>VotedSBPInfo</code></p> <ul> <li><code>blockProducerName</code>: <code>string</code>  SBP name</li> <li><code>status</code>: <code>uint8</code>  SBP status. <code>2</code> - the SBP is cancelled, <code>1</code> - SBP is valid</li> <li><code>votes</code>: <code>bigint string</code>  Number of votes. This also refers to the account's available VITE balance</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"1.0\",\n    \"id\": 1,\n    \"method\": \"contract_getVotedSBP\",\n    \"params\": [\n        \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"blockProducerName\": \"s1\",\n        \"status\": 1,\n        \"votes\": \"599960989999999999999999997\"\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_getsbpvotedetailsbycycle","title":"<code>contract_getSBPVoteDetailsByCycle</code>","text":"<p>Get the voting details of all SBPs by cycle</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>cycle</code>: <code>uint64 string</code>  Cycle index</li> </ul> </li> <li> <p>Returns: <code>Array&lt;VoteDetail&gt;</code></p> <ul> <li><code>blockProducerName</code>: <code>string</code>  SBP name</li> <li><code>totalVotes</code>: <code>bigint string</code>  Total votes</li> <li><code>blockProducingAddress</code>: <code>address</code>  Block creation address</li> <li><code>historyProducingAddresses</code>: <code>Array&lt;address&gt;</code>  Block creation addresses used by the SBP in history</li> <li><code>addressVoteMap</code>: <code>map&lt;address, bigint string&gt;</code>  Address-votes map</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"1.0\",\n    \"id\": 1,\n    \"method\": \"contract_getSBPVoteDetailsByCycle\",\n    \"params\": [\n        \"104\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            \"blockProducerName\": \"s1\",\n            \"totalVotes\": \"100000000000000000000\",\n            \"blockProducingAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n            \"historyProducingAddresses\": [\n                \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\"\n            ],\n            \"addressVoteMap\": {\n                \"vite_ab24ef68b84e642c0ddca06beec81c9acb1977bbd7da27a87a\": \"100000000000000000000\"\n            }\n        },\n        {\n            \"blockProducerName\": \"s2\",\n            \"totalVotes\": \"50000000000000000000\",\n            \"blockProducingAddress\": \"vite_0acbb1335822c8df4488f3eea6e9000eabb0f19d8802f57c87\",\n            \"historyProducingAddresses\": [\n                \"vite_0acbb1335822c8df4488f3eea6e9000eabb0f19d8802f57c87\"\n            ],\n            \"addressVoteMap\": {\n                \"vite_56fd05b23ff26cd7b0a40957fb77bde60c9fd6ebc35f809c23\": \"50000000000000000000\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_gettokeninfolist","title":"<code>contract_getTokenInfoList</code>","text":"<p>Get all tokens</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>pageIndex</code>: <code>int</code>  Page index, starting with 0</li> <li><code>pageSize</code>: <code>int</code>  Page size. Maximum 1000</li> </ul> </li> <li> <p>Returns: <code>TokenInfoList</code></p> <ul> <li><code>totalCount</code>: <code>int</code>  Total number of tokens</li> <li><code>tokenInfoList</code>: <code>Array&lt;TokenInfo&gt;</code>  See TokenInfo<ul> <li><code>tokenName</code>: <code>string</code>  Token name</li> <li><code>tokenSymbol</code>: <code>string</code>  Token symbol</li> <li><code>totalSupply</code>: <code>big.Int</code> Total supply</li> <li><code>decimals</code>: <code>uint8</code>  Decimal places</li> <li><code>owner</code>: <code>Address</code>  Token owner</li> <li><code>isReIssuable</code>: <code>bool</code> <code>true</code> means the token can be re-issued</li> <li><code>maxSupply</code>: <code>big.Int</code>  Maximum supply</li> <li><code>isOwnerBurnOnly</code>: <code>bool</code> <code>true</code> means only the token owner can burn the tokens. Deprecated</li> <li><code>tokenId</code>: <code>TokenId</code>  Token ID</li> <li><code>index</code>: <code>uint16</code>  Token index</li> </ul> </li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getTokenInfoList\",\n    \"params\": [\n        0,\n        10\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"totalCount\": 1,\n        \"tokenInfoList\": [\n            {\n                \"tokenName\": \"Vite Token\",\n                \"tokenSymbol\": \"VITE\",\n                \"totalSupply\": \"1000000000000000000000000000\",\n                \"decimals\": 18,\n                \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n                \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n                \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n                \"isReIssuable\": true,\n                \"index\": 0,\n                \"isOwnerBurnOnly\": false\n            }\n        ]\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_gettokeninfobyid","title":"<code>contract_getTokenInfoById</code>","text":"<p>Get token by id</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>tokenId</code>: <code>tokenId</code>  Token id</li> </ul> </li> <li> <p>Returns: <code>TokenInfo</code></p> <ul> <li><code>tokenName</code>: <code>string</code>  Token name</li> <li><code>tokenSymbol</code>: <code>string</code>  Token symbol</li> <li><code>totalSupply</code>: <code>big.Int</code> Total supply</li> <li><code>decimals</code>: <code>uint8</code> Decimal places</li> <li><code>owner</code>: <code>Address</code> Token owner</li> <li><code>isReIssuable</code>: <code>bool</code> <code>true</code> means the token can be re-issued</li> <li><code>maxSupply</code>: <code>big.Int</code>  Maximum supply</li> <li><code>isOwnerBurnOnly</code>: <code>bool</code> <code>true</code> means only the token owner can burn the tokens. Deprecated</li> <li><code>tokenId</code>: <code>TokenId</code> Token ID</li> <li><code>index</code>: <code>uint16</code> Token index</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getTokenInfoById\",\n    \"params\": [\n        \"tti_5649544520544f4b454e6e40\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"tokenName\": \"VITE\",\n        \"tokenSymbol\": \"VITE\",\n        \"totalSupply\": \"999369292029736282857580488\",\n        \"decimals\": 18,\n        \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n        \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n        \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n        \"isReIssuable\": true,\n        \"index\": 0,\n        \"isOwnerBurnOnly\": false\n    }\n}\n</code></pre>"},{"location":"api/contract/contract/#contract_gettokeninfolistbyowner","title":"<code>contract_getTokenInfoListByOwner</code>","text":"<p>Get tokens issued by owner</p> <ul> <li> <p>Parameters: </p> <ul> <li><code>address</code>: <code>address</code>  Address of the owner account</li> </ul> </li> <li> <p>Returns: <code>Array&lt;TokenInfo&gt;</code> See TokenInfo</p> <ul> <li><code>tokenName</code>: <code>string</code>  Token name</li> <li><code>tokenSymbol</code>: <code>string</code>  Token symbol</li> <li><code>totalSupply</code>: <code>big.Int</code> Total supply</li> <li><code>decimals</code>: <code>uint8</code> Decimal places</li> <li><code>owner</code>: <code>Address</code> Token owner</li> <li><code>isReIssuable</code>: <code>bool</code> <code>true</code> means the token can be re-issued</li> <li><code>maxSupply</code>: <code>big.Int</code>  Maximum supply</li> <li><code>isOwnerBurnOnly</code>: <code>bool</code> <code>true</code> means only the token owner can burn the tokens. Deprecated</li> <li><code>tokenId</code>: <code>TokenId</code> Token ID</li> <li><code>index</code>: <code>uint16</code> Token index</li> </ul> </li> </ul> <p>Example</p> RequestResponse <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"contract_getTokenInfoListByOwner\",\n    \"params\": [\n        \"vite_0000000000000000000000000000000000000004d28108e76b\"\n    ]\n}\n</code></pre> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            \"tokenName\": \"VITE\",\n            \"tokenSymbol\": \"VITE\",\n            \"totalSupply\": \"999411106171319027184734227\",\n            \"decimals\": 18,\n            \"owner\": \"vite_0000000000000000000000000000000000000004d28108e76b\",\n            \"tokenId\": \"tti_5649544520544f4b454e6e40\",\n            \"maxSupply\": \"115792089237316195423570985008687907853269984665640564039457584007913129639935\",\n            \"isReIssuable\": true,\n            \"index\": 0,\n            \"isOwnerBurnOnly\": false\n        }\n    ]\n}\n</code></pre>"},{"location":"api/contract/built-in-contracts/asset/","title":"Asset Built-in Contract","text":""},{"location":"api/contract/built-in-contracts/asset/#contract-address","title":"Contract Address","text":"<p><code>vite_000000000000000000000000000000000000000595292d996d</code></p>"},{"location":"api/contract/built-in-contracts/asset/#abi","title":"ABI","text":"<pre><code>[\n    // Issue new token\n    {\"type\":\"function\",\"name\":\"IssueToken\",\"inputs\":[{\"name\":\"isReIssuable\",\"type\":\"bool\"},{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"name\":\"isOwnerBurnOnly\",\"type\":\"bool\"}]},\n    // Re-issue. Mint additional tokens\n    {\"type\":\"function\",\"name\":\"ReIssue\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"tokenId\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"receiveAddress\",\"type\":\"address\"}]},\n    // Burn\n    {\"type\":\"function\",\"name\":\"Burn\",\"inputs\":[]},\n    // Transfer ownership of re-issuable token\n    {\"type\":\"function\",\"name\":\"TransferOwnership\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"tokenId\"},{\"name\":\"newOwner\",\"type\":\"address\"}]},\n    // Change token type from re-issuable to non-reissuable\n    {\"type\":\"function\",\"name\":\"DisableReIssue\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"tokenId\"}]},\n    // Get token information\n    {\"type\":\"function\",\"name\":\"GetTokenInformation\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"tokenId\"}]},\n    // Token issuance event\n    {\"type\":\"event\",\"name\":\"issue\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"tokenId\",\"indexed\":true}]},\n    // Token re-issuance event\n    {\"type\":\"event\",\"name\":\"reIssue\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"tokenId\",\"indexed\":true}]},\n    // Burn event\n    {\"type\":\"event\",\"name\":\"burn\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"tokenId\",\"indexed\":true},{\"name\":\"burnAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}]},\n    // Ownership transfer event\n    {\"type\":\"event\",\"name\":\"transferOwnership\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"tokenId\",\"indexed\":true},{\"name\":\"owner\",\"type\":\"address\"}]},\n    // Token type change event\n    {\"type\":\"event\",\"name\":\"disableReIssue\",\"inputs\":[{\"name\":\"tokenId\",\"type\":\"tokenId\",\"indexed\":true}]},\n    // Callback for GetTokenInformation\n    {\"type\":\"callback\",\"name\":\"GetTokenInformation\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"tokenId\",\"type\":\"tokenId\"},{\"name\":\"exist\",\"type\":\"bool\"},{\"name\":\"isReIssuable\",\"type\":\"bool\"},{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"name\":\"isOwnerBurnOnly\",\"type\":\"bool\"},{\"name\":\"index\",\"type\":\"uint16\"},{\"name\":\"ownerAddress\",\"type\":\"address\"}]}\n]\n</code></pre> <p>Warning</p> <p>Due to historical reasons, this contract also contains a number of other ABIs that are NOT listed on this page. These functions are deprecated and no longer in use. Do NOT use them in your code.</p>"},{"location":"api/contract/built-in-contracts/asset/#issuetoken","title":"<code>IssueToken</code>","text":"<p>Mint a new token with an initial supply. The minted token will be sent to the issuer's account. The cost to mint a token is 1,000 VITE.</p> <ul> <li>Parameters: <ul> <li><code>tokenName</code>: <code>string</code> Token name</li> <li><code>tokenSymbol</code>: <code>string</code> Token symbol</li> <li><code>totalSupply</code>: <code>bigint</code> Total initial supply</li> <li><code>decimals</code>: <code>uint8</code> Token decimals</li> <li><code>maxSupply</code>: <code>bigint</code> Maximum supply</li> <li><code>isReIssuable</code>: <code>bool</code> Reissuable flag</li> <li><code>isOwnerBurnOnly</code>: <code>bool</code> <code>true</code> means the token can only be burned by the owner. Deprecated</li> </ul> </li> </ul>"},{"location":"api/contract/built-in-contracts/asset/#reissue","title":"<code>ReIssue</code>","text":"<p>Mint additional units of a re-issuable token and increase the token's total supply. Tokens with fixed supply cannot be reissued.</p> <p>Note: Only the token owner can perform this operation.</p> <ul> <li>Parameters: <ul> <li><code>tokenId</code>: <code>tokenId</code> Token id</li> <li><code>amount</code>: <code>bigint</code> Reissue amount</li> <li><code>receiveAddress</code>: <code>address</code> Receive Address</li> </ul> </li> </ul>"},{"location":"api/contract/built-in-contracts/asset/#burn","title":"<code>Burn</code>","text":"<p>Burn units of a re-issuable token and reduce the total supply. Tokens with fixed supply cannot be burned.</p> <ul> <li>Parameters: none</li> </ul>"},{"location":"api/contract/built-in-contracts/asset/#transferownership","title":"<code>TransferOwnership</code>","text":"<p>Transfer a re-issuable token's ownership to another account.</p> <p>Note</p> <p>Only the token owner can perform this operation.</p> <ul> <li>Parameters: <ul> <li><code>tokenId</code>: <code>tokenId</code> Token id</li> <li><code>newOwner</code>: <code>address</code> New Owner</li> </ul> </li> </ul>"},{"location":"api/contract/built-in-contracts/asset/#disablereissue","title":"<code>DisableReIssue</code>","text":"<p>Permanently change a re-issuable token to non-reissuable.</p> <p>Note</p> <p>Only the token owner can perform this operation.</p> <ul> <li>Parameters: <ul> <li><code>tokenId</code>: <code>tokenId</code> Token id</li> </ul> </li> </ul>"},{"location":"api/contract/built-in-contracts/asset/#gettokeninformation","title":"<code>GetTokenInformation</code>","text":"<p>Get a token's information. This function is provided for another contract to get a token's information within the contract. For client programs, you should call RPC <code>contract_getTokenInfoById</code>.</p> <ul> <li>Parameters: <ul> <li><code>tokenId</code>: <code>tokenId</code> Token id</li> </ul> </li> </ul>"},{"location":"api/contract/built-in-contracts/asset/#callback-gettokeninformation","title":"Callback <code>GetTokenInformation</code>","text":"<p>The callback function of <code>GetTokenInformation</code>. This will be called back by the Asset contract to return the result.</p> <p>Note</p> <p>The current Solidity++ 0.8.0 does not support more than 9 arguments. Solidity++ 0.8.2 will expand this limit to 16.</p> <ul> <li>Parameters: <ul> <li><code>id</code>: <code>bytes32</code> Hash of <code>GetTokenInformation</code> transaction</li> <li><code>tokenId</code>: <code>tokenId</code> Token id</li> <li><code>exist</code>: <code>bool</code> <code>true</code> means the token exists</li> <li><code>isReIssuable</code>: <code>bool</code> <code>true</code> means the token is re-issuable</li> <li><code>tokenName</code>: <code>string</code> Token name</li> <li><code>tokenSymbol</code>: <code>string</code> Token symbol</li> <li><code>totalSupply</code>: <code>bigint</code> Total supply</li> <li><code>decimals</code>: <code>uint8</code> Token decimals</li> <li><code>maxSupply</code>: <code>bigint</code> Maximum supply</li> <li><code>isOwnerBurnOnly</code>: <code>bool</code> <code>true</code> means the token can only be burned by the owner. Deprecated</li> <li><code>index</code>: <code>uint16</code> Token index</li> <li><code>ownerAddress</code>: <code>address</code> Address of token owner</li> </ul> </li> </ul>"},{"location":"api/contract/built-in-contracts/consensus/","title":"Consensus Built-in Contract","text":""},{"location":"api/contract/built-in-contracts/consensus/#contract-address","title":"Contract Address","text":"<p><code>vite_0000000000000000000000000000000000000004d28108e76b</code></p>"},{"location":"api/contract/built-in-contracts/consensus/#abi","title":"ABI","text":"<pre><code>[\n  // Register block producer\n  {\"type\":\"function\",\"name\":\"RegisterSBP\", \"inputs\":[{\"name\":\"sbpName\",\"type\":\"string\"},{\"name\":\"blockProducingAddress\",\"type\":\"address\"},{\"name\":\"rewardWithdrawAddress\",\"type\":\"address\"}]},\n  // Update block producing address\n  {\"type\":\"function\",\"name\":\"UpdateSBPBlockProducingAddress\", \"inputs\":[{\"name\":\"sbpName\",\"type\":\"string\"},{\"name\":\"blockProducingAddress\",\"type\":\"address\"}]},\n  // Update reward withdrawal address\n  {\"type\":\"function\",\"name\":\"UpdateSBPRewardWithdrawAddress\", \"inputs\":[{\"name\":\"sbpName\",\"type\":\"string\"},{\"name\":\"rewardWithdrawAddress\",\"type\":\"address\"}]},\n  // Cancel block producer\n  {\"type\":\"function\",\"name\":\"RevokeSBP\",\"inputs\":[{\"name\":\"sbpName\",\"type\":\"string\"}]},\n  // Withdraw block producing reward\n  {\"type\":\"function\",\"name\":\"WithdrawSBPReward\",\"inputs\":[{\"name\":\"sbpName\",\"type\":\"string\"},{\"name\":\"receiveAddress\",\"type\":\"address\"}]},\n  // Vote for block producer\n  {\"type\":\"function\",\"name\":\"VoteForSBP\", \"inputs\":[{\"name\":\"sbpName\",\"type\":\"string\"}]},\n  // Cancel voting\n  {\"type\":\"function\",\"name\":\"CancelSBPVoting\",\"inputs\":[]}\n]\n</code></pre> <p>Warning</p> <p>Due to historical reasons, this contract also contains a number of other ABIs that are NOT listed on this page. These functions are deprecated and no longer in use. Do NOT use them in your code.</p>"},{"location":"api/contract/built-in-contracts/consensus/#registersbp","title":"<code>RegisterSBP</code>","text":"<p>Register a new SBP. This operation will lock up 1 million Vite coins for 7,776,000 snapshot blocks (3 months). </p> <ul> <li>Parameters: </li> <li><code>sbpName</code>: <code>string</code> SBP name</li> <li><code>blockProducingAddress</code>: <code>address</code> Block creation address</li> <li><code>rewardWithdrawAddress</code>: <code>address</code> Reward withdrawal address</li> </ul>"},{"location":"api/contract/built-in-contracts/consensus/#updatesbpblockproducingaddress","title":"<code>UpdateSBPBlockProducingAddress</code>","text":"<p>Update an SBP's block creation address</p> <ul> <li>Parameters: </li> <li><code>sbpName</code>: <code>string</code> SBP name</li> <li><code>blockProducingAddress</code>: <code>address</code> New block creation address</li> </ul>"},{"location":"api/contract/built-in-contracts/consensus/#updatesbprewardwithdrawaddress","title":"<code>UpdateSBPRewardWithdrawAddress</code>","text":"<p>Update an SBP's reward withdrawal address</p> <ul> <li>Parameters: </li> <li><code>sbpName</code>: <code>string</code> SBP name</li> <li><code>rewardWithdrawAddress</code>: <code>address</code> New reward withdrawal address</li> </ul>"},{"location":"api/contract/built-in-contracts/consensus/#revokesbp","title":"<code>RevokeSBP</code>","text":"<p>Cancel an SBP registration after the lockup period expires</p> <ul> <li>Parameters: </li> <li><code>sbpName</code>: <code>string</code> SBP name</li> </ul>"},{"location":"api/contract/built-in-contracts/consensus/#withdrawsbpreward","title":"<code>WithdrawSBPReward</code>","text":"<p>Withdraw SBP reward. See Rewards Withdrawal for more information.</p> <ul> <li>Parameters: </li> <li><code>sbpName</code>: <code>string</code> SBP name</li> <li><code>receiveAddress</code>: <code>address</code> Address to receive reward</li> </ul>"},{"location":"api/contract/built-in-contracts/consensus/#voteforsbp","title":"<code>VoteForSBP</code>","text":"<p>Vote for an SBP. See Voting for more information.</p> <ul> <li>Parameters: </li> <li><code>sbpName</code>: <code>string</code> SBP name</li> </ul>"},{"location":"api/contract/built-in-contracts/consensus/#cancelsbpvoting","title":"<code>CancelSBPVoting</code>","text":"<p>Withdraw vote</p> <ul> <li>Parameters: none</li> </ul>"},{"location":"api/contract/built-in-contracts/quota/","title":"Quota Built-in Contract","text":""},{"location":"api/contract/built-in-contracts/quota/#contract-address","title":"Contract Address","text":"<p><code>vite_0000000000000000000000000000000000000003f6af7459b9</code></p>"},{"location":"api/contract/built-in-contracts/quota/#staking-id","title":"Staking Id","text":"<p>The staking transaction (request) hash is used as the Staking Id to cancel the staking (unlock) after the lockup period expires.</p>"},{"location":"api/contract/built-in-contracts/quota/#abi","title":"ABI","text":"<pre><code>[\n  // Stake for quota\n  {\"type\":\"function\",\"name\":\"StakeForQuota\", \"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}]},\n  // Cancel staking\n  {\"type\":\"function\",\"name\":\"CancelQuotaStaking\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}]},\n  // Stake for quota with callback\n  {\"type\":\"function\",\"name\":\"StakeForQuotaWithCallback\", \"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"stakeHeight\",\"type\":\"uint64\"}]},\n  // Cancel quota staking with callback\n  {\"type\":\"function\",\"name\":\"CancelQuotaStakingWithCallback\",\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}]},\n  // Callback function for stake for quota\n  {\"type\":\"callback\",\"name\":\"StakeForQuotaWithCallback\", \"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"success\",\"type\":\"bool\"}]},\n  // Callback function for cancel quota staking\n  {\"type\":\"callback\",\"name\":\"CancelQuotaStakingWithCallback\", \"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"success\",\"type\":\"bool\"}]}\n]\n</code></pre> <p>Warning</p> <p>Due to historical reasons, this contract also contains a number of other ABIs that are NOT listed on this page. These functions are deprecated and no longer in use. Do NOT use them in your code.</p>"},{"location":"api/contract/built-in-contracts/quota/#stakeforquota","title":"<code>StakeForQuota</code>","text":"<p>Lock VITE for quota. The minimum locking amount is 134 VITE. The locked coins can be retrieved after 259,200 snapshot blocks (3 days). </p> <p>Note: multiple records will be created if one account stakes for the same beneficiary more than once.  </p> <ul> <li>Parameters: </li> <li><code>beneficiary</code>: <code>address</code> Address of the quota beneficiary</li> </ul>"},{"location":"api/contract/built-in-contracts/quota/#cancelquotastaking","title":"<code>CancelQuotaStaking</code>","text":"<p>Cancel a staking, retrieve locked VITE after the lock-up period expires, and release the quota.</p> <ul> <li>Parameters: </li> <li><code>id</code>: <code>bytes32</code> Staking id</li> </ul>"},{"location":"api/contract/built-in-contracts/quota/#stakeforquotawithcallback","title":"<code>StakeForQuotaWithCallback</code>","text":"<p>Lock VITE for quota. This function is designed for calling from a contract. The contract should implement the callback to receive the staking result. The minimum locking amount is 134 VITE. </p> <ul> <li>Parameters: </li> <li><code>beneficiary</code>: <code>address</code> Address of the quota beneficiary</li> <li><code>stakeHeight</code>: <code>uint64</code> Lock-up period in the number of snapshot blocks. The minimum lock-up height is 259,200.</li> </ul>"},{"location":"api/contract/built-in-contracts/quota/#callback-stakeforquotawithcallback","title":"Callback <code>StakeForQuotaWithCallback</code>","text":"<p>The callback function of <code>StakeForQuotaWithCallback</code>. This callback will be called by the Quota contract to notify the staking result.</p> <ul> <li>Parameters: </li> <li><code>id</code>: <code>bytes32</code>   Staking id </li> <li><code>success</code>: <code>bool</code> This flag is used to indicate whether the staking was successful</li> </ul>"},{"location":"api/contract/built-in-contracts/quota/#cancelquotastakingwithcallback","title":"<code>CancelQuotaStakingWithCallback</code>","text":"<p>Cancel a staking, retrieve locked VITE after the lock-up period expires, and release the quota. This function is designed for calling from a contract. The contract should implement the callback to receive the cancel staking result.</p> <ul> <li>Parameters: </li> <li><code>id</code>: <code>bytes32</code> Staking id </li> </ul>"},{"location":"api/contract/built-in-contracts/quota/#callback-cancelquotastakingwithcallback","title":"Callback <code>CancelQuotaStakingWithCallback</code>","text":"<p>The callback function of <code>CancelQuotaStakingWithCallback</code>. This callback will be called by the Quota contract to notify the cancel staking result.</p> <ul> <li>Parameters: </li> <li><code>id</code>: <code>bytes32</code>   Staking id </li> <li><code>success</code>: <code>bool</code> This flag is used to indicate whether the staking was cancelled</li> </ul>"},{"location":"best-practices/","title":"Best Practices","text":"<p>This document aims to provide the best practices of smart contract development for Vite developers, including common functional practices for smart contracts, and a few examples of pitfalls that must be avoided.</p> <p>Before starting, we assume you have a good understanding of Vite's asynchronous architecture, the foundation for many features of Vite's smart contracts. </p>"},{"location":"best-practices/#transferable-by-default-for-contract","title":"Transferable by Default for Contract","text":"<pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0;\n\ncontract Hello {\n   // Receive Token\n   receive() external payable {\n   }\n}\n</code></pre>"},{"location":"best-practices/#transfer-to-other-addresses-in-the-vite-contract","title":"Transfer to Other Addresses in the Vite Contract","text":"<pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0;\n\ncontract Hello {\n   vitetoken public constant VITE = \"tti_5649544520544f4b454e6e40\";\n\n   function transferTo(address payable to, uint256 num) payable external {\n      require(msg.token == VITE, \"require vite\");\n      require(msg.value &gt;= num, \"enough to transfer\");\n\n      // send VITE to `to`\n      to.transfer(VITE, num);\n   }\n}\n</code></pre>"},{"location":"best-practices/#emit-an-event-in-the-vite-contract","title":"Emit an Event in the Vite Contract","text":"<pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0;\n\ncontract Hello {\n   // declare event\n   event SayHello(address to, bytes message);\n\n   function sayHello(address to, bytes memory message) external {\n       // trigger event\n       emit SayHello(to, message);\n   }\n}\n</code></pre>"},{"location":"best-practices/#using-the-indexed-in-the-vite-contract-event-todo","title":"Using the <code>indexed</code> in the Vite contract event (todo)","text":""},{"location":"best-practices/#getting-random-numbers","title":"Getting Random Numbers","text":"<pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0;\n\ncontract Hello {\n\n   event SayHello(address to, uint64 i, uint256 num);\n\n   function randomEvent(address to) external {\n       emit SayHello(to, 0, random64()); // get random number\n       emit SayHello(to, 1, random64()); // get same random number\n       emit SayHello(to, 2, nextrandom()); // get different random number\n       emit SayHello(to, 4, nextrandom()); // get different random number\n   }\n}\n</code></pre>"},{"location":"best-practices/#calling-other-contracts-asynchronously","title":"Calling Other Contracts Asynchronously","text":"<pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0;\n\ninterface Callee {\n    function invoke(uint num) external;\n}\n\ncontract Hello {\n    function callTo(address to, uint num) external {\n        Callee callee = Callee(to);\n        callee.invoke(num);\n    }\n}\n\ncontract HelloCallee is Callee {\n   event CallEvent(address from, uint256 num);\n\n   function invoke(uint num) external override {\n       emit CallEvent(msg.sender, num); \n   }\n}\n</code></pre>"},{"location":"common-patterns/","title":"Common Patterns","text":"<p>In this chapter, we will cover the common patterns of Vite smart contract development with an example.</p>"},{"location":"common-patterns/#a-well-structured-vite-smart-contract","title":"A Well-Structured Vite Smart Contract","text":"<p>The following contract comes from a collateral vault that accepts Vite coins, and in turn, mints a stablecoin VUSD.</p> <pre><code>// SPDX-License-Identifier: MIT\npragma soliditypp &gt;=0.8.0;\npragma experimental Await;\n\nimport \"./interface/Vault.solpp\";\nimport \"./interface/ITokenMinter.solpp\";\nimport \"./interface/IOracle.solpp\";\nimport \"../openzeppelin/access/Ownable.sol\";\n\ncontract CollateralVault is Vault, Ownable {\n\n    vitetoken constant VITE_TOKEN = \"tti_5649544520544f4b454e6e40\";\n    uint8 constant VITE_DECIMALS = 18;\n    vitetoken constant STABLE_TOKEN = \"tti_80f3751485e4e83456059473\";\n    uint8 constant VUSD_DECIMALS = 6;\n\n    IOracle oracle;\n    // the built-in token issuance contract\n    ITokenMinter tm = ITokenMinter(\"vite_000000000000000000000000000000000000000595292d996d\");\n\n    /// @param _oracleAddress The price oracle contract\n    /// @param _tmAddress The token manager contract\n    constructor(address _oracleAddress, address _tmAddress) payable {\n        collateralToken = VITE_TOKEN;\n        stableToken = STABLE_TOKEN;\n        oracle = IOracle(_oracleAddress);\n        if (_tmAddress != address(0)) {\n            tm = ITokenMinter(_tmAddress);\n        }\n    }\n\n    /// @notice Allows the owner to set a new oracle\n    /// @param _oracleAddress The new price oracle contract to be set\n    function setOracle(address _oracleAddress) public onlyOwner {\n        oracle = IOracle(_oracleAddress);\n    }\n\n    /// @notice Allows the owner to set a new token minter\n    /// @param _tmAddress The new token minter contract to be set\n    function setTokenMinter(address _tmAddress) public onlyOwner {\n        tm = ITokenMinter(_tmAddress);\n    }\n\n    /// @notice Allows a user to deposit VITE in exchange for some amount of VUSD\n    /// @param _depositAmount  The amount of VITE the user sent in the transaction\n    function deposit(uint256 _depositAmount) override payable external {\n        require(VITE_TOKEN == msg.token, \"incorrect deposit token\");\n        require(_depositAmount == msg.value, \"incorrect deposit amount\");\n\n        vaults[msg.sender].collateralAmount += _depositAmount;\n        // estimate mint amount\n        uint256 amountToMint = getMintAmount(_depositAmount);\n        // mint stable coins, the minted token will be sent to msg.sender\n        await tm.ReIssue(STABLE_TOKEN, amountToMint, payable(msg.sender));\n        vaults[msg.sender].debtAmount += amountToMint;\n\n        emit Deposit(_depositAmount, amountToMint);\n    }\n\n    /// @notice Allows a user to withdraw up to 100% of the VITE collateral they have on deposit\n    /// @param _repayAmount  the amount of VUSD that a user is repaying to redeem their collateral for.\n    function withdraw(uint256 _repayAmount) override payable external {\n        require(STABLE_TOKEN == msg.token, \"incorrect repay token\");\n        require(_repayAmount == msg.value, \"incorrect repay amount\");\n        require(_repayAmount &lt;= vaults[msg.sender].debtAmount, \"withdraw limit exceeded\"); \n\n        vaults[msg.sender].debtAmount -= _repayAmount;\n        // estimate withdraw amount\n        uint256 amountToWithdraw =  getWithdrawAmount(_repayAmount);\n        // burn repaid stable coins\n        await tm.Burn{token: STABLE_TOKEN, value: _repayAmount}();\n        vaults[msg.sender].collateralAmount -= amountToWithdraw;\n        // send VITE to msg.sender\n        payable(msg.sender).transfer(VITE_TOKEN, amountToWithdraw);\n\n        emit Withdraw(amountToWithdraw, _repayAmount);\n    }\n\n    /// @notice Returns an estimate of how much collateral VITE could be withdrawn for a given amount of VUSD\n    /// @param _repayAmount  the amount of VUSD that would be repaid\n    /// @return withdrawAmount the estimated amount of a vault's collateral VITE that would be returned \n    function getWithdrawAmount(uint256 _repayAmount) override view public returns(uint256 withdrawAmount) {\n        // get price from oracle\n        (uint256 price, uint8 decimals) = await oracle.getLatestPrice();\n        return _repayAmount * 10**(VITE_DECIMALS + decimals) / (price * 10**VUSD_DECIMALS);\n    }\n\n    /**\n     * @notice Returns an estimate on how much VUSD could be minted at the current rate\n     * @param _depositAmount the amount of VITE that would be deposited\n     * @return mintAmount  the estimated amount of VUSD that would be minted\n     */\n    function getMintAmount(uint256 _depositAmount) override view public returns(uint256 mintAmount) {\n        (uint256 price, uint8 decimals) = await oracle.getLatestPrice();\n        // get price from oracle\n        return _depositAmount * price * 10**VUSD_DECIMALS / 10**(VITE_DECIMALS + decimals);\n    }\n}\n</code></pre> <p>The contract inherits <code>Vault.solpp</code> and <code>openzeppelin/access/Ownable.sol</code>. As an abstract contract, <code>Vault.solpp</code> defines the base functions and the data structure of the vault. <code>Ownable.sol</code> is a standard OpenZeppelin contract of Solidity, which is imported into the collateral contract without change. The contract also declares two interface fields <code>IOracle.solpp</code> and <code>ITokenMinter.solpp</code>, corresponding to a price oracle and a token minter - they will be instantiated during deployment. When the contract is in actual use, the token minter should be the Vite's token issuance contract, and the oracle is assigned with the contract address of <code>TokenPriceOracle.solpp</code>. We simply replace with <code>MockOracle.solpp</code> and <code>MockTokenMinter.solpp</code> in our example for demo purpose and testing.</p> <p><code>MockOracle.solpp</code> returns a fixed price, and <code>MockTokenMinter.solpp</code> maintains an amount of pre-minted VUSD tokens and sends to certain address when it is called. </p> <p>The contract's directory structure is as below.</p> <p></p> Contract directory structure <p></p>"},{"location":"common-patterns/#using-solidity-code","title":"Using Solidity Code","text":"<p>Most Solidity code can be directly used in Solidity++ without any change. This also applies to most contracts in OpenZeppelin library except the \"ERCxxx\" token contracts in Ethereum. In the example, CollateralVault extends <code>Ownable.sol</code> so that the <code>onlyOwner</code> modifier can be used in the contract. <code>Ownable.sol</code> is an standard OpenZeppelin contract written in Solidity.</p> <p>Tip</p> <p>Vite implements a native token issuance model. Issuing or minting a new token doesn't need a \"Token Contract\" as in Ethereum.</p> <pre><code>/// @notice Allows the owner to set a new oracle\n/// @param _oracleAddress The new price oracle contract to be set\nfunction setOracle(address _oracleAddress) public onlyOwner {\n    oracle = IOracle(_oracleAddress);\n}\n</code></pre>"},{"location":"common-patterns/#how-to-transfer-tokens","title":"How to Transfer Tokens","text":"<p>In the example, the contract sends an amount of <code>amountToWithdraw</code> VITE tokens to <code>msg.sender</code>, which is the caller of the <code>withdraw</code> function. <code>msg.sender</code> must be <code>payable</code> in order to receive funds. </p> <pre><code>// send VITE collateral to msg.sender\npayable(msg.sender).transfer(VITE_TOKEN, amountToWithdraw);\n</code></pre> <p>Note: The syntax of sending token to another address is <code>address.transfer(_tti, _amount)</code></p>"},{"location":"common-patterns/#using-implicit-receive-function","title":"Using Implicit Receive Function","text":"<p><code>MockedTokenMinter.solpp</code> has defined a default (implicit) receive function, which allows others send tokens to the contract. Note that the receive function doesn't have any parameters and must be declared as <code>payable</code>.</p> <p>Note: Solidity++ contract doesn't have a default receive function. The contract cannot receive transactions - any token sent to the contract will be returned. Always add the receive function if your contract needs to receive tokens.</p> <pre><code>// SPDX-License-Identifier: MIT\n// SPDX-License-Identifier: MIT\npragma soliditypp &gt;=0.8.0;\n\nimport \"./interface/ITokenMinter.solpp\";\n\ncontract MockedTokenMinter is ITokenMinter {\n\n    vitetoken constant VUSD = \"tti_80f3751485e4e83456059473\";\n\n    /// implicit receive function\n    receive() external payable {\n        require(VUSD == msg.token);\n    }\n\n    /// @notice Mint a given amount of token and send to the recieve address\n    /// @dev Instead of actually mint the token upon request, the tokens will be pre-minted and stored in this mock\n    /// @param tokenId The token to be minted\n    /// @param amount The token amount to be minted\n    /// @param receiveAddress The recipient address which the minted token will be sent to\n    function ReIssue(vitetoken tokenId, uint256 amount, address payable receiveAddress) override external {\n        require(balance(VUSD) &gt;= amount);\n        require(VUSD == tokenId);\n        // transfer token to the receive address\n        receiveAddress.transfer(tokenId, amount);\n        emit Minted(tokenId, amount);\n    }\n\n    /// @notice Burn token\n    /// @dev Instead of acutally burn the token, the tokens sent with this function will be stored in this mock\n    function Burn() override payable external {\n        require(VUSD == msg.token);\n        emit Burned(msg.token, msg.value);\n    }\n}\n</code></pre>"},{"location":"common-patterns/#how-to-call-another-contract","title":"How to Call Another Contract","text":"<p><code>CollateralVault</code> calls the price oracle contract to obtain the current price. For example, <code>await oracle.getLatestPrice()</code> calls the <code>getLatestPrice()</code> function on the oracle and returns the price. The <code>await</code> operator indicates the call is synchronous. The execution will pause until the price is returned from the oracle. </p> <p>Await operator and Solidity</p> <p>The <code>await</code> operator is introduced in Solidity++ v0.8.1. It is a powerful tool that makes synchronous-like calls on Vite possible. Basically, it behaves similarly to a function call in Ethereum, and gives the same execution result. However, due to the asynchronous nature of Vite, in some execution context it might give unexpected results (compared to that in Ethereum). We will explain these pitfalls in the next chapter. </p> <pre><code>function getMintAmount(uint256 _depositAmount) view override returns(uint256 mintAmount) {\n    // get price from oracle\n    (uint256 price, uint8 decimals) = await oracle.getLatestPrice();\n    return _depositAmount * price * 10**VUSD_DECIMALS / 10**(VITE_DECIMALS + decimals);\n}\n</code></pre> <p>Before the <code>await</code> operator is introduced, all the contract call on Vite is asynchronous. They will return immediately and the Vite VM will start execute the next line of code. In the example, if we remove <code>await</code>, <code>oracle.getLatestPrice()</code> will become an async call, and the next line <code>return _depositAmount * price * 10**VUSD_DECIMALS / 10**(VITE_DECIMALS + decimals)</code> will start to run with an invalid price (apparently not the expected behavior for our example).</p> <p>Note: The syntax of calling another contract is <code>contract.f(_params)</code>. If you want to make it synchronous, simply adding <code>await</code> ahead, i.e. <code>await contract.f(_params)</code>.</p>"},{"location":"common-patterns/#how-to-transfer-tokens-when-calling-another-contract","title":"How to Transfer Tokens when Calling Another Contract","text":"<p>After received VUSD repayment, the <code>withdraw</code> function burns the tokens by calling <code>await tm.Burn{token: STABLE_TOKEN, value: _repayAmount}()</code>. This calls the <code>Burn</code> function on TokenMinter contract and sends the tokens for burning. </p> <p>Note: The syntax is <code>contract.f{token: _vitetoken, value: _amount}(_params)</code>. The function must be <code>payable</code>. </p>"},{"location":"common-patterns/#using-librariesopenzeppelin","title":"Using Libraries(OpenZeppelin)","text":"<p>Using OpenZeppelin library is also possible in Solidity++. Let us modify the <code>CollateralVault.solpp</code> contract to use the library <code>SafeMath.sol</code>.</p> <p>Same as what need to be done in Solidity, We add an new import and declare to use the library in the contract.</p> <pre><code>// SPDX-License-Identifier: MIT\npragma soliditypp &gt;=0.8.0;\n\nimport \"./interface/Vault.solpp\";\nimport \"./interface/ITokenMinter.solpp\";\nimport \"./MockOracle.solpp\";\nimport \"../openzeppelin/access/Ownable.sol\";\nimport \"../openzeppelin/utils/math/SafeMath.sol\";\n\ncontract CollateralVault is Vault, Ownable {\n\n    using SafeMath for uint;\n\n    // other code of the contract...\n\n    function getMintAmount(uint256 _depositAmount) view override returns(uint256 mintAmount) {\n        (uint256 price, uint8 decimals) = await oracle.getLatestPrice();\n        // get price from oracle\n        return _depositAmount.mul(price).mul(10**VUSD_DECIMALS).div(10**(VITE_DECIMALS.add(decimals)));\n    }\n}\n</code></pre> <p>We modified <code>getMintAmount(uint256 _depositAmount)</code> by replacing the original math operations with functions provided in the library.</p>"},{"location":"soliditypp/","title":"Index","text":"<p>order: false parent:     title: Solidity++     order: 2</p>"},{"location":"soliditypp/IDE/","title":"How to Use","text":"<p>The recommended development environment for Solidity++ is Visual Studio Code with the Soliditypp extension, which includes a latest version of Vite node, a <code>solppc</code> compiler and debugging environment. </p>"},{"location":"soliditypp/IDE/#install","title":"Install","text":"<p>Download and install Visual Studio Code</p> <p>Launch VSCode, navigate to the Extensions panel and search for \"soliditypp\", install the Solidity++ 0.8 Preview extension. </p> <p>That's it! Now you can proceed to test your environment by deploying a contract.</p> <p>Legacy Extension</p> <p>At current time, two versions of solidity++ extension will be returned. If you are working with a 0.4.x Solidity++ contract, install Solidityppcc.</p>"},{"location":"soliditypp/IDE/#write-contract","title":"Write Contract","text":"<p>First create or specify a folder for your Solidity++ project.</p> <p>Open the debug panel, and click on <code>create a launch.json file</code> link.   Then choose \"Soliditypp\" for the environment.This automatically generates a <code>launch.json</code> file which is used by VSCode to configure the debugger. </p> <p>Create a new file named <code>HelloWorld.solpp</code> and type in the following code:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0;\n\ncontract HelloWorld {\n    uint public data = 123;\n\n    function set(uint a) external {\n        data = a; \n    }\n}\n</code></pre> <p>The contract has a <code>set</code> function setting an input value <code>a</code> to public state field <code>data</code>.</p> <p>Note</p> <p>Public field can be visited with an implicit view function in the same name. </p> <p>Example</p> <p>The legacy extension provides a command to generate a <code>HelloWorld.solpp</code> contract by pressing <code>\u21e7\u2318P</code> (on Mac) or <code>Ctrl+Shift+P</code> (on Windows) to open the Command Palette, then choosing the command <code>&gt;soliditypp: Generate HelloWorld</code>. This has been replaced by <code>&gt;soliditypp: Generate Examples</code> in extension Solidity++ 0.8. </p> <p>You can also fetch the examples from https://github.com/vitelabs/soliditypp-examples</p>"},{"location":"soliditypp/IDE/#debugging","title":"Debugging","text":"<p>Launch the debugger by pressing <code>F5</code>. This will automatically compile the contract and launch a debugger browser window. </p> <p>Note</p> <p>The extension will download <code>gvite</code> node for the first launch, stay patient!</p> <p></p> <p>Compiling Errors</p> <p>If the debugger interface doesn't launch, check the debug console for any errors.</p> <p></p> <p>Gvite Version</p> <p>Since 0.2.5, it's possible to specify the gvite release version by adding <code>gviteVersion</code> in launch.json in your working directory as below.</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"soliditypp\",\n            \"request\": \"launch\",\n            \"name\": \"Soliditypp Debug\",\n            \"program\": \"${file}\",\n            \"gviteVersion\": \"v2.12.0-nightly-202204012212\"\n        }\n    ]\n}\n</code></pre>"},{"location":"soliditypp/IDE/#deployment","title":"Deployment","text":"<p>To deploy your contract to the local (debug) node, simply hit on Deploy as shown below. There are several options available, let's use the default values here.</p> <p></p> <p>When the contract is deployed, a contract address will be displayed. We can call the contract now. </p> <p>The right side of the window shows the execution result logs.</p> <p></p> <p>Let's choose the function <code>set</code> and feed an integer, then click on the call set() button. When the log shows the \"[RECEIVE]\" transaction has been executed, hit the query data() button to check if the data field has been updated. </p> <p>Congratulations! You've deployed and tested your first Solidity++ contract!</p>"},{"location":"soliditypp/IDE/know-more/","title":"Know More about the Debugger","text":"<p>Before reading this section, please make sure you have completed the steps in \"How to use IDE\".</p>"},{"location":"soliditypp/IDE/know-more/#start-stop-the-debugger","title":"Start / Stop the Debugger","text":"<ul> <li>Start: Press <code>F5</code> in VSCode to launch the debugger. This will compile your current contract and load the debugging interface in a browser window. </li> </ul> <p>Note</p> <p>The extension has a local <code>gvite</code> node. Selecting \"debug\" in the network dropdown list to use this node.</p> <ul> <li>Stop: Press <code>Shift+F5</code> in VSCode to stop the debugger.</li> </ul> <p>Warning</p> <p>Please note that all the contracts deployed will be cleaned up on the local debug node after the debugger is stopped.</p>"},{"location":"soliditypp/IDE/know-more/#layout","title":"Layout","text":"<p>The debugger UI has several areas.</p> <p></p>"},{"location":"soliditypp/IDE/know-more/#networkwallet","title":"Network/Wallet","text":"<ul> <li>Network: Select where the contract will be deployed to. Currently supports <code>debug</code>, <code>testnet</code>, <code>mainnet</code>, and <code>custom</code>.</li> </ul> <p><code>custom</code> is added in Solidity++ 0.8, which allows to use a customized node.</p> <ul> <li>Current Node: Shows the current connected network's RPC endpoint.</li> </ul> <p>Tip</p> <p>you can add this endpoint into the desktop wallet's network setting to send or receive transactions on the node.</p> <ul> <li> <p>Snapshot Block Height: Shows the snapshot block height for the connected network. The local <code>debug</code> network will start at 1 each time the debugger is launched.</p> </li> <li> <p>Account Block Number: Shows the current address's block height.</p> </li> <li> <p>Balance: Shows the balance of the current address. On the <code>debug</code> network the address will be initially provided 1,000 VITE. Hitting the <code>\u2295</code> button will supply 1,000 VITE to the address each time. </p> </li> <li> <p>Address/Selected Address: Shows the current address used for contract deployment and debugging. Click on <code>\u2295</code> button to to use a different address.</p> </li> </ul>"},{"location":"soliditypp/IDE/know-more/#contract-deployment","title":"Contract Deployment","text":"<ul> <li> <p>Contract Selection: Select the contract that has been deployed. If the <code>.solpp</code> file has more than one contracts, all of them will be displayed here.</p> </li> <li> <p>amount: Send a certain amount of token to the contract upon deployment.</p> </li> </ul> <p>Note</p> <p>The contract constructor must be <code>payable</code> to accept token transfer on deployment. Otherwise the deployment will fail.</p> <ul> <li>Response Latency Time:  This parameter specifies the required confirmation depth (i.e. number of snapshot blocks) on any request transaction before the deployed contract will send a response transaction. This value ranges from 0 to 75, where 0 means there is no waiting period and respond block will be produced immediately.</li> </ul> <p>Note</p> <p>Larger response latency means slower contract response</p> <p>Tip</p> <p>If the contract uses timestamp, snapshot block height, or random numbers, this parameter must be above 0. </p> <ul> <li> <p>Quota multiplier: This parameter modifies the amount of quota consumed by all request transactions that call the contract. Quota charged on the contract's response transactions are not affected. The Quota multiplier has a range from 10 to 100, which corresponds to a range of 1x to 10x quota consumption. For example, a value of 15 means that the requested transaction to the contract uses 1.5x the default rate.</p> </li> <li> <p>Random degree: The number of snapshot blocks having random seed by which request sent to this contract is confirmed before responding to the specific transaction. Value range is 0-75. 0 indicates that there is no waiting for the request transaction to be included in a snapshot block that contains random number. If any random number related instruction is used in the contract, the value must be above 0. </p> <p>In general, the larger the value, the more secure the random number. This parameter must be no greater than response latency.</p> </li> <li> <p>show abi: Shows the contract's abi specification in JSON. It is important to have this information to call any deployed contract.</p> </li> <li> <p>show binary: Shows the contract's compiled binary code.</p> </li> <li> <p>show offchain code: Shows the contract's compiled offchain code. </p> </li> </ul> <p>Note</p> <p>offchain (getter) function has been deprecated in Solidity++ 0.8. Developer should use <code>query</code> function to access the public fields of the contract.</p>"},{"location":"soliditypp/IDE/know-more/#interact-with-contract","title":"Interact with Contract","text":"<p>This area will only appear after the contract has been deployed or loaded, and is used to call functions on a given contract.</p> <p>Load an existing contract</p> <p>You can load a previously deployed contract by filling in the address and hit the \"Load Contract\" button. This is very useful to load an old contract deployed on the testnet or mainnet.</p> <ul> <li> <p>Contract Name/Address: Shows the address of deployed contracts.</p> </li> <li> <p>Parameters: Shows the input parameters of the deployed contract.</p> </li> </ul>"},{"location":"soliditypp/IDE/know-more/#log","title":"Log","text":"<p>The log area shows the details of <code>Send</code> or <code>Receive</code> transactions for the current address. In general, a <code>Send</code> transaction corresponds the request to call the contract and <code>Receive</code> transaction is the execution.</p> <p>Note</p> <p>If your contract emits <code>Event</code>, the event can be found in the corresponding <code>Receive</code> transaction. </p>"},{"location":"soliditypp/IDE/know-more/#debugger-settings","title":"Debugger Settings","text":"<ul> <li>Mnemonic Words: Shows the mnemonic phrase that are used to generate the wallet addresses in the extension.</li> </ul> <p>Do NOT use your primary wallet for testing</p> <p>Keep your wallet's mnemonic words safe. Do NOT use your primary wallet (that have large funds in the mainnet or any wallet you will use normally in the web/desktop/app wallet) for debugging/testing purpose. You should generate a separate test wallet or use Vite Connect(on mainnet). </p> <ul> <li>Vite Connect: Instead of using the local wallet generated from mnemonic words, this option allows to use ViteConnect to connect a wallet in the Vite Wallet app.</li> </ul> <p>Vite Connect is a safer approach which signs a transaction using private keys secured on the wallet app. The wallet's keys will never be sent to the website. All transactions must be confirmed and signed on the Vite Wallet app. </p>"},{"location":"soliditypp/advanced/","title":"Advanced Topics","text":"<p>We have introduced the amazing features of Vite. Let us now explore some advanced topics and reveal the magic behind it.</p> <p>Note: this chapter will dig into the design and implementation of Vite. If you are new to Vite and just want to build a dApp quickly, you can jump to the next chapter. </p>"},{"location":"soliditypp/advanced/await-operator/","title":"Await Operator","text":"<p>We covered the <code>await</code> operator in chapter Promise and Await. Let us look at how it is implemented in Vite.</p>"},{"location":"soliditypp/advanced/await-operator/#design-objectives","title":"Design Objectives","text":"<p>Let's see a piece of code to know what specific work needs to be done by the compiler and VM:</p> <p></p> <p>In summary, there are the following tasks: * To generate callback entries for each synchronous call automatically at compile time. * To initiate a callback request when the result is returned. * To maintain execution context during function invocations and callbacks.</p>"},{"location":"soliditypp/advanced/await-operator/#solidity-compiler-and-evm","title":"Solidity Compiler and EVM","text":"<p>Before starting, let's take a look at the output from Solidity compiler for an example.</p> <p>Pseudo assembly code for contract <code>A</code>: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(add)\n    jump(tag_function_add)\nelse\n    fallback()\nstop\n\ntag_function_add:\na, b := abi_decode(calldata)\ntmp := checked_add(a, b)\nret := abi_encode(tmp)\nreturn(ret)\n</code></pre></p> <p>Pseudo assembly code for contract <code>B</code>: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(test)\n    jump(tag_function_test)\nelse\n    fallback()\nstop\n\ntag_function_test:\ncontract_address := contractA\nmethod_id := sig_hash(add)\nparams := abi_encode(1, 2)\ncall(contract_address, method_id, params)\nret := abi_decode(returndata)\ndata = ret\nreturn\n</code></pre></p> <p>I use an anatomy diagram to show the control flow:</p> <p></p> <p>As shown by the red arrows in the diagram, the EVM executes external function calls through the <code>call</code> and <code>return</code> instructions.</p> <p>The Solidity compiler will create a piece of code called function selector for each contract that includes the entries to interface functions of the contract at compile time.</p> <p>When executing a message call to a contract, EVM extracts the first four bytes from calldata and compare against the method id of each function, then jump to the definition of a corresponding function and keep executing if they match. Otherwise, jump to the fallback function either defined by user or automatically created by the compiler.</p> <p>When the <code>call</code> instruction gets executed, the EVM will retrieve the callee's address and load the callee\u2019s code from the address and execute the code in an independent context.</p> <p>When the <code>return</code> instruction gets executed, the EVM will place the result of the execution into the memory and exits from the callee's code, and then keep executing the remaining code of the caller.</p>"},{"location":"soliditypp/advanced/await-operator/#solidity-compiler","title":"Solidity++ Compiler","text":"<p>Now let's try to extend the functionality of the Solidity compiler, and introduce the following new features:</p> <ul> <li>To generate a callback entry, the compiler needs to traverse all <code>await</code> expressions in the contract at compile time, add a tag to each position immediately after the <code>await</code>, and add it to the function selector as a callback entry.</li> <li>To initiate a callback request when the result is returned, we need to re-implement the <code>return</code> instruction in the Vite VM to initiate a send transaction with type of <code>SendCallback</code>.</li> <li>To maintain execution context, two new instructions <code>synccall</code> and <code>callbackdest</code> need to be introduced into the Vite VM. </li> </ul> <p>The compiler places a <code>synccall</code> instruction at each synchronous call. When the VM executes the <code>synccall</code> instruction, it initiates a send transaction with type of <code>SendSyncCall</code> and persists the execution context into the local database.</p> <p>Similarly, the compiler places a <code>callbackdest</code> instruction at each callback. When the VM executes the <code>callbackdest</code> instruction, it restores the execution context from the local database and then resumes execution.</p> <p>This design allows the compiler to generate code that can run on an asynchronous VM for contracts written in a programming language similar to Solidity.</p> <p>The example will be compiled to the following code:</p> <p>Pseudo assembly code for contract <code>A</code>: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(add)\n    jump(tag_function_add)\nelse\n    fallback()\nstop\n\ntag_function_add:\na, b := abi_decode(calldata)\ntmp := checked_add(a, b)\nret := abi_encode(tmp)\nreturn(ret)\n</code></pre></p> <p>Pseudo assembly code for contract <code>B</code>: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(test)\n    jump(tag_function_test)\n&lt;strong&gt;else if method_id == 0x00000001\n    jump(tag_callback_01)&lt;/strong&gt;\nelse\n    fallback()\nstop\n\ntag_function_test:\ncontract_address := contractA\nmethod_id := sig_hash(add)\nparams := abi_encode(1, 2)\n&lt;strong&gt;callback_id := 0x00000001\nsynccall(contract_address, method_id, params, callback_id)&lt;/strong&gt;\nstop\n\n&lt;strong&gt;tag_callback_01:\ncallbackdest\nret := abi_decode(calldata)\nreturn(ret)\n</code></pre></p> <p>Again, let's put these in an anatomy diagram:</p> <p></p> <p>The assembly code in blue is generated by the Solidity++ compiler specifically for the Vite VM.</p> <p>The orange and green circles represent the send (request) transaction and receive (response) transaction initiated by the Vite VM, respectively.</p> <p>As we can see, the compiler translates each <code>await</code> expression into a set of instructions in the same pattern: inserting a <code>synccall</code> instruction, a <code>stop</code> instruction, a jump dest tag (a <code>jumpdest</code> instruction), and a <code>callbackdest</code> instruction.</p> <p>Essentially, the Vite VM treats the <code>synccall</code> instruction as an interrupt, which is a request for the VM to interrupt currently executing code, save its context, and initiate an asynchronous request transaction.</p> <p>Correspondingly, before receiving a callback and resuming execution, the execution context needs to be restored by executing the <code>callbackdest</code> instruction.</p> <p>This pattern is known as context switch. In a multi-task system, it refers to the process of storing the system state for a task, so that task can be paused and resumed later.</p>"},{"location":"soliditypp/advanced/vite-vm-instructions/","title":"Instructions","text":"<p>Vite VM retains semantics of most EVM instructions. However, since Vite adopts different ledger structure and transaction definition that are different from Ethereum, some EVM instructions need to be redefined, such as those to query block information.</p> <p>The instruction set in Vite VM is as follows:</p>"},{"location":"soliditypp/advanced/vite-vm-instructions/#0s-stop-and-arithmetic-operations","title":"0s: Stop and Arithmetic Operations","text":"Opcode Mnemonic POP PUSH Description Differential with EVM 0x00 STOP 0 0 Halt execution Same semantics 0x01 ADD 2 1 Add two operands Same semantics 0x02 MUL 2 1 Multiply two operands Same semantics 0x03 SUB 2 1 Subtract two operands Same semantics 0x04 DIV 2 1 Integer division operation. If the divisor is 0 then returns 0 Same semantics 0x05 SDIV 2 1 Signed integer division operation Same semantics 0x06 MOD 2 1 Modulo remainder operation Same semantics 0x07 SMOD 2 1 Signed modulo remainder operation Same semantics 0x08 ADDMOD 3 1 Modulo addition operation. Add the former two operands and modulo 3rd one Same semantics 0x09 MULMOD 3 1 Modulo multiplication operation. Multiply the former two operands and modulo 3rd one Same semantics 0x0A EXP 2 1 Exponential operation Same semantics 0x0B SIGNEXTEND 2 1 Extend length of two\u2019s complement signed integer Same semantics"},{"location":"soliditypp/advanced/vite-vm-instructions/#10s-comparison-and-bitwise-logic-operations","title":"10s: Comparison and Bitwise Logic Operations","text":"Opcode Mnemonic POP PUSH Description Differential with EVM 0x10 LT 2 1 Less-than comparison Same semantics 0x11 GT 2 1 Greater-than comparison Same semantics 0x12 SLT 2 1 Signed less-than comparison Same semantics 0x13 SGT 2 1 Signed greater-than comparison Same semantics 0x14 EQ 2 1 Equality comparison Same semantics 0x15 ISZERO 1 1 Zero or not Same semantics 0x16 AND 2 1 Bitwise AND operation Same semantics 0x17 OR 2 1 Bitwise OR operation Same semantics 0x18 XOR 2 1 Bitwise XOR operation Same semantics 0x19 NOT 1 1 Bitwise NOT operation Same semantics 0x1A BYTE 2 1 Retrieve single byte from 2nd operand Same semantics 0x1B SHL 2 1 Shift left Same semantics 0x1C SHR 2 1 Shift right Same semantics 0x1D SAR 2 1 Arithmetic shift right Same semantics"},{"location":"soliditypp/advanced/vite-vm-instructions/#20s-sha3-instruction-set","title":"20s: SHA3 Instruction Set","text":"Opcode Mnemonic POP PUSH Description Differential with EVM 0x21 BLAKE2B 2 1 Compute Blake2b hash Blake2b is the hash algorithm used in Vite. SHA3 is not provided"},{"location":"soliditypp/advanced/vite-vm-instructions/#30s-environmental-information","title":"30s: Environmental Information","text":"Opcode Mnemonic POP PUSH Description Differential with EVM 0x30 ADDRESS 0 1 Get address of currently executing account Same semantics 0x31 BALANCE 1 1 Get specific token's balance of current account Add token id as operand. This instruction should not be used to obtain balance of any other account 0x32 ORIGIN - - Get account address from which the execution is originated Not provided, Vite doesn't maintain casual relationship between inner Tx and user Tx 0x33 CALLER 0 1 Get caller address which is directly responsible for this execution Same semantics 0x34 CALLVALUE 0 1 Get transfer amount of called transaction Same semantics 0x35 CALLDATALOAD 1 1 Get input data of current call Same semantics 0x36 CALLDATASIZE 0 1 Get size of input data in current call Same semantics 0x37 CALLDATACOPY 3 0 Copy input data in current call to memory Same semantics 0x38 CODESIZE 0 1 Get size of code running in current environment Same semantics 0x39 CODECOPY 3 0 Copy code running in current environment to memory Same semantics 0x3A GASPRICE - - - Not provided, Vite doesn't charge transaction fee 0x3B EXTCODESIZE 1 1 Get size of an account\u2019s code Currently not provided 0x3C EXTCODECOPY 4 0 Copy a specific account\u2019s code to memory Currently not provided 0x3D RETURNDATASIZE 0 1 Get size of output data from the previous call Same semantics 0x3E RETURNDATACOPY 3 0 Copy output data from the previous call to memory Same semantics 0x3F EXTCODEHASH 1 1 Get the hash of an account\u2019s code Currently not provided"},{"location":"soliditypp/advanced/vite-vm-instructions/#40s-block-information","title":"40s: Block Information","text":"Opcode Mnemonic POP PUSH Description Differential with EVM 0x40 BLOCKHASH - - Get the hash of one block Not provided 0x41 COINBASE - - Get the block's beneficiary address Not provided 0x42 TIMESTAMP 0 1 Get the block\u2019s timestamp Different semantics. Return latest snapshot block timestamp 0x43 HEIGHT 0 1 Get the block\u2019s number Different semantics. Return latest snapshot block height 0x44 DIFFICULTY - - Get the block\u2019s difficulty Not provided 0x45 GASLIMIT - - Get the block\u2019s gas limit Not provided 0x46 TOKENID 0 1 Get Tx's transfer token id Additional 0x47 ACCOUNTHEIGHT 0 1 Get account block height Additional 0x48 PREVHASH 0 1 Get the hash of previous account block Additional 0x49 FROMHASH 0 1 Get the hash of request Tx Additional 0x4A SEED 0 1 Get random seed. This instruction will return the same random number in one transaction Additional 0x4B RANDOM 0 1 Get next random seed. This instruction can return different random numbers in one transaction Additional"},{"location":"soliditypp/advanced/vite-vm-instructions/#50s-stack-memory-storage-and-flow-operations","title":"50s: Stack, Memory, Storage and Flow Operations","text":"Opcode Mnemonic POP PUSH Description Differential with EVM 0x50 POP 1 0 Remove item from stack Same semantics 0x51 MLOAD 1 1 Load word from memory Same semantics 0x52 MSTORE 2 0 Save word to memory Same semantics 0x53 MSTORE8 2 0 Save byte to memory Same semantics 0x54 SLOAD 1 1 Load word from storage Same semantics 0x55 SSTORE 2 0 Save word to storage Same semantics 0x56 JUMP 1 0 Alter the program counter Same semantics 0x57 JUMPI 2 0 Conditionally alter the program counter Same semantics 0x58 PC 0 1 Get the value of the program counter Same semantics 0x59 MSIZE 0 1 Get the size of active memory in bytes Same semantics 0x5A GAS - - Get the amount of available gas Not provided 0x5B JUMPDEST 0 0 Mark a valid destination for jump instructions Same semantics"},{"location":"soliditypp/advanced/vite-vm-instructions/#60s-70s-push-operations","title":"60s &amp; 70s: Push Operations","text":"Opcode Mnemonic POP PUSH Description Differential with EVM 0x60 PUSH1 0 1 Place 1 byte item on stack Same semantics 0x61 PUSH2 0 1 Place 2-byte item on stack Same semantics ... ... ... ... ... ... 0x7F PUSH32 0 1 Place 32-byte (full word) item on stack Same semantics"},{"location":"soliditypp/advanced/vite-vm-instructions/#80s-duplication-operations","title":"80s: Duplication Operations","text":"Opcode Mnemonic POP PUSH Description Differential with EVM 0x80 DUP1 1 2 Duplicate 1st stack item Same semantics 0x81 DUP2 2 3 Duplicate 2nd stack item Same semantics ... ... ... ... ... ... 0x8F DUP16 16 17 Duplicate 2nd stack item Same semantics"},{"location":"soliditypp/advanced/vite-vm-instructions/#90s-exchange-operations","title":"90s: Exchange Operations","text":"Opcode Mnemonic POP PUSH Description Differential with EVM 0x90 SWAP1 2 2 Exchange 1st and 2nd stack items Same semantics 0x91 SWAP2 3 3 Exchange 1st and 3rd stack items Same semantics ... ... ... ... ... ... 0x9F SWAP16 17 17 Exchange 1st and 17th stack items Same semantics"},{"location":"soliditypp/advanced/vite-vm-instructions/#a0s-logging-operations","title":"a0s: Logging Operations","text":"Opcode Mnemonic POP PUSH Description Differential with EVM 0xA0 LOG0 2 0 Append log record with no topics Same semantics 0xA1 LOG1 3 0 Append log record with one topic Same semantics ... ... ... ... ... ... 0xA4 LOG4 6 0 Append log record with four topics Same semantics"},{"location":"soliditypp/advanced/vite-vm-instructions/#f0s-system-operations","title":"f0s:  System Operations","text":"Opcode Mnemonic POP PUSH Description Differential with EVM 0xF0 CREATE - - Create a new contract Not provided 0xF1 CALL 5 0 Call another contract Call another contract asynchronously with no return value 0xF2 CALLCODE - - Change current account's status with calling an alternative contract\u2019s code Not provided 0xF3 RETURN 2 0 Halt execution and return output data Same semantics 0xF4 DELEGATECALL 6 1 Call another contract's code, change contract and current account's status but persisting the original transaction info Not provided 0xFA STATICCALL - - Call another contract, not allowed to change the status Not provided 0xFD REVERT 2 0 Halt execution, recover status and return output data Same semantics 0xFF SELFDESTRUCT 1 0 Halt execution, set contract status as later deletion and return all of the balances Not provided"},{"location":"soliditypp/advanced/vite-vm/","title":"Vite VM","text":"<p>Vite VM (Virtual Machine) retains the semantics of most EVM instructions, but is not a clone of EVM. Therefore, new instructions such as <code>synccall</code> and <code>callbackdest</code> need to be implemented from scratch, and some EVM instructions such as <code>return</code>, <code>returndatasize</code>, <code>returndatacopy</code> need to be reimplemented to adapt to the Vite protocol.</p>"},{"location":"soliditypp/advanced/vite-vm/#transaction-types","title":"Transaction Types","text":"<p>Three new transaction types are added in Vite VM:</p> <ul> <li>SendSyncCall: A send transaction initiated by a synchronous call,</li> <li>SendCallback: A send transaction initiated by a callback that successfully executes and returns a result.</li> <li>SendFailureCallback: A send transaction initiated by a callback that fails to execute and returns an error.</li> </ul>"},{"location":"soliditypp/advanced/vite-vm/#execution-context","title":"Execution Context","text":"<p>Each transaction with one of the three new types contains an execution context data stored in the database.</p> <p>The execution context is defined as follows:</p> <pre><code>ExecutionContext {\n    referrer types.Hash\n    callback big.Int\n    stack  []big.Int\n    memory []byte\n}\n</code></pre> <p>For a <code>SendSyncCall</code> transaction, its execution context includes: - <code>referrer</code> holds the send transaction hash of the upstream (origin) sync call. - <code>callback</code> holds the 4-bytes method id of the callback function entry. - <code>stack</code> holds a snapshot of the contract stack at the time <code>synccall</code> is executed. - <code>memory</code> holds a snapshot of the contract memory at the time <code>synccall</code> is executed.</p> <p>For a <code>SendCallback</code> or a <code>SendFailureCallback</code> transaction, its execution context only includes a <code>referrer</code> field: - <code>referrer</code> holds the send transaction hash of the latest sync call.</p> <p>Note: <code>referrer</code> could look a bit confusing, see the example below\uff1a</p> <p></p>"},{"location":"soliditypp/advanced/vite-vm/#synccall-instruction","title":"SyncCall Instruction","text":"<p>The <code>synccall</code> instruction is implemented in pseudocode as follows:</p> <pre><code>func opSynccall() {\n    callback, toAddress, tokenID, amount, inOffset, inSize := vm.stack.pop(6)\n    calldata := vm.mem.get(inOffset, inSize)\n\n    if vm.Context.originSendBlock == nil {\n        // upstream call\n        origin := this.sendBlock\n    } else {\n        // load origin from VM context, it was saved by previous callbackdest\n        origin := vm.Context.Origin\n    }\n\n    tx := ViteRequestTransaction {\n        from: this.address,\n        to: toAddress,\n        type: SendSyncCall,\n        value: amount,\n        token: tokenID,\n        data: calldata\n        executionContext: ExecutionContext {\n            referrer: origin.Hash,\n            callback: callback,\n            stack: vm.stack,\n            memory: vm.memory,\n        }\n    }\n\n    vite.trigger(tx)\n}\n</code></pre>"},{"location":"soliditypp/advanced/vite-vm/#return-instruction","title":"Return Instruction","text":"<p>The <code>return</code> instruction is implemented in pseudocode as follows:</p> <pre><code>func opReturn() {\n    offset, size := vm.stack.pop(2)\n    ret := vm.mem.get(offset, size)\n\n    sendType := this.sendBlock.BlockType\n    // need to trigger a callback transaction\n    if sendType == SendSyncCall || sendType == SendCallback || sendType == SendFailureCallback {\n        // get the send-block of the original call\n        if vm.Context.Origin == nil {\n            // the return statement is not in a callback function\n            // so origin is the latest send transaction\n            origin := this.sendBlock\n        } else {\n            // the return statement is in a callback function\n            // load origin from VM context, it was saved by previous callbackdest\n            origin := vm.Context.Origin\n        }\n\n        if origin.BlockType == SendSyncCall {\n            callback := origin.executionContext.callback\n            // calldata of the callback: [callback_id][return_data]\n            data := concat(callback, ret)\n\n            tx := ViteRequestTransaction {\n                from: this.address,\n                to: origin.address,\n                type: SendCallback,\n                data: data,\n                executionContext: ExecutionContext {\n                    referrer: origin.Hash,\n                }\n            }\n\n            vite.trigger(tx)\n        }\n    }\n}\n</code></pre>"},{"location":"soliditypp/advanced/vite-vm/#callbackdest-instruction","title":"CallbackDest Instruction","text":"<p>The <code>callbackdest</code> instruction is implemented in pseudocode as follows:</p> <pre><code>func opCallbackDest() {\n    sendType := this.sendBlock.BlockType\n    if sendType == SendCallback || sendType == SendFailureCallback {\n        referrer := this.sendBlock.executionContext.referrer\n\n        // validate sync call send block\n        if referrer.address != this.address || referrer.ToAddress != this.sendBlock.address {\n            return nil, error\n        }\n\n        // get upstream origin send block\n        origin := referrer.executionContext.referrer\n\n        // validate origin send block\n        if origin.ToAddress != this.address {\n            return nil, error\n        }\n\n        // save origin send block to VM context\n        vm.Context.Origin = origin\n\n        // restore stack\n        vm.stack = referrer.executionContext.stack\n\n        // push success flag (act as RETURN instruction in EVM)\n        if sendType == SendCallback {\n            // push true\n            stack.push(1)\n        } else { // sendType == SendFailureCallback\n            // push false\n            stack.push(0)\n        }\n\n        // restore memory\n        vm.memory = referrer.executionContext.memory\n    }\n}\n</code></pre>"},{"location":"soliditypp/advanced/vite-vm/#advanced-example","title":"Advanced example","text":"Show  ### Objectives  ![dissect the code](./assets/vite-vm-02.png)  ### Solidity Compiler and EVM  Pseudo assembly code for contract `A`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(add)\n    jump(tag_function_add)\nelse\n    fallback()\nstop\n\ntag_function_add:\na, b := abi_decode(calldata)\ntmp := checked_add(a, b)\nret := abi_encode(tmp)\nreturn(ret)\n</code></pre>  Pseudo assembly code for contract `B`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(sum)\n    jump(tag_function_sum)\nelse\n    fallback()\nstop\n\ntag_function_sum:\na, b, c := abi_decode(calldata)\ncontract_address := contractA\nmethod_id := sig_hash(add)\nparams := abi_encode(a, b)\ncall(contract_address, method_id, params)\npartialResult := abi_decode(returndata)\nparams := abi_encode(partialResult, c)\ncall(contract_address, method_id, params)\nret := abi_decode(returndata)\nreturn(ret)\n</code></pre>  Pseudo assembly code for contract `C`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(test)\n    jump(tag_function_test)\nelse\n    fallback()\nstop\n\ntag_function_test:\ncontract_address := contractB\nmethod_id := sig_hash(sum)\nparams := abi_encode(1, 2, 3)\ncall(contract_address, method_id, params)\nret := abi_decode(returndata)\ndata = ret\nreturn\n</code></pre>  ![compiled from solidity](./assets/vite-vm-03.png)  ### Solidity++ Compiler  Pseudo assembly code for contract `A`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(add)\n    jump(tag_function_add)\nelse\n    fallback()\nstop\n\ntag_function_add:\na, b := abi_decode(calldata)\ntmp := checked_add(a, b)\nret := abi_encode(tmp)\nreturn(ret)\n</code></pre>  Pseudo assembly code for contract `B`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(sum)\n    jump(tag_function_sum)\nelse if method_id == 0x00000001\n    jump(tag_callback_01)\nelse if method_id == 0x00000002\n    jump(tag_callback_02)\nelse\n    fallback()\nstop\n\ntag_function_sum:\na, b, c := abi_decode(calldata)\ncontract_address := contractA\nmethod_id := sig_hash(add)\nparams := abi_encode(a, b)\ncallback_id := 0x00000001\nsynccall(contract_address, method_id, params, callback_id)\nstop\n\ntag_callback_01:\ncallbackdest\np := abi_decode(calldata)\ncontract_address := contractA\nmethod_id := sig_hash(add)\nparams := abi_encode(p, c)\ncallback_id := 0x00000002\nsynccall(contract_address, method_id, params, callback_id)\nstop\n\ntag_callback_02:\ncallbackdest\nret := abi_decode(calldata)\nreturn(ret)\n</code></pre>  Pseudo assembly code for contract `C`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(test)\n    jump(tag_function_test)\nelse if method_id == 0x00000001\n    jump(tag_callback_01)\nelse\n    fallback()\nstop\n\ntag_function_test:\ncontract_address := contractB\nmethod_id := sig_hash(sum)\nparams := abi_encode(1, 2, 3)\ncallback_id := 0x00000001\nsynccall(contract_address, method_id, params, callback_id)\nstop\n\ntag_callback_01:\ncallbackdest\nret := abi_decode(calldata)\nreturn(ret)\n</code></pre>  ![compiled from soliditypp](./assets/vite-vm-04.png)  ### Vite VM  ![referrer](./assets/vite-vm-05.png)"},{"location":"soliditypp/compiler/","title":"Index","text":"<p>order: false parent:     title: Compiler     order: 2</p>"},{"location":"soliditypp/compiler/solppc-js/","title":"solppc-js","text":"<p><code>solppc-js</code> is a JavaScript binding for the Solidity++ compiler.</p>"},{"location":"soliditypp/compiler/solppc-js/#how-to-install-solppc-js","title":"How to Install solppc-js","text":"<p>Install the latest stable version of the Solidity++ compiler from npm:</p> <pre><code>npm install solppc\n</code></pre>"},{"location":"soliditypp/compiler/solppc-js/#usage-in-command-line","title":"Usage in Command-Line","text":"<p>If this package is installed globally (<code>npm install -g solppc</code>), a command-line tool called <code>solppcjs</code> will be available.</p> <p>To see all the supported features, execute:</p> <pre><code>solppcjs --help\n</code></pre> <p>To compile a contract that imports other contracts via relative paths: <pre><code>solppcjs --bin --include-path node_modules/ --base-path . MainContract.solpp\n</code></pre> Use the <code>--base-path</code> and <code>--include-path</code> options to describe the layout of your project.</p> <ul> <li><code>--base-path</code> represents the root of your own source tree </li> <li><code>--include-path</code> specifies extra locations containing external code (e.g. libraries installed with a package manager).</li> </ul> <p>Note: make sure all the files you specify in the command are located inside the base path or one of the include paths. The compiler refers to files from outside of these directories using absolute paths. Having absolute paths in contract metadata will result in your bytecode being reproducible only when it's placed in these exact absolute locations.</p> <p>Note: this command line interface is not compatible with <code>solppc</code> provided by the Solidity++ compiler package. Please refer to the solppc chapter for instructions to install <code>solppc</code>. Furthermore, the command line interface of solppc-js provides less features than the binary release.</p>"},{"location":"soliditypp/compiler/solppc-js/#usage-in-projects","title":"Usage in Projects","text":"<p>There are two ways to use <code>solppc</code>:</p> <ol> <li>Through a high-level API giving a general interface to all compiler versions</li> <li>Through a low-level API giving access to all the compiler interfaces and choose the version of the compiler</li> </ol>"},{"location":"soliditypp/compiler/solppc-js/#high-level-api","title":"High-level API","text":"<p>The high-level API consists of a single method, <code>compile</code>, which conforms to Compiler Standard Input and Output JSON.</p> <p>It also accepts an optional set of callback functions, which include the <code>import</code> and the <code>smtSolver</code> callbacks. Starting from 0.6.0 it only accepts an object in place of the callback to supply the callbacks.</p> <p>The <code>import</code> callback function is used to resolve unmet dependencies. This callback receives a path and must synchronously return either an error or the content of the dependency as a string.  It cannot be used together with callback-based, asynchronous, filesystem access. A workaround is to collect the names of dependencies, return an error, and keep re-running the compiler until all dependencies are resolved.</p>"},{"location":"soliditypp/compiler/solppc-js/#example-usage-without-the-import-callback","title":"Example usage without the import callback","text":"<p>Example:</p> <pre><code>var solppc = require('solppc');\n\nvar input = {\n  language: 'Solidity',\n  sources: {\n    'test.solpp': {\n      content: 'contract C { function f() public async { } }'\n    }\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*']\n      }\n    }\n  }\n};\n\nvar output = JSON.parse(solppc.compile(JSON.stringify(input)));\n\n// `output` here contains the JSON output as specified in the documentation\nfor (var contractName in output.contracts['test.solpp']) {\n  console.log(\n    contractName +\n      ': ' +\n      output.contracts['test.solpp'][contractName].evm.bytecode.object\n  );\n}\n</code></pre>"},{"location":"soliditypp/compiler/solppc-js/#example-usage-with-import-callback","title":"Example usage with import callback","text":"<pre><code>var solppc = require('solppc');\n\nvar input = {\n  language: 'Solidity',\n  sources: {\n    'test.solpp': {\n      content: 'import \"lib.solpp\"; contract C { function f() public sync { L.f(); } }'\n    }\n  },\n  settings: {\n    outputSelection: {\n      '*': {\n        '*': ['*']\n      }\n    }\n  }\n};\n\nfunction findImports(path) {\n  if (path === 'lib.solpp')\n    return {\n      contents:\n        'library L { function f() internal returns (uint) { return 7; } }'\n    };\n  else return { error: 'File not found' };\n}\n\n// New syntax (supported from 0.5.12, mandatory from 0.6.0)\nvar output = JSON.parse(\n  solppc.compile(JSON.stringify(input), { import: findImports })\n);\n\n// `output` here contains the JSON output as specified in the documentation\nfor (var contractName in output.contracts['test.solpp']) {\n  console.log(\n    contractName +\n      ': ' +\n      output.contracts['test.solpp'][contractName].evm.bytecode.object\n  );\n}\n</code></pre> <p>The <code>smtSolver</code> callback function is used to solve SMT queries generated by Solidity's SMTChecker. In case you have an SMT solver installed locally, it can be used to solve the given queries, where the callback must synchronously return either an error or the result from the solver. A default <code>smtSolver</code> callback is distributed by <code>solppc-js</code>, which relies on either Z3 or CVC4 being installed locally.</p>"},{"location":"soliditypp/compiler/solppc-js/#example-usage-with-smtsolver-callback","title":"Example usage with smtSolver callback","text":"<p><pre><code>var solppc = require('solppc');\nvar smt = require('smtsolver');\n// Note that this example only works via node and not in the browser.\n\nvar input = {\n  language: 'Solidity',\n  sources: {\n    'test.solpp': {\n      content: 'pragma experimental SMTChecker; contract C { function f(uint x) public async { assert(x &gt; 0); } }'\n    }\n  }\n};\n\nvar output = JSON.parse(\n  solppc.compile(JSON.stringify(input), { smtSolver: smt.smtSolver })\n);\n</code></pre> The assertion is clearly false, and an <code>assertion failure</code> warning should be returned.</p>"},{"location":"soliditypp/compiler/solppc-js/#low-level-api","title":"Low-level API","text":"<p>The low-level API is as follows:</p> <ul> <li><code>solppc.lowlevel.compileSingle</code>: the original entry point, supports only a single file</li> <li><code>solppc.lowlevel.compileMulti</code>: supports multiple files, introduced in 0.1.6</li> <li><code>solppc.lowlevel.compileCallback</code>: supports callbacks, introduced in 0.2.1</li> <li><code>solppc.lowlevel.compileStandard</code>: works just like <code>compile</code> above, but is only present in compilers after (and including) 0.4.11</li> </ul> <p>For examples how to use them, please refer to the README of the above mentioned solppc-js releases.</p>"},{"location":"soliditypp/compiler/solppc-js/#linking-bytecode","title":"Linking Bytecode","text":"<p>When using libraries, the resulting bytecode will contain placeholders for the real addresses of the referenced libraries. These have to be updated, via a process called linking, before deploying the contract.</p> <p>The <code>linker</code> module (<code>require('solppc/linker')</code>) offers helpers to accomplish this.</p> <p>The <code>linkBytecode</code> method provides a simple helper for linking:</p> <pre><code>var linker = require('solppc/linker');\n\nbytecode = linker.linkBytecode(bytecode, { MyLibrary: 'vite_01020304050607...' });\n</code></pre> <p>As of Solidity 0.4.11 the compiler supports standard JSON input and output which outputs a link references map. This gives a map of library names to offsets in the bytecode to replace the addresses at. It also doesn't have the limitation on library file and contract name lengths.</p> <p>There is a method available in the <code>linker</code> module called <code>findLinkReferences</code> which can find such link references in bytecode produced by an older compiler:</p> <pre><code>var linker = require('solppc/linker');\n\nvar linkReferences = linker.findLinkReferences(bytecode);\n</code></pre>"},{"location":"soliditypp/compiler/solppc-js/#browser-usage","title":"Browser Usage","text":"<p>Add the version of <code>solppc</code> you want to use into <code>index.html</code>:</p> <pre><code>&lt;script\n  type=\"text/javascript\"\n  src=\"https://github.com/vitelabs/soliditypp/releases/download/latest/soljson.js\"\n&gt;&lt;/script&gt;\n</code></pre> <p>This will load <code>solppc</code> into the global variable <code>window.Module</code>. Then use this inside Javascript as:</p> <pre><code>var wrapper = require('solppc/wrapper');\nvar solppc = wrapper(window.Module);\n</code></pre> <p>Or in ES6 syntax:</p> <pre><code>import * as wrapper from 'solppc/wrapper';\nconst solppc = wrapper(window.Module);\n</code></pre>"},{"location":"soliditypp/compiler/solppc/","title":"solppc","text":"<p><code>solppc</code> is the binary release of Solidity++ compiler.</p> <p>TODO</p>"},{"location":"soliditypp/fundamentals/","title":"Introduction","text":"<p>Solidity++ is a programming language for creating smart contracts on the Vite blockchain. Solidity++ is derived from Solidity and embraces Solidity's underlying message passing infrastructure. Solidity++ has an asynchronous design that works well with Vite's high-throughput DAG-based ledger.</p>"},{"location":"soliditypp/fundamentals/#solidity-features","title":"Solidity++ Features","text":"<ul> <li>Based on Solidity; easy to learn and to port existing contracts.</li> <li>Asynchronous design allows for high throughput on DAG-based blockchains.</li> <li>Secure by default against reentrancy and flash-loan attacks.</li> <li>Support for native tokens, random numbers, scheduled tasks and more.</li> <li>Vite's zero-fee feature (enabled by a lock-for-quota system) enables new possibilities for dApps.</li> </ul> <p>We assume that you are already familiar with Solidity, if not, please read Solidity v0.8.x documentation before starting.</p>"},{"location":"soliditypp/fundamentals/abi/","title":"ABI","text":"<p>The Contract Application Binary Interface (ABI) is the standard way to interact with contracts in the Vite ecosystem, both from outside the blockchain and for contract-to-contract interaction. Data is encoded according to its type, as described in this specification. The encoding is not self describing and thus requires a schema in order to decode.</p> <p>We assume the interface functions of a contract are strongly typed, known at compilation time and static. We assume that all contracts will have the interface definitions of any contracts they call available at compile-time.</p> <p>This specification does not address contracts whose interface is dynamic or otherwise known only at run-time.</p>"},{"location":"soliditypp/fundamentals/abi/#function-selector","title":"Function Selector","text":"<p>The first four bytes of the call data for a function call specifies the function to be called. It is the first (left, high-order in big-endian) four bytes of the blake2b hash of the signature of the function. The signature is defined as the canonical expression of the basic prototype without data location specifier, i.e. the function name with the parenthesised list of parameter types. Parameter types are split by a single comma - no spaces are used.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.0;\n\ncontract Foo {\n    function baz(uint32 x, bool y) public pure returns (bool r) { r = x &gt; 32 || y; }\n}\n</code></pre> <p>Given the contract above the <code>baz</code> function would be represented as <code>0x921bcc0e</code> which is the so called Method ID. This is derived as the first 4 bytes of the blake2b hash of the ASCII form of the signature <code>baz(uint32,bool)</code>.</p>"},{"location":"soliditypp/fundamentals/abi/#argument-encoding","title":"Argument Encoding","text":"<p>Starting from the fifth byte, the encoded arguments follow. This encoding is also used in other places, e.g. the return values and also event arguments are encoded in the same way, without the four bytes specifying the function.</p> <ul> <li><code>address</code>: equivalent to <code>uint168</code>, except for the assumed interpretation and language typing.</li> <li><code>vitetoken</code>: equivalent to <code>uint80</code>, except for the assumed interpretation and language typing.</li> <li><code>tokenId</code>: alias of <code>vitetoken</code></li> </ul> <p>For a complete list of types please refer to https://docs.soliditylang.org/en/v0.8.1/abi-spec.html#types</p>"},{"location":"soliditypp/fundamentals/abi/#mapping-solidity-to-abi-types","title":"Mapping Solidity++ to ABI types","text":"<p>Solidity++ supports all the types of Solidity with the same names. As with Solidity, some Solidity++ types are not supported by the ABI. The following table shows on the left column Solidity++ types that are not part of the ABI, and on the right column the ABI types that represent them.</p> Solidity++ ABI address payable <code>address</code> contract <code>address</code> enum <code>uint8</code> struct <code>tuple</code>"},{"location":"soliditypp/fundamentals/abi/#example","title":"Example","text":"<p>Given the contract:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.0;\n\ncontract Foo {\n    function bar(uint32 x, vitetoken t) public pure returns (bool r) { r = x &gt; 32; }\n}\n</code></pre> <p>Thus for our <code>Foo</code> example if we wanted to call <code>bar</code> with the parameters <code>123</code> and <code>tti_564954455820434f494e69b5</code>, we would pass 68 bytes total, which can be broken down into:</p> <ul> <li><code>0x176d9ecf</code>: the Method ID. This is derived as the first 4 bytes of the blake2b hash of the ASCII form of the signature <code>bar(uint32,vitetoken)</code>.</li> <li><code>0x000000000000000000000000000000000000000000000000000000000000007B</code>: the first parameter,   a uint32 value <code>123</code> padded to 32 bytes</li> <li><code>0x00000000000000000000000000000000000000000000564954455820434f494e</code>: the second parameter,    a uint80 value <code>0x564954455820434f494e</code> padded to 32 bytes</li> </ul> <p>In total:</p> <pre><code>0x176d9ecf000000000000000000000000000000000000000000000000000000000000007B00000000000000000000000000000000000000000000564954455820434f494e\n</code></pre> <p>It returns a single <code>bool</code>. If, for example, it were to return <code>false</code>, its output would be the single byte array <code>0x0000000000000000000000000000000000000000000000000000000000000000</code>, a single bool.</p> <p>For more examples please refer to https://docs.soliditylang.org/en/v0.8.1/abi-spec.html</p>"},{"location":"soliditypp/fundamentals/callbacks/","title":"Callbacks","text":"<p>Composability is one of the core features of a decentralized ecosystem, that is, one smart contract can interact with others in unlimited combinations. So that developers can stack smart contracts on top of one another like Lego.</p> <p>To achieve composability, smart contract programming languages must be designed to make it easier for contracts to talk to each other.</p> <p>Solidity on EVM makes contracts inherently composable through synchronous external function calls and the ABI specification.</p> <p>But for Solidity++ on Vite, things are not that simple. Because Vite is an asynchronous blockchain, calls to smart contracts on Vite are also asynchronous, that is, the return value cannot be obtained immediately after the call. Therefore, the composability can only be achieved through the callback functions in the early version of Solidity++ (before 0.8.1).</p> <p>Let's examine the following example: * Contract <code>A</code> has an <code>add()</code> method that returns the sum of two unsigned integers. * Contract <code>B</code> has a <code>test()</code> method that calculates the sum of <code>1</code> and <code>2</code> by calling <code>A.add()</code>, and stores the result in the storage variable <code>data</code>.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.0;\n\ncontract A {\n    function add(uint a, uint b, function(uint) external callback) external {\n        if (callback.address != address(0)) {\n            // send callback to return data to the caller\n            callback(a + b);\n        }\n    }\n}\n\ncontract B {\n    A contractA;\n    uint public data;\n\n    constructor (address addr) {\n        contractA = A(addr);\n    }\n\n    function test() external {\n        contractA.add(1, 2, this.callback_onAdd);\n    }\n\n    function callback_onAdd(uint result) external {\n        // receive data from the called contract\n        require(msg.sender == address(contractA));\n        data = result;\n    }\n}\n</code></pre> <p>We add an additional parameter <code>callback</code> of type <code>function(uint) external</code> to <code>A.add()</code>.</p> <p>When contract <code>B</code> calls contract <code>A</code>, it needs to pass the callback function <code>this.callback_onAdd</code> as an argument of <code>A.add()</code>.</p> <p>Contract <code>A</code> can obtain the address of the caller and the selector of the callback function through the <code>callback</code> parameter. It puts the result of <code>a + b</code> in the first argument and initiates a call to the <code>callback</code> function to return data to <code>B</code>.</p> <p>In the callback function <code>callback_onAdd()</code> of contract <code>B</code>, it gets the result of <code>A.add()</code> from the parameter <code>result</code> and assigns it to the storage variable <code>data</code>.</p> <p>The next example is the same as introduced in the Sync / Async Functions chapter but using a callback function:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.0;\n\ncontract A {\n    function add(uint a, uint b, function(uint) external callback) external {\n        if (callback.address != address(0)) {\n            // send callback to return data to the caller\n            callback(a + b);\n        }\n    }\n}\n\ncontract B {\n    A contractA;\n    uint public total;\n\n    constructor (address addr) {\n        contractA = A(addr);\n    }\n\n    function invoke(uint a, uint b) external {\n        contractA.add(a, b, this.sum);\n    }\n\n    function sum(uint result) external {\n        total += result;\n    }\n}\n</code></pre> <p>It works fine and the code doesn't look too complicated, no pain at all, right? Once the call stack gets deeper, you will find yourself in the Callback Hell: Using low-level callbacks makes code difficult to write and understand. It also increases the difficulty of identifying the control flow for a contract.</p> <p>The maximum depth of call stack for Solidity++ is 512.</p>"},{"location":"soliditypp/fundamentals/error-handling/","title":"Error Handling (assert / require / revert / try-catch)","text":"<p>Solidity++ uses state-reverting exceptions to handle errors. Such an exception undoes all changes made to the state in the current call (and all its sub-calls) and flags an error to the caller.</p> <p>Error propagation through <code>revert</code> and <code>try/catch</code> will be supported in v0.8.1.</p> <p><code>assert(bool condition)</code></p> <p>causes a Panic error and thus state change reversion if the condition is not met - to be used for internal errors.</p> <p><code>require(bool condition)</code></p> <p>reverts if the condition is not met - to be used for errors in inputs or external components.</p> <p><code>require(bool condition, string memory message)</code></p> <p>reverts if the condition is not met - to be used for errors in inputs or external components. Also provides an error message.</p> <p><code>revert()</code></p> <p>abort execution and revert state changes</p> <p><code>revert(string memory reason)</code></p> <p>abort execution and revert state changes, providing an explanatory string</p> <p>The following example shows how to use an error string together with <code>revert</code> and the equivalent <code>require</code>:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.0;\n\ncontract VendingMachine {\n    function buy(uint amount) public payable {\n        if (amount &gt; msg.value)\n            revert(\"Not enough Vite provided.\");\n        // Alternative way to do it:\n        require(\n            amount &lt;= msg.value,\n            \"Not enough Vite provided.\"\n        );\n        // Perform the purchase.\n    }\n}\n</code></pre> <p>If you provide the reason string directly, then the two syntax options are equivalent, it is the developer's preference which one to use.</p> <p>For more examples please refer to https://docs.soliditylang.org/en/v0.8.1/control-structures.html?highlight=panic#error-handling-assert-require-revert-and-exceptions</p>"},{"location":"soliditypp/fundamentals/event-subscription/","title":"Event Subscription","text":"<p>In Vite, events are notifications triggered by virtual machine to indicate state change and will be pushed to front-end program such as dApp for further processing. A <code>vmlog</code> will be created in the smart contract's response block when event is triggered.</p> <p>Taking the following contract as example, when function <code>transferWithEvent</code> is called, the contract transfers the token received to specified address and then triggers a <code>TransferEvent</code> event.</p> <pre><code>pragma soliditypp ^0.8.0;\ncontract TransferContract {\n   event TransferEvent(address indexed addr, uint256 value, vitetoken tokenid);\n\n   function transferWithEvent(address payable addr) external payable {\n      addr.transfer(msg.token ,msg.value);\n      emit TransferEvent(addr, msg.value, msg.token);      \n   }\n}\n</code></pre> <p>The <code>TransferEvent</code> event contains the following content: * The hash of contract response block in which the event was created. This information can be used to retrieve contract address, contract account block height, request transaction hash and so on. * Event signature as the hash of <code>TransferEvent(address,uint256,tokenId)</code>. * Indexed parameters, which are marked as <code>indexed</code> in event definition. Up to 3 indexed parameters can be defined in an event. Event signature and indexed parameters are stored in <code>topics</code> field of <code>vmlog</code>, where <code>topics[0]</code> is occupied by event signature. * Non-indexed parameters having no <code>indexed</code> marked. Non-indexed parameters are stored in <code>data</code> field of <code>vmlog</code>.</p> <p>Below is an example of event logged on the blockchain when sending 1 VITE to <code>vite_9990375e0eaf10426d1d1f9b528b6dee158fd3adb0e1b9de70</code> <pre><code>{\n    \"vmlog\": {\n        \"topics\": [\n            \"b94af1d4b8401b8201545e8211b72d72169050f6694be63e2f6ede119725d7fd\",\n            \"00000000000000000000009990375e0eaf10426d1d1f9b528b6dee158fd3ad00\"\n        ],\n        \"data\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADeC2s6dkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVklURSBUT0tFTg==\"\n    },\n    \"accountBlockHash\": \"67bc57f99a3b333b81d6007eecd1bb2409d92b3ad65a8452fd4aef31edfe9831\",\n    \"accountBlockHeight\": \"6\",\n    \"address\": \"vite_79ac3daebdfed6947c0aaeacd418eadf38a94dddefbd4acec1\",\n    \"removed\": false\n}\n</code></pre></p>"},{"location":"soliditypp/fundamentals/event-subscription/#event-subscription_1","title":"Event Subscription","text":"<p>If a certain event is subscribed to, the subscriber will be notified when this certain event occurs.  For example, if you subscribe to <code>TransferEvent</code> of <code>TransferContract</code>, you will receive a notification when <code>transferWithEvent</code> method is called.</p> <p>Event subscription can be used to listen to contract state changes or new transactions on blockchain.</p> <p>Note: It's only allowed to listen to events that have not occurred yet. Historical events cannot be monitored but can only be fetched through Ledger API.</p> <p>The following parameters need to be specified when subscribing to an event: * Contract address. Required. * Contract account height range. Optional. By this parameter, it's possible to subscribe to events happening within a certain height range. * Event signature or indexed parameter. Optional. For example, you can subscribe to events that transfer to certain accounts.</p> <p>For more information, see Subscription API and <code>newVmLog</code></p>"},{"location":"soliditypp/fundamentals/function-call-options/","title":"Function Call Options","text":"<p>When calling functions of other contracts, you can specify the amount of a specific token to send, with the call options: <code>{token: \"tti_564954455820434f494e69b5\", value: 1e18}</code>.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0;\n\ncontract InfoFeed {\n    function getBalance(vitetoken token) external view returns (uint256) {\n        return balance(token);\n    }\n\n    function info() external payable returns (uint ret) {\n        return 42;\n    }\n}\n\ncontract Consumer {\n    InfoFeed feed;\n\n    constructor (address payable addr) {\n        feed = InfoFeed(addr);\n    }\n\n    function callFeed() external {\n        // send 1 VX with the call\n        feed.info{token: \"tti_564954455820434f494e69b5\", value: 1e18}();\n    }\n}\n</code></pre> <p>If the <code>token</code> call option is omitted, the VITE token is sent by default.</p> <p>The following code: <pre><code>feed.info{value: 1e18}();\n</code></pre> is equivalent to: <pre><code>feed.info{token: \"tti_5649544520544f4b454e6e40\", value: 1e18}();\n</code></pre></p> <p>Note</p> <p>The <code>gas</code>,<code>salt</code> keys in a call option are not supported in Solidity++.</p>"},{"location":"soliditypp/fundamentals/global-variables/","title":"Global Variables, Functions and Members","text":"<p>There are special variables and functions which always exist in the global namespace and are mainly used to provide information about the blockchain or are general-use utility functions. </p>"},{"location":"soliditypp/fundamentals/global-variables/#block-and-transaction-properties","title":"Block and Transaction Properties","text":"<ul> <li><code>block.number</code> (<code>uint</code>): current snapshot block height</li> <li><code>block.timestamp</code> (<code>uint</code>): current snapshot block timestamp as seconds since unix epoch</li> <li><code>msg.data</code> (<code>bytes calldata</code>): complete calldata</li> <li><code>msg.sender</code> (<code>address</code>): sender of the message (current call)</li> <li><code>msg.sig</code> (<code>bytes4</code>): first four bytes of the calldata (i.e. function identifier)</li> <li><code>msg.value</code> (<code>uint</code>): amount of a specific token sent with the message</li> <li><code>tx.origin</code> (<code>address</code>): sender of the transaction (full call chain)</li> </ul> <p>Strictly speaking, due to the asynchronous nature of Vite, <code>block.number</code> and <code>block.timestamp</code> returns the result of the snapshot block that the request transaction was included in, NOT precisely the current snapshot block.  </p> <p>The following are available in Solidity but not in Solidity++:</p> <pre><code>blockhash(_blockNumber);\nblock.chainid;\nblock.coinbase;\nblock.difficulty;\nblock.gaslimit;\nblockhash(param);\ngasleft();\nmsg.gas;\ntx.gasprice;\nselfdestruct(_owner);\nsuicide(_addr);\n</code></pre> <p>To support additional Vite features, Solidity++ has been extended with the following functions and members:</p> <ul> <li><code>fromhash() returns (bytes32)</code>: hash of the request transaction</li> <li><code>prevhash() returns (bytes32)</code>: hash of the latest block on the contract's account chain</li> <li><code>accountheight() returns (uint)</code>: height of the latest block on the contract's account chain</li> <li><code>random64() returns (uint64)</code>: random number (returns the same random number in one transaction)</li> <li><code>nextrandom() returns (uint64)</code>: random number (can be called multiple times to obtain different random numbers in one transaction)</li> <li><code>balance(vitetoken) returns (uint256)</code>: balance of the contract for the specified vitetoken</li> <li><code>msg.token</code> (<code>vitetoken</code>): token identifier sent with the message</li> <li><code>payable(address).transfer(vitetoken, uint256)</code>: sends some amount of a specific token to an address</li> <li><code>blake2b(bytes memory) returns (bytes32)</code>: computes the BLAKE2b hash of the input</li> </ul> <p>For a complete list please refer to https://docs.soliditylang.org/en/v0.8.1/units-and-global-variables.html#special-variables-and-functions</p>"},{"location":"soliditypp/fundamentals/inline-assembly/","title":"Inline Assembly","text":"<p>Since v0.8.0 inline assembly and Yul are available in Solidity++. You can interleave statements with inline assembly in a language close to the one of the Vite virtual machine. This gives you more fine-grained control, which is especially useful when you would like to reduce the quota consumed to execute a transaction or if you are enhancing the language by writing libraries.</p> <p>The language used for inline assembly in Solidity++ is called Yul and it is documented here. This section will only cover how the inline assembly code can interface with the surrounding Solidity++ code.</p> <p>Inline assembly is a way to access the Vite Virtual Machine at a low level. This bypasses several important safety features and checks of Solidity. You should only use it for tasks that need it, and only if you are confident with using it.</p> <p>An inline assembly block is marked by <code>assembly { ... }</code>, where the code inside the curly braces is code in the Yul language.</p> <p>The inline assembly code can access local Solidity variables as explained below.</p> <p>Different inline assembly blocks share no namespace, i.e. it is not possible to call a Yul function or access a Yul variable defined in a different inline assembly block.</p> <p>The following example multiplies the provided variable <code>x</code> with <code>b = 2</code> and returns the result:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.0;\n\ncontract C {\n    uint b = 2;\n    function f(uint x) public view returns (uint r) {\n        assembly {\n            // We ignore the storage slot offset, we know it is zero\n            // in this special case.\n            r := mul(x, sload(b.slot))\n        }\n    }\n}\n</code></pre> <p>For more examples please refer to https://docs.soliditylang.org/en/v0.8.1/assembly.html</p>"},{"location":"soliditypp/fundamentals/promise-await/","title":"Promise and Await","text":"<p>As briefly mentioned in the Sync / Async Functions chapter, Vite is a completely asynchronous blockchain with an asynchronous virtual machine (VM). All message calls on Vite are fully asynchronous.</p> <p>An asynchronous call is not blocked when waiting for the called function to return. The caller cannot get the return data immediately after the call. Instead, it gets a promise of return types. </p> <p>The promise syntax is not implemented in the current version.</p> <p>In order to make contracts written in Solidity++ as simple and straightforward as those written in Solidity, the await operator is introduced which is very similar to other modern programming languages such as JavaScript and C#.</p> <p>Awaiting a promise with <code>await</code> will be supported in v0.8.1.</p> <p>Await operator suspends evaluation of the enclosing async function until the asynchronous operation represented by its operand completes. When the asynchronous operation completes, it returns the result of the operation, if any.</p> <p>It helps you write synchronous-looking Solidity++ code that works asynchronously.</p> <p>When the example introduced in the Callback chapter is implemented with the await operator, the code will be as straightforward and concise as in Solidity:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.1;\n\ncontract A {\n    function add(uint a, uint b) external pure returns(uint) {\n        return a + b;\n    }\n}\n\ncontract B {\n    A contractA;\n    constructor (address addr) {\n        contractA = A(addr);\n    }\n\n    function sum(uint a, uint b, uint c) external view returns(uint) {\n        uint partialResult = await contractA.add(a, b);\n        return await contractA.add(partialResult, c);\n    }\n}\n\n\ncontract C {\n    B contractB;\n    uint public data;\n\n    constructor (address addr) {\n        contractB = B(addr);\n    }\n\n    function test() external {\n        data = await contractB.sum(1, 2, 3);\n    }\n}\n</code></pre>"},{"location":"soliditypp/fundamentals/randomness/","title":"Randomness","text":"<p>Random numbers are widely used in Vite.  One good case is the process to reach consensus, where a random number is chosen in each round in the purpose of determining which SBP is responsible for producing the next snapshot block, thus avoid being predicted in advance. Another scenario is in gambling games the results are generated depending on unpredictable random numbers to avoid manipulation.</p> <p>When we design the random number, it should meet the following criteria:</p> <ol> <li>Must NOT be manipulable</li> <li>Must NOT be predictable</li> </ol>"},{"location":"soliditypp/fundamentals/randomness/#random-numbers-on-vite","title":"Random Numbers on Vite","text":"<p>The design comes from the common dicing game in real world. Basically, a simple dicing game will go through the following 3 steps: 1. Dealer shakes the dice box 2. Player guesses the dice number and makes bet 3. Dealer uncovers dice box and shows result</p> <p>In this game, dealer can have two ways to cheat: 1. Changes the result after player bets 2. Reveals the result to another player in conspiracy</p> <p>In real world, we can take the following precautions to reduce the probability of cheating, but none of them has 100% guarantees. 1. Perform careful dicing equipments inspection 2. Supervise the dicing process 3. Rely on dealer's reputation</p> <p>Luckily, in the blockchain world, a more secure and efficient way can be used to prevent a dealer from manipulating results - the random numbers. </p> <p>This is equivalent to the following steps in the dicing example: 1. Add multiple dealers. The dicing results from each dealer will be submitted to calculation of the final result. As long as one dealer is honest, the final result is safe. A dealer must conspire with all rest dealers in order to cheat. 2. When the dicing result is generated, the result hash is calculated and shown in public for verification purpose before the player makes bet. The dicing result, when it is finally published, should match the hash. This effectively prevents the result from being tampered with.</p> <p>Figure 1 shows how above idea is implemented in Vite</p> <p>Figure 1</p> <p>Each random number goes through three steps in the lifecycle: 1. $hash_N$ is published when $random_N$ is generated 2. $random_N$ is published 3. $random_N$ is safely used</p> <p>In the figure, block $N$ to $N+5$ are six consecutive snapshot blocks produced by 3 SBPs (we assume the network has only 3 SBPs).</p> <p>In each round of producing a snapshot block, an SBP should publish both: 1. The hash of random number in the current round. 2. The random number that was generated by this SBP in the last round. </p> <p>For example, SBP1 published $hash_{N+3}$ (the hash of random number in $Block_{N+3}$) and $random_N$ (the random number generated in $Block_{N}$) in $Block_{N+3}$. The network will test if $Hash(random_N)=hash_N$, meaning the hash of $random_N$ must be equal to $hash_N$, otherwise $random_N$ is invalid.</p> <p>At this time, we can calculate a random seed based on the random numbers published by the SBPs in previous rounds. When $Block_{N+5}$ is produced, the random seed at this block is $$Seed_{N+5} = Sum(random_{N+2}, random_{N+1}, random_{N})$$ This result is unpredictable, and not a single SBP is able to manipulate the result.</p> <p>In actual implementation, in order to save storage, $random_N$ is in <code>uint64</code>, and $hash_N$ is limited to 32-byte length.</p> <p>In addition, for security reason such as preventing from brute-force attack, the hash function is defined as following:</p> <p>$$hash_N = Hash(random_N + Block_N.PrevHash + Block_N.Timestamp)$$</p> <p>See VEP-12: The Implementation of Random Numbers in Vite for more details.</p>"},{"location":"soliditypp/fundamentals/randomness/#using-random-seed-in-contract","title":"Using Random Seed in Contract","text":"<p>On Vite, contract execution is split into a pair of request and response. If random numbers are used in the contract, in order to obtain a random seed, the contract must wait at least until a given number x of snapshot blocks that contain published random numbers are produced. x is called Random Degree. </p> <p>When deploying a contract that uses the global function <code>random64()</code> or <code>nextrandom()</code>, you need specify a positive Random Degree and Response Latency, otherwise the deployment will fail.</p> <p>See here for more details about Random Degree and Response Latency.</p>"},{"location":"soliditypp/fundamentals/request-response-model/","title":"Request / Response Model","text":"<p>Vite's asynchronous design mainly lies in three aspects.</p> <ul> <li>Asynchronous request and response</li> <li>Asynchronous transaction writing and confirmation</li> <li>Asynchronous communication between smart contracts</li> </ul> <p>Here we focus on the first aspect.</p> <p>The typical model for devices communicating on a network is request-response. In the request-response model, a client requests data, and a server responds to the request by providing the data. The same concept applies to Vite and Solidity++ just with slightly different terms.</p>"},{"location":"soliditypp/fundamentals/request-response-model/#transactions","title":"Transactions","text":"<p>Transactions on Vite can be categorized as request (send) transactions and response (receive) transactions. We distinguish between the following scenarios:</p> <ul> <li>Token Transfer: User \u21cb User</li> <li>a user address sends funds to another user address</li> <li>Contract invocation: User \u21cb Contract or Contract \u21cb Contract</li> <li>a user address invokes a function of a contract address</li> <li>a contract address invokes the function of another contract address</li> </ul> <p>Regardless of the scenario, two successive transactions get generated on the ledger. Each transaction only affects the state of a single address and transactions do not interfere with one another, which improves throughput.</p> <p>In most cases, a transaction refers to an account block on Vite.</p>"},{"location":"soliditypp/fundamentals/request-response-model/#rs-receive-send-blocks","title":"RS (Receive-Send) Blocks","text":"<p>A request transaction to a smart contract may change the status of multiple user accounts or contracts. Imagine a Tipbot contract which sends \"small tips\" to many addresses in one transaction. By design, many new request transactions should be created and sent out after the contract response is complete. However, as a result, this breaks ACID principles that a transaction must hold. To prevent this, VEP-7 has been introduced to merge the in-contract request transactions into the original response as one whole transaction. The merged block contains a response transaction and multiple request transactions. We call such merged blocks as RS blocks.</p> <p>As shown in the figure below, one request block A<sub>1</sub> and three response blocks B<sub>1</sub>, C<sub>1</sub> and D<sub>1</sub> are created, and the in-contract request block B<sub>11</sub> and B<sub>12</sub> are merged into B<sub>1</sub>, which is a RS block in fact.</p> <p></p> <p>RS block has the following benefits:</p> <ul> <li>ACID is guaranteed since the response transaction and in-contract request transactions are written into one block</li> <li>Duplicated data are removed since blocks are merged</li> <li>Request-response relationship is preserved since each in-contract request has independent transaction hash</li> </ul>"},{"location":"soliditypp/fundamentals/request-response-model/#a-simple-solidity-contract","title":"A Simple Solidity++ Contract","text":"<p>Let's have a look at a simple Solidity++ example:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0 &lt;0.9.0;\n\ncontract SimpleStorage {\n    uint public storedData = 2;\n\n    function get() external view returns (uint) {\n        return storedData;\n    }\n}\n</code></pre> <p>As above, the way of declaring a contract is syntactically similar to Solidity.</p> <p>The first line tells you that the source code is licensed under the GPL version 3.0.</p> <p>The next line specifies that the source code is written for Solidity++ version 0.8.0, or a newer version of the language up to, but not including version 0.9.0. This is to ensure that the contract is not compilable with a new (breaking) compiler version, where it could behave differently. The only difference with Solidity is to replace <code>solidity</code> with <code>soliditypp</code>.</p> <p>Coming back to the request-response and client-server model, a client can invoke the <code>get()</code> function and the server (contract) will return the value of <code>storedData</code> which is equal to 2.</p> <p>Because <code>storedData</code> is annotated with the <code>public</code> keyword, a getter function will be auto-generated by the compiler. As a result, this example contract allows to retrieve the value of <code>storedData</code> in 2 different ways.</p>"},{"location":"soliditypp/fundamentals/sync-async-functions/","title":"Sync / Async Functions","text":"<p>In this chapter, we focus on the aspect of asynchronous communication between smart contracts.</p> <p>In synchronous architecture, when a process executes a request, it waits until the execution is complete and then returns the result. The process pauses during that time. After the request is sent, the asynchronous process (usually a thread) runs in the back and the main process goes ahead to handle other executions. When the asynchronous process completes, the main process will receive a notification with the return result.</p> <p>The advantages of asynchronous architecture are obvious \u2014 it will be much faster when running a batch of executions. Vite adopts a DAG-based ledger, where each address has a separate account chain. A transaction only changes the state of one account chain, so transactions of multiple addresses can be executed in parallel to achieve higher throughput.</p> <p>Unlike Ethereum, Vite is an asynchronous blockchain, calls to smart contracts on Vite are also asynchronous, that is, the return value cannot be obtained immediately after the call.</p> <p>The following is a simple example to introduce the asynchronous syntax in Solidity++.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0 &lt;0.9.0;\n\ncontract SimpleStorage {\n    uint storedData;\n\n    function set(uint x) external {\n        storedData = x;\n    }\n\n    function get() external view returns (uint) {\n        return storedData;\n    }\n}\n</code></pre> <p>There are two functions in the SimpleStorage contract. The syntax of function declarations is the same as Solidity, but the semantics are different. </p> <p>A function of a Vite contract is an async function.</p> <p>An async function does not execute or return result in the request transaction but in a subsequent response transaction.</p> <p>Let's dive deeper with a more advanced example.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.0;\n\ninterface Listener {\n    // declare a callback to receive the result\n    function sum(uint result) external;\n}\n\ncontract A {\n    uint public last;\n\n    function add(uint a, uint b) external {\n        last = a + b;\n        Listener sender = Listener(msg.sender);\n        // send message to the caller\n        sender.sum(last);\n    }\n}\n\ncontract B is Listener {\n    A contractA;\n    uint public total;\n\n    constructor (address addr) {\n        contractA = A(addr);\n    }\n\n    function test(uint a, uint b) external {\n        contractA.add(a, b);\n    }\n\n    function sum(uint result) external override {\n        total += result;\n    }\n\n    function getViteBalance() external view returns(uint256) {\n        return balance(\"tti_5649544520544f4b454e6e40\");\n    }\n}\n</code></pre> <ol> <li>When the client invokes <code>B.test()</code>, a request transaction S1 (client -&gt; contract B) is initiated.</li> <li>Vite is listening for all open request transactions to the address of contract B. Once the S1 is discovered, Vite VM is activated and the code of <code>B.test()</code> is executed. A response transaction R1 will be initiated after the execution.</li> <li>When the <code>contractA.add(a, b)</code> statement is executed, a new request transaction S2 (contract B -&gt; contract A) is triggered and merged into R1.</li> <li>When the S2 is accepted by contract A, the code of <code>A.add(uint a, uint b)</code> is executed and a response transaction R2 will be initiated after the execution.</li> <li>When the <code>sender.sum(last)</code> statement is executed, a new request transaction S3 (contract A -&gt; contract B) is triggered to send the result back to B. (S3 will be merged into R2).</li> <li>When S3 is accepted by contract B, the code of <code>B.sum(uint result)</code> is executed. The value of storage variable <code>total</code> is increased by the value from the calldata of S3. After the execution, a response transaction R3 will be initiated.</li> </ol> <p>Note</p> <p>Retrieving the last value with <code>contractA.last()</code> in contract B will be possible when the <code>async</code> keyword is be introduced with v0.8.1 of Solidity++. Refer to Promise and Await for details.</p>"},{"location":"soliditypp/fundamentals/transactional-semantics/","title":"Transactional Semantics","text":"<p>TODO</p>"},{"location":"soliditypp/fundamentals/types/","title":"Types and Units","text":""},{"location":"soliditypp/fundamentals/types/#types","title":"Types","text":"<p>Solidity++ is a statically typed language, which means that the type of each variable needs to be specified. Types allow the compiler to check the correct usage of the variables. Similar to other statically typed languages Solidity++ has value types and reference types which are defined as follows.</p>"},{"location":"soliditypp/fundamentals/types/#value-types","title":"Value Types","text":"<p>Value type variables store their own data. These are the basic data types provided by Solidity++. These types of variables are always passed by value and are copied wherever they are used in function arguments or assignment. </p> <ul> <li><code>bool</code> possible values are <code>true</code> or <code>false</code></li> <li><code>uint8</code> to <code>uint256</code> in steps of <code>8</code></li> <li><code>int8</code> to <code>int256</code> in steps of <code>8</code></li> <li><code>address</code>, <code>bytes</code>, <code>string</code>, <code>enum</code> and <code>vitetoken</code></li> </ul>"},{"location":"soliditypp/fundamentals/types/#reference-types","title":"Reference Types","text":"<p>Reference type variables store the location of the data. They don't share the data directly. With the help of reference type, two different variables can refer to the same location where any change in one variable can affect the other one.</p> <ul> <li><code>Arrays</code>: An array is a group of variables of the same data type in which variable has a particular location known as an index. By using the index location, the desired variable can be accessed. The array size can be fix or dynamic.</li> <li><code>Struct</code>: Custom types can be defined in the form of structures. The structure is a group of different types but it cannot contain a member of its own type. The structure is a reference type variable which can contain both value type and reference type.</li> <li><code>Mapping</code>: Mapping is a reference type, that stores the data in a key-value pair where a key can be any value type. It is like a hash table or dictionary as in any other programming language, where data can be retrieved by key.</li> </ul> <p>In addition, types can interact with each other in expressions containing operators.</p> <p>Examples of operators: - <code>!</code> (logical negation) - <code>&amp;&amp;</code> (logical conjunction, \u201cand\u201d) - <code>||</code> (logical disjunction, \u201cor\u201d) - <code>==</code> (equality) - <code>!=</code> (inequality)</p> <p>The concept of \"undefined\" or \"null\" values does not exist in Solidity++, but newly declared variables always have a default value dependent on its type.</p> <ul> <li><code>bool</code> : <code>false</code></li> <li><code>uint</code> or <code>int</code> : 0</li> <li><code>enum</code> : the default value is its first member</li> <li>statically-sized arrays and <code>bytes1</code> to <code>bytes32</code> : each individual element will be initialized to the default value corresponding to its type</li> <li>dynamically-sized arrays, <code>bytes</code> and <code>string</code> : the default value is an empty array or string</li> </ul>"},{"location":"soliditypp/fundamentals/types/#special-types","title":"Special Types","text":"<p>The <code>address</code> type is redefined to be compatible with Vite, and a new type <code>vitetoken</code> representing Vite Native Token Id is introduced in Solidity++.</p> <p>Default values: - <code>address</code> : vite_0000000000000000000000000000000000000000a4f3a0cb58 - <code>vitetoken</code> : tti_000000000000000000004cfd</p> <pre><code>// address type\naddress addr1 = address(\"vite_0102030405060708090807060504030201020304eddd83748e\");\naddress addr2 = \"vite_0102030405060708090807060504030201020304eddd83748e\";\naddress payable addr3 = payable(\"vite_0102030405060708090807060504030201020304eddd83748e\");\n\n// vitetoken type\nvitetoken token1 = vitetoken(\"tti_2445f6e5cde8c2c70e446c83\");\nvitetoken token2 = \"tti_2445f6e5cde8c2c70e446c83\";\n</code></pre> <p>For more examples please refer to https://docs.soliditylang.org/en/v0.8.1/types.html</p>"},{"location":"soliditypp/fundamentals/types/#units","title":"Units","text":"<p>In Solidity, a literal number can take a suffix of <code>wei</code>, <code>gwei</code> or <code>ether</code> to specify a subdenomination of Ether, where Ether numbers without a postfix are assumed to be <code>wei</code>.</p> <p>Similarly, in Solidity++, a literal number can take a suffix of <code>attov</code> and <code>vite</code> to specify a subdenomination of VITE, where VITE numbers without a postfix are assumed to be <code>attov</code>.</p> <ul> <li><code>1 vite == 1e18 attov</code></li> </ul>"},{"location":"soliditypp/fundamentals/types/#time-units","title":"Time Units","text":"<p>Suffixes like <code>seconds</code>, <code>minutes</code>, <code>hours</code>, <code>days</code> and <code>weeks</code> after literal numbers can be used to specify units of time where seconds are the base unit and units are considered naively in the following way:</p> <ul> <li><code>1 == 1 seconds</code></li> <li><code>1 minutes == 60 seconds</code></li> <li><code>1 hours == 60 minutes</code></li> <li><code>1 days == 24 hours</code></li> <li><code>1 weeks == 7 days</code></li> </ul> <p>Take care if you perform calendar calculations using these units, because not every year equals 365 days and not even every day has 24 hours because of leap seconds. Due to the fact that leap seconds cannot be predicted, an exact calendar library has to be updated by an external oracle.</p> <p>These suffixes cannot be applied to variables. For example, if you want to interpret a function parameter in days, you can in the following way:</p> <pre><code>function f(uint start, uint daysAfter) public {\n    if (block.timestamp &gt;= start + daysAfter * 1 days) {\n        // ...\n    }\n}\n</code></pre>"},{"location":"soliditypp/migration-guide/migrate-from-0.4/","title":"Migrating from Solidity++ 0.4","text":"<p>Comparing with Solidity++ 0.4, Solidity++ 0.8 is much syntactically closer to Solidity, which makes it more friendly to developers who want to migrate from Solidity. </p> <p>Note: Some counter-intuitive syntax and keywords are removed in this version.</p>"},{"location":"soliditypp/migration-guide/migrate-from-0.4/#solidity-080","title":"Solidity++ 0.8.0","text":""},{"location":"soliditypp/migration-guide/migrate-from-0.4/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>All Solidity breaking changes since v0.4.3 to v0.8.0 are applied to Solidity++ 0.8.0.</li> <li>Most of Solidity contracts and libraries can be compiled by solppc 0.8.0 and imported by Solidity++ 0.8.0 contracts, except for the contracts with external / delegate calls.</li> <li><code>onMessage</code> keyword is deprecated since 0.8.0. Use function declarations instead.</li> <li><code>message</code> keyword is deprecated since 0.8.0. Use <code>function</code> declared in a <code>contract</code> or <code>interface</code> instead.</li> <li><code>send</code> keyword is deprecated since 0.8.0. Use function calls instead.</li> <li><code>getter</code> keyword is deprecated since 0.8.0. Use <code>view</code>/<code>pure</code> functions instead.</li> <li>Inline assembly and Yul are supported since 0.8.0.</li> <li><code>keccak256</code> is available since 0.8.0.</li> <li><code>tokenId</code> keyword (Vite Native Token Id type) is changed to <code>vitetoken</code>.</li> <li>Some transaction properties are changed since 0.8.0: <code>msg.tokenid</code> is changed to <code>msg.token</code>, <code>msg.amount</code> is changed to <code>msg.value</code>.</li> </ul>"},{"location":"soliditypp/migration-guide/migrate-from-0.4/#compatibilities","title":"Compatibilities","text":"<ul> <li>An external or public <code>function</code> (without return values) in 0.8.0 equivalents to <code>onMessage</code> in 0.4.3. They have the same signature and selector. For example <code>function set(uint data) external</code> equivalents to <code>onMessage set(uint data)</code>.</li> <li>An external or public <code>function</code> declaration in 0.8.0 equivalents to <code>message</code> declaration in 0.4.3. </li> <li>A contract compiled by solppc 0.8.0 can call contracts compiled by solppc 0.4.3 asynchronously.</li> <li>A contract compiled by solppc 0.4.3 can call contracts compiled by solppc 0.8.0 asynchronously.</li> <li>The ABI encoding, storage layout, memory layout and calldata layout remain unchanged.</li> </ul>"},{"location":"soliditypp/migration-guide/migrate-from-0.4/#solidity-081","title":"Solidity++ 0.8.1","text":""},{"location":"soliditypp/migration-guide/migrate-from-0.4/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>Solidity contracts and libraries with external / delegate calls can be compiled by solppc 0.8.1 and imported by Solidity++ 0.8.1 contracts.</li> <li><code>await</code> operator is introduced since 0.8.1.</li> <li>Error propagation through <code>revert</code> and <code>try/catch</code> is enabled since 0.8.1.</li> <li>Delegate calls are allowed since 0.8.1.</li> <li>External / delegate calls in Solidity are allowed since 0.8.1.</li> <li>Library linking and calls to external library functions are allowed since 0.8.1.</li> </ul>"},{"location":"soliditypp/migration-guide/migrate-from-0.4/#compatibilities_1","title":"Compatibilities","text":"<ul> <li>A contract compiled by solppc 0.8.1 can call contracts compiled by solppc 0.4.3 asynchronously.</li> <li>A contract compiled by solppc 0.8.1 can call contracts compiled by solppc 0.8.0 both synchronously and asynchronously.</li> <li>A contract compiled by solppc 0.8.1 can get return values after a synchronous call to a contract compiled by solppc 0.8.0.</li> <li>The ABI encoding, storage layout, memory layout and calldata layout remain unchanged.</li> </ul>"},{"location":"soliditypp/migration-guide/migrate-from-0.4/#migrate-to-080","title":"Migrate to 0.8.0","text":"<p>Let's start with an example:</p> <pre><code>pragma soliditypp ^0.4.3;\n\ncontract A {\n    message sum(uint result);\n\n    onMessage add(uint a, uint b) {\n        uint result = a + b;\n        address sender = msg.sender;\n        send(sender, sum(result));\n   }\n}\n\ncontract B {\n    address addrA;\n    uint total;\n    message add(uint a, uint b);\n\n    constructor (address addr) {\n        addrA = addr;\n    }\n\n    onMessage invoke(uint a, uint b) {\n        send(addrA, add(a, b));\n    }\n\n    onMessage sum(uint result) {\n        total += result;\n    }\n\n    getter total() returns(uint) {\n        return total;\n    }\n\n    getter getSomething() returns(uint) {\n        return total + 1;\n    }\n}\n</code></pre> <p>In above code, contract A declares a message listener <code>add(uint a, uint b)</code>.</p> <p>contract B declares <code>add</code> message which has the same signature to <code>add</code> message listener in contract A.</p> <p>Contract B declares a message listener <code>invoke</code> as the entry to the contract. When <code>B.invoke()</code> is called, contract B sends a <code>add</code> message to contract A to initiate an asynchronous message call.</p> <p>When contract A responds to the message call, it sends a <code>sum</code> message back to contract B to return data asynchronously.</p> <p>Contract B also declares a message listener <code>sum(uint result)</code> as a 'callback function' to handle the returned message from contract A.</p> <p>Since 0.8.0, <code>onMessage</code> and <code>message</code> are replaced with <code>function</code>, <code>send</code> statements are replaced with function calls. The <code>await</code> operator is not available in 0.8.0, it is required to declare callbacks explicitly using <code>function</code>.</p> <p>The migrated code in 0.8.0 is as follows:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.0;\n\ninterface Listener {\n    // delare a callback to receive the result\n    function sum(uint result) external;\n}\n\ncontract A {\n    // the onMessage is replaced with an external function\n    function add(uint a, uint b) external {\n        Listener sender = Listener(msg.sender);\n        // send message to the caller\n        sender.sum(a + b);\n    }\n}\n\ncontract B is Listener {\n    A contractA;\n    uint public total;  // a getter function will be auto-generated by the compiler\n\n    constructor (address addr) {\n        contractA = A(addr);\n    }\n\n    // the onMessage is replaced with a function\n    function invoke(uint a, uint b) external {\n        // replace the send statement with a function call\n        contractA.add(a, b);\n    }\n    // the callback is replaced with a function\n    function sum(uint result) external override {\n        total += result;\n    }\n    // the offchain getter is replaced with a view or pure function\n    function getSomething() external view returns(uint) {\n        return total + 1;\n    }\n}\n</code></pre>"},{"location":"soliditypp/migration-guide/migrate-from-0.4/#migrate-to-081","title":"Migrate to 0.8.1","text":"<p>Since Solidity++ 0.8.1, no explicit callback declarations are required.</p> <p>The compiler is smart enough to generate callbacks automatically. The code is cleaner and optimized significantly by the introduction of <code>await</code>.</p> <p>The migrated code in 0.8.1 is as follows:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.1;\n\ncontract A {\n    // the async function can return data to the caller\n    function add(uint a, uint b) external async returns(uint) {\n        return a + b;\n    }\n}\n\ncontract B {\n    A contractA;\n    uint public total;\n\n    constructor (address addr) {\n        contractA = A(addr);\n    }\n\n    function invoke(uint a, uint b) external async {\n        // use await expression to get data returned from the called contract\n        total += await contractA.add(a, b);\n    }\n\n    function getSomething() external view returns(uint) {\n        return total + 1;\n    }\n}\n</code></pre>"},{"location":"soliditypp/migration-guide/migrate-from-solidity/","title":"Migrating from Solidity","text":""},{"location":"soliditypp/migration-guide/migrate-from-solidity/#solidity-compatibility","title":"Solidity Compatibility","text":"<p>Solidity++ 0.8 is compatible with almost all syntax of Solidity, except for a few differences which will be introduced below.</p> <p>All features related to Ethereum are replaced with the counterparts in Vite.</p> <p>Note: The <code>new</code> keyword is disabled in this version. In other words, it is impossible to deploy a new contract from a contract at runtime.  In addition, <code>selfdestruct</code> and <code>ecrecover</code> are disabled in this version.</p>"},{"location":"soliditypp/migration-guide/migrate-from-solidity/#types","title":"Types","text":"<p>Type <code>address</code> is redefined to be compatible with Vite, and a new type <code>vitetoken</code> representing Vite Native Token Id is introduced in Solidity++.</p> <pre><code>// address type\naddress addr1 = address(\"vite_0102030405060708090807060504030201020304eddd83748e\");\naddress addr2 = \"vite_0102030405060708090807060504030201020304eddd83748e\";\naddress payable addr3 = payable(\"vite_0102030405060708090807060504030201020304eddd83748e\"); \n// vitetoken type\nvitetoken token1 = vitetoken(\"tti_2445f6e5cde8c2c70e446c83\");\nvitetoken token2 = \"tti_2445f6e5cde8c2c70e446c83\";\n</code></pre>"},{"location":"soliditypp/migration-guide/migrate-from-solidity/#call-options","title":"Call Options","text":"<p>When calling functions of other contracts, it is possible to specify the amount of a specific token sent with the call in call options, e.g. <code>{token: \"tti_564954455820434f494e69b5\", value: 1e18}</code>.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0 &lt;0.9.0;\n\ncontract InfoFeed {\n    function info() external async payable returns (uint ret) {\n        return 42;\n    }\n}\n\ncontract Consumer {\n    InfoFeed feed;\n\n    constructor payable (address payable addr) {\n        feed = InfoFeed(addr);\n    }\n\n    function callFeed() external async {\n        // send 1 VX with the call\n        feed.info{token: \"tti_564954455820434f494e69b5\", value: 1e18}();\n    }\n}\n</code></pre> <p>If property <code>token</code> is omitted, the VITE token is sent by default.</p> <p>That says, the following code <pre><code>feed.info{value: 1e18}();\n</code></pre> is equivalents to <pre><code>feed.info{token: \"tti_5649544520544f4b454e6e40\", value: 1e18}();\n</code></pre></p> <p>Note</p> <p>Property <code>gas</code> and <code>salt</code> in call option are not supported in Solidity++.</p>"},{"location":"soliditypp/migration-guide/migrate-from-solidity/#units","title":"Units","text":"<p>In Solidity, a literal number can take a suffix of <code>wei</code>, <code>gwei</code> or <code>ether</code> to specify a subdenomination of Ether, where Ether numbers without a postfix are assumed to be <code>wei</code>.</p> <p>Similarly, in Solidity++, a literal number can take a suffix of <code>attov</code> and <code>vite</code> to specify a subdenomination of VITE, where VITE numbers without a postfix are assumed to be <code>attov</code>.</p> <pre><code>1 vite = 1e18 attov\n</code></pre>"},{"location":"soliditypp/migration-guide/migrate-from-solidity/#special-variables-and-functions","title":"Special Variables and Functions","text":""},{"location":"soliditypp/migration-guide/migrate-from-solidity/#block-and-transaction-properties","title":"Block and Transaction Properties","text":"<p>Below special variables and functions has been removed in Solidity++:</p> <pre><code>tx.gasprice;\nblock.coinbase;\nblock.difficulty;\nblock.gaslimit;\nblockhash(param);\ngasleft();\nmsg.gas;\nselfdestruct(_owner);\nsuicide(_addr);\n</code></pre> <p>Below special variables and functions has been added in Solidity++:</p> <pre><code>bytes32 b1 = fromhash();\nuint height = accountheight();\nbytes32 b2 = prevhash();\nuint64 random = random64();\nuint64 random = nextrandom();\n</code></pre> <ul> <li><code>fromhash()</code> returns request transaction's hash</li> <li><code>accountheight()</code> returns latest block height of an account</li> <li><code>prevhash()</code> returns latest block hash of an account</li> <li><code>random64()</code> returns a random number in <code>uint64</code>. This function will return the same random number in one transaction</li> <li><code>nextrandom()</code> returns a random number in <code>uint64</code>. This function can be called multiple times to obtain different random numbers in one transaction</li> </ul> <p>Get transfer value (Ether) in Solidity: <pre><code>uint amount = msg.value\n</code></pre></p> <p>Get transfer value and token id in Solidity++: <pre><code>uint amount = msg.value;\nvitetoken token = msg.token;\n</code></pre></p>"},{"location":"soliditypp/migration-guide/migrate-from-solidity/#members-of-address-types","title":"Members of Address Types","text":"<p>Get account balance in Solidity:</p> <pre><code>address.balance\n</code></pre> <p>Get account balance in Solidity++, balance is a function with a single parameter of <code>vitetoken</code>: <pre><code>address.balance(\"tti_564954455820434f494e69b5\");\n</code></pre></p> <p>In Solidity, send Ether to an address:</p> <pre><code>payable(_addr).transfer(_amount);\n</code></pre> <p>In Solidity++, send some amount of a specific token to an address:</p> <pre><code>payable(_addr).transfer(_tokenId, _amount);\n</code></pre>"},{"location":"soliditypp/migration-guide/migrate-from-solidity/#cryptographic-functions","title":"Cryptographic Functions","text":"<p>A new hash function <code>blake2b</code> is introduced in Solidity++. <pre><code>blake2b(bytes memory) returns (bytes32)\n</code></pre> * Compute the Blake2b hash of the input.</p>"},{"location":"soliditypp/vuilder/","title":"Vuilder Kit","text":"<p>Vuilder is the Solidity++ smart contract development kit to help developers reduce complexity of compilation, library linking, testing, and deployment of the contract. Vuilder has the following common commands:</p> <pre><code>npx vuilder node  // start a local gvite node\nnpx vuilder compile // compile contract\nnpx vuilder test  // test contract\nnpx ts-node deploy.ts  // execute a ts file \n</code></pre> <p>The following sections show how to use Vuilder with an example.</p>"},{"location":"soliditypp/vuilder/#create-a-vuilder-project","title":"Create a Vuilder Project","text":"<p>Execute the command to create a typescript project.</p> <pre><code>mkdir vuilder-demo &amp;&amp; cd vuilder-demo\nnpm init -y &amp;&amp; npm i typescript --save-dev &amp;&amp; npx tsc --init --resolveJsonModule true\nnpm install ts-node @types/node @vite/vuilder chai mocha @types/chai @types/mocha\n</code></pre>"},{"location":"soliditypp/vuilder/#compile-contract","title":"Compile Contract","text":"<p>Let's create two sample contracts and save to <code>contracts</code> subfolder. Create the subfolder if it doesn't exit.</p> <pre><code>mkdir contracts\nvim contracts/HelloWorld.solpp\n</code></pre> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0;\n\ncontract HelloWorld {\n    uint public data = 123;\n\n    function set(uint a) external {\n        data = a; \n    }\n}\n</code></pre> <pre><code>vim contracts/transfer.solpp\n</code></pre> <pre><code>// SPDX-License-Identifier: GPL-3.0\n// Demonstrate how to transfer tokens from / to a contract.\n\npragma soliditypp &gt;=0.8.0;\n\ncontract TransferVite {\n   event Received(address sender, vitetoken token, uint amount);\n\n   constructor() payable {}\n\n   // Receive Token function\n   receive() external payable {\n      address sender = msg.sender;\n      vitetoken token = msg.token;\n      uint amount = msg.value;\n\n      emit Received(sender, token, amount);\n   }\n\n   function sendViteTo(address payable addr, uint amount) external payable {\n      // send VITE to `addr`\n      addr.transfer(\"tti_5649544520544f4b454e6e40\", amount);\n   }\n}\n</code></pre> <p>Compile the contract</p> <pre><code>npx vuilder compile HelloWorld.solpp\nnpx vuilder compile transfer.solpp\n</code></pre> <p>It should show that the compilation is successful</p> <p></p>"},{"location":"soliditypp/vuilder/#testing","title":"Testing","text":"<p>Set up local network and test account</p> <pre><code>mkdir test\nvim test/vite.config.json\n</code></pre> <p>The settings below should not be modified due to the mnemonic phrase for local network has been set up by default.</p> <pre><code>{\n  \"networks\": {\n    \"local\": {\n      \"http\": \"http://127.0.0.1:23456/\",\n      \"ws\": \"http://127.0.0.1:23457/\",\n      \"mnemonic\": \"record deliver increase organ subject whisper private tourist final athlete unit jacket arrow trick sweet chuckle direct print master post senior pluck whale taxi\"\n    }\n  }\n}\n</code></pre> <p>Write test cases in <code>HelloWorld.spec.ts</code></p> <pre><code>vim test/HelloWorld.spec.ts\n</code></pre> <pre><code>import { expect } from \"chai\";\nconst vuilder = require(\"@vite/vuilder\");\nimport config from \"./vite.config.json\";\n\nlet provider: any;\nlet deployer: any;\n\ndescribe(\"test HelloWorld\", () =&gt; {\n  before(async function() {\n    provider = vuilder.newProvider(config.networks.local.http);\n    console.log(await provider.request(\"ledger_getSnapshotChainHeight\"));\n    deployer = vuilder.newAccount(config.networks.local.mnemonic, 0, provider);\n    console.log('deployer', deployer.address);\n  });\n\n  it('test set function', async () =&gt; {\n    // compile\n    const compiledContracts = await vuilder.compile('HelloWorld.solpp');\n    expect(compiledContracts).to.have.property('HelloWorld');\n\n    // deploy\n    let helloWorld = compiledContracts.HelloWorld;\n    helloWorld.setDeployer(deployer).setProvider(provider);\n    await helloWorld.deploy({});\n    expect(helloWorld.address).to.be.a('string');\n    console.log(helloWorld.address);\n\n    // check default value of data\n    let result = await helloWorld.query('data', []);\n    console.log('return', result);\n    expect(result).to.be.an('array').with.lengthOf(1);\n    expect(result![0]).to.be.equal('123');\n\n    // call HelloWorld.set(456);\n    await helloWorld.call('set', ['456'], {});\n\n    // check value of data\n    result = await helloWorld.query('data', []);\n    console.log('return', result);\n    expect(result).to.be.an('array').with.lengthOf(1);\n    expect(result![0]).to.be.equal('456');\n  });\n});\n</code></pre> <p>Write test cases in <code>transfer.spec.ts</code></p> <pre><code>vim test/transfer.spec.ts\n</code></pre> <pre><code>import { describe } from \"mocha\";\nimport { expect } from \"chai\";\nimport * as vuilder from \"@vite/vuilder\";\nimport config from \"./vite.config.json\";\n\nlet provider: any;\nlet deployer: vuilder.UserAccount;\n\ndescribe('test transfer', () =&gt; {\n  before(async function() {\n    provider = vuilder.newProvider(config.networks.local.http);\n    console.log(await provider.request(\"ledger_getSnapshotChainHeight\"));\n    deployer = vuilder.newAccount(config.networks.local.mnemonic, 0, provider);\n    console.log('deployer', deployer.address);\n  });\n\n  it('test contract', async () =&gt; {\n    // compile\n    const compiledContracts = await vuilder.compile('transfer.solpp');\n    expect(compiledContracts).to.have.property('TransferVite');\n\n    // init user accounts\n    const alice = vuilder.newAccount(config.networks.local.mnemonic, 1, provider);\n    console.log('alice', alice.address);\n    const bob = vuilder.newAccount(config.networks.local.mnemonic, 2, provider);\n    console.log('bob', bob.address);\n    await deployer.sendToken(alice.address, '200');\n    await alice.receiveAll();\n    await deployer.sendToken(bob.address, '100');\n    await bob.receiveAll();\n\n    // deploy\n    let transferVite = compiledContracts.TransferVite;\n    transferVite.setDeployer(deployer).setProvider(provider);\n    await transferVite.deploy({tokenId: 'tti_5649544520544f4b454e6e40', amount: '600'});\n    expect(transferVite.address).to.be.a('string');\n    console.log(transferVite.address);\n\n    let balanceA = await transferVite.balance();\n    expect(balanceA).to.be.equal('600');\n\n    // Alice sent 50 to the contract A\n    const block = await alice.sendToken(transferVite.address, '50');\n\n    await vuilder.utils.waitFor(() =&gt; {\n      return vuilder.isReceived(provider, block.hash);\n    }, \"Wait for receiving token\");\n\n    // check balance of A\n    balanceA = await transferVite.balance();\n    // console.log('balance of A:', balanceA);\n    expect(balanceA).to.be.equal('650');\n\n    // check events of A\n    let events = await transferVite.getPastEvents('Received', {fromHeight: 0, toHeight: 0});\n    expect(events[0]?.returnValues?.sender).to.be.equal(alice.address);\n    expect(events[0]?.returnValues?.token).to.be.equal('tti_5649544520544f4b454e6e40');\n    expect(events[0]?.returnValues?.amount).to.be.equal('50');\n\n    // check balance of Alice\n    let balanceAlice = await alice.balance();\n    // console.log('balance of Alice:', balanceAlice);\n    expect(balanceAlice).to.be.equal('150');\n\n    // Alice call contract A.sendViteTo() to send token to Bob\n    await transferVite.call('sendViteTo', [bob.address, 30], {caller: alice, amount: \"100\"});\n\n    // check balance of Bob before receiving\n    let balanceBob = await bob.balance();\n    // console.log('balance of Bob:', balanceBob);\n    expect(balanceBob).to.be.equal('100');\n\n    // Bob recevie the money\n    await bob.receiveAll();\n\n    // check balance of Bob after receiving\n    balanceBob = await bob.balance();\n    // console.log('balance of Bob:', balanceBob);\n    expect(balanceBob).to.be.equal('130');\n\n    // check balance of A\n    balanceA = await transferVite.balance();\n    // console.log('balance of A:', balanceA);\n    expect(balanceA).to.be.equal('720');\n  });\n});\n</code></pre> <p>Run the test script and watch results.</p> <pre><code>npx vuilder test\n</code></pre> <p>Tip</p> <p>For more examples, please refer to soliditypp-examples</p>"},{"location":"soliditypp/vuilder/#deployment","title":"Deployment","text":"<p>Congratulations! All the tests have passed, we can deploy the contract on the blockchain now.</p> <p>Create a <code>deploy.config.json</code> file specifying the deployment environment and a mnemonic phrase. Here we deploy the contract in the testnet.</p> <pre><code>mkdir scripts\nvim scripts/deploy.config.json\n</code></pre> <pre><code>{\n  \"http\": \"https://buidl.vite.net/gvite\",\n  \"mnemonic\": \"your mnemonic phrase\"\n}\n</code></pre> <p>Write deployment script</p> <pre><code>vim scripts/deploy.ts\n</code></pre> <pre><code>import { expect } from \"chai\";\nimport * as vuilder from \"@vite/vuilder\";\nimport config from \"./deploy.config.json\";\n\nasync function run(): Promise&lt;void&gt; {\n  const provider = vuilder.newProvider(config.http);\n  console.log(await provider.request(\"ledger_getSnapshotChainHeight\"));\n  const deployer = vuilder.newAccount(config.mnemonic, 0, provider);\n\n  // compile\n  const compiledContracts = await vuilder.compile(\"HelloWorld.solpp\");\n  expect(compiledContracts).to.have.property(\"HelloWorld\");\n\n  // deploy\n  let helloWorld = compiledContracts.HelloWorld;\n  helloWorld.setDeployer(deployer).setProvider(provider);\n  await helloWorld.deploy({});\n  expect(helloWorld.address).to.be.a(\"string\");\n  console.log(helloWorld.address);\n\n  return;\n}\n\nrun().then(() =&gt; {\n  console.log(\"done\");\n});\n</code></pre> <p>Run deploy script</p> <pre><code>npx ts-node scripts/deploy.ts\n</code></pre> <p>We can get the contract address on the console. </p> <p>Tip</p> <p>To ensure the contract is deployed successfully on the chain, you can check the address on a Vite Explorer.</p> <p></p>"},{"location":"vep/","title":"VEP","text":"<p>Vite Enhancement Proposal. Anything beneficial you believe, please submit here: VEP.</p>"},{"location":"vep/#proposal-list","title":"Proposal list","text":"<ul> <li>VEP 3: Vite Wallet Key Derivation</li> <li>VEP 5: Remove Explicit Snapshot Hash Reference as Timestamps</li> <li>VEP 6: Vite URI Formatting</li> <li>VEP 7: Merge In-Contract Request Calls into Original Response as one Transaction</li> <li>VEP 8: AccountBlock Data Content Type Definition</li> <li>VEP 10: Vite TestNet-PreMainnet Data Migration Plan</li> <li>VEP 12: The Implementation of Random Numbers in Vite</li> <li>VEP 13: Rules of SBP Rewards Calculation and Distribution</li> <li>VEP 15: Introduce Block Producing Rate in SBP Selection</li> <li>VEP 16: Specification of Address Generation</li> <li>VEP 19: Implement Synchronous Function Calls to Vite Contracts</li> </ul>"},{"location":"vep/vep-10/","title":"VEP-10: Vite TestNet-PreMainnet Data Migration Plan","text":""},{"location":"vep/vep-10/#background","title":"Background","text":"<p>Due to massive optimizations made in blockchain's data structure and consensus algorithm, old transaction data cannot be verified in the mainnet. Therefore, transactions in TestNet will not be retained after the migration, but only account status will be.</p>"},{"location":"vep/vep-10/#objectives","title":"Objectives","text":"<ol> <li>Keep complete account state information</li> <li>Ensure consensus works smoothly when the mainnet launches</li> </ol>"},{"location":"vep/vep-10/#migration-plan","title":"Migration Plan","text":"<p>Generate a genesis block on each account involved to store balance, contract states and other information that should be migrated. Then snapshot these genesis account blocks into a genesis snapshot block.</p>"},{"location":"vep/vep-10/#user-account","title":"User Account","text":"<p>User account status includes account balance and un-received transactions. * Balance is directly saved * Amounts of all un-received transactions are summed up and added into account balance * Only balances of VITE and VCP are retained</p>"},{"location":"vep/vep-10/#contract-account","title":"Contract Account","text":"<p>Contract account status includes contract information (code, delegated consensus group that the contract belongs to), contract states (contract storage), contract account balance and un-received transactions.</p>"},{"location":"vep/vep-10/#built-in-contracts","title":"Built-in Contracts","text":"<ul> <li>Balance is directly saved</li> <li>Amounts of all un-received transactions are returned to original accounts</li> <li>Only balances of VITE and VCP are retained</li> </ul> <p>Staking contract (address <code>vite_0000000000000000000000000000000000000003f6af7459b9</code>) * Retain all staking information with new expiration height 1 (can be retrieved immediately after the mainnet launches)</p> <p>Original SBP registration contract, voting contract and consensus group contract are merged into new consensus group contract (address <code>vite_0000000000000000000000000000000000000004d28108e76b</code>) * Retain all valid SBP registrations with new registration expiration height 7776000 (about 3 months after mainnet launches) * Retain all voting information * Retain all settings in snapshot consensus group and public delegated consensus group</p> <p>Mintage contract (address <code>vite_000000000000000000000000000000000000000595292d996d</code>) * Retain token information for VITE and VCP * Change VITE to re-issuable * For other tokens, token issuance fee (1,000 VITE each) is refunded to issuer's account and the relevant token will not be retained</p>"},{"location":"vep/vep-10/#user-deployed-contracts","title":"User-deployed Contracts","text":"<ul> <li>User-deployed contracts will not be retained</li> <li>Contract deployment fee (10 VITE each) is refunded to contract creator</li> <li>Contract balance is returned to contract creator</li> <li>Amounts of all un-received transactions are returned to original accounts</li> <li>Only balances of VITE and VCP are retained</li> </ul>"},{"location":"vep/vep-10/#conclusion","title":"Conclusion","text":"<ul> <li>Consensus state is carried over from TestNet. The snapshot consensus group info and SBP ranking is unchanged</li> <li>Account information remain unchanged, including balance, staking, voting, SBP registration and token issuance information</li> <li>All user-issued tokens need to be re-minted in the mainnet</li> <li>All user-deployed smart contracts need to be re-deployed in the mainnet</li> </ul>"},{"location":"vep/vep-12/","title":"VEP-12: The Implementation of Random Numbers in Vite","text":""},{"location":"vep/vep-12/#background","title":"Background","text":"<p>Random numbers are widely used in Vite.  One good case is the consensus reaching process, where a random number is chosen in each round in the purpose of determining which supernode is responsible for producing the next snapshot block without being predicted in advance. Another scenario is in gambling dApp games the results are generated depending on unpredictable random numbers to avoid manipulation. In general, the random numbers in Vite should meet the following criteria:</p> <ol> <li>Should NOT be manipulable</li> <li>Should NOT be predictable</li> </ol>"},{"location":"vep/vep-12/#implementation","title":"Implementation","text":"<p>The design evolved from the dicing game in real life. Basically, a simple dicing game will go through the following 3 steps: 1. The dealer shakes the dice box 2. The player guesses the numbers and makes bet 3. The dealer uncovers dice box and shows result</p> <p>In this game, the dealer can have two ways of cheating: 1. Changing the result in secret after the player bets 2. Being aware of the result in advance and disguising as a player</p> <p>In real life, the following methods can be used to prevent from dealer's cheating, but with no 100% guarantees. 1. Inspecting dicing instruments (including dice box and die) 2. Supervising the whole dicing process 3. Using the dealer's reputation as guarantee</p> <p>In the blockchain world, a more secure and efficient way can be used to prevent the dealer from manipulating the result, by using random numbers.  In effect, this is equivalent to the following steps in the dicing example: 1. Introduce multiple dealers and adding all dicing results up as the final result. As long as one dealer does not cheat, the overall result is unpredictable. This step greatly increases cheating cost and reduces the probability in return 2. Once the dicing result is generated, the result hash is calculated and shown in public before the player places a bet for verification purpose. Whenever the dicing result is announced, it should match the hash value published before. This step effectively prevents the result from being tampered with</p> <p>Figure 1 shows how above idea is implemented in Vite</p> <p>Figure 1</p> <p>Each random number goes through three stages in the lifecycle: 1. $hash_N$ is announced when $random_N$ is generated 2. $random_N$ is announced 3. $random_N$ is used somewhere</p> <p>In the figure, block $N$ to $N+5$ are 6 consecutive snapshot blocks produced by 3 SBPs (we assume the system has only 3 SBPs).</p> <p>When producing a block, each SBP should announce the random number's hash of current round and the random number that was created by this very SBP in previous round.  For example, $hash_{N+3}$ (the hash of random number in $Block_{N+3}$) and $random_N$ (the random number produced in $Block_{N}$) are announced in $Block_{N+3}$. This requires $Hash(random_N)=hash_N$, meaning the hash of $random_N$ should be in equal with $hash_N$, otherwise $random_N$ is invalid.</p> <p>In this way, when a new block is produced, a random seed can be calculated based on the random numbers announced by all SBPs in previous round. In our example, $Block_{N+5}$ has random seed $Sum(random_{N+2}, random_{N+1}, random_{N})$. This result is unpredictable until $Block_{N+5}$ is produced, and also $Block_{N+5}$ is not able to manipulate the result. This perfectly satisfies the two criteria we mentioned above.</p> <p>In actual implementation, in order to save storage, $random_N$ is defined as <code>uin64</code>, and $hash_N$ is <code>32byte</code>.</p> <p>At the same time, for security reason of avoiding brute-force attack, the hash function is defined as:</p> <p>$$hash_N = Hash(random_N, Block_N.PrevHash, Block_N.Timestamp)$$</p>"},{"location":"vep/vep-12/#random-seed-in-contract","title":"Random Seed in Contract","text":"<p>In Vite, a contract call is split into a pair of request and response. If random numbers are involved in the contract's business logic, the contract should wait until the request transaction is snapshotted and use this snapshot block for random seed.  In real implementation, request block hash is used together to guarantee the maximum unpredictability.</p>"},{"location":"vep/vep-12/#conclusion","title":"Conclusion","text":"<p>As the usage of random numbers in blockchain increases, a well-designed random number solution that cannot be manipulated and predicted significantly improves the security. This proposal suggests an implementation method of random numbers in Vite.</p>"},{"location":"vep/vep-13/","title":"VEP-13: Rules of SBP Rewards Calculation and Distribution","text":""},{"location":"vep/vep-13/#background","title":"Background","text":"<p>In each year, an additional amount of Vite tokens which is no more than 3% of circulation will be issued for SBP incentivization. Taking circulation of 1 billion as an example, the reward for each snapshot block in the first year is <code>0.951293759512937595</code> VITE.</p> <p>SBP rewards are calculated by cycle. A cycle has 1152 rounds, approximately equivalent to one day. To be eligible for rewards, the SBP node must be in top 100 in the last round of the cycle.</p> <p>SBP rewards come from token inflation.</p>"},{"location":"vep/vep-13/#rules-of-reward-calculation","title":"Rules of Reward Calculation","text":"<p>SBP rewards consist of two parts: Block Creation Reward and Candidate Additional Reward.</p> <ul> <li> <p>Block Creation Reward: 50% of rewards will be given to block producers in number of the blocks they created</p> </li> <li> <p>Candidate Additional Reward: 50% of rewards will be allocated to the top 100 SBPs in the last round of cycle based on block producing rate and the number of votes in the cycle.</p> </li> </ul> <p>Reward calculation:</p> <p>$$Q = \\frac{l}{m}\\frac{V}{W}XR0.5 + lR0.5$$</p> <ul> <li><code>Q</code>: the total reward of the SBP in one cycle</li> <li><code>l</code>: the number of blocks that are produced by the SBP in one cycle</li> <li><code>m</code>: the number of blocks that are expected to produce by the SBP in one cycle. If no block is produced by any SBP in a round, <code>m</code> should substrate the target block producing number of that round</li> <li><code>X</code>: the total number of blocks that are produced by all SBP nodes in one cycle</li> <li><code>W</code>: the total number of votes of the top 100 SBPs in the last round of one cycle, plus the total staking amounts of registration of the top 100 SBPs (1m VITE for each SBP in the Mainnet)</li> <li><code>V</code>: the number of votes of the SBP in the last round of one cycle, plus the staking amounts of registration of this node (1m VITE for each SBP in the Mainnet)</li> <li><code>R</code>: The reward for each block, fixed at <code>0.951293759512937595</code> VITE in the first year</li> </ul> <p>For example:</p> <p>Suppose S1 and S2 are SBPs and are in the top 100 in the last round of one cycle. The voting number of S1 and S2 is 200k and 300k respectively.</p> <p>In each round, S1 and S2 are supposed to produce 3 blocks. </p> <p>In the first round, S1 produced 1 block, and the actual block number produced by S2 is 2.</p> <p>In the second round S1 produced 2 block, and S2 produced all 3 blocks.</p> <p>Start from the third round till cycle's end, neither S1 nor S2 produced any more block.</p> <p>Rewards of S1 and S2 in the cycle can be calculated as below:</p> <p>$$Q_{S1} = \\frac{1+2}{3+3}\\frac{200000+1000000}{200000+1000000+300000+1000000}(1+2+2+3)0.9512937595129375950.5+(1+2)0.9512937595129375950.5$$</p> <p>$$Q_{S2} = \\frac{2+3}{3+3}\\frac{300000+1000000}{200000+1000000+300000+1000000}(1+2+2+3)0.9512937595129375950.5+(2+3)0.9512937595129375950.5$$</p>"},{"location":"vep/vep-13/#rules-of-reward-withdrawal","title":"Rules of Reward Withdrawal","text":"<ul> <li>Reward must be withdrawn by the owner of SBP (registration account) or an account authorized by the owner</li> <li>Reward in latest 48 rounds (approximately one hour) cannot be withdrawn</li> <li>Reward must be withdrawn by cycles (days)</li> <li>Incomplete cycle is not eligible for reward, such as the first cycle of registration and the last cycle in which the registration is cancelled</li> </ul>"},{"location":"vep/vep-13/#reward-distribution","title":"Reward Distribution","text":"<ul> <li>First, SBP registration account sends a withdrawal request to Vite's built-in consensus contract, and specifies SBP name and an address for receiving reward (the default receiving address is registration address)</li> <li>The consensus contract calculates the actual amount of reward available for withdrawal, then sends a request to token issuance contract to mint new Vite coins. The issuing amount is the number calculated in this step. The recipient's address is the reward receiving address</li> <li>The token issuance contract mints new coins, and transfers to the reward receiving address</li> <li>Reward is received by receiving address</li> </ul> <p>VITE is re-issuable. The token's owner is the consensus contract. In the protocol of Vite, this is the only re-issuance scenario of VITE.</p>"},{"location":"vep/vep-15/","title":"VEP-15: Introduce Block Producing Rate in SBP Selection","text":""},{"location":"vep/vep-15/#background","title":"Background","text":"<p>In practice, SBP node may be temporarily down due to various reasons, such as poor internet connection, or temporary hardware overload. SBP node would fail to produce snapshot blocks during the time.  Considering every SBP in top 25 has the responsibility to maintain the stability and security of the network by producing snapshot blocks on time, it's necessary to downgrade the \"non-available\" SBP in the round.</p>"},{"location":"vep/vep-15/#scheme","title":"Scheme","text":"<ul> <li>Downgrade two nodes at most in a round</li> <li>Set the threshold of block producing rate in last hour at 80%. SBP nodes that are below the threshold will be downgraded</li> <li>Assign the first 25 nodes are consisted of Group A and those in 26-75 belong to Group B</li> <li>Downgrade and replace a node with block producing rate below 80% in Group A with another node in Group B higher than 80%. In this case, the latter node is upgraded</li> <li>Keep the number of nodes in Group A and B unchanged</li> </ul> <p>For example, suppose the producing rate of a node ranking 24th is lower than 80%, and that of another node ranking 26 is above 80%, in the following round, the latter will replace the former to produce block.</p>"},{"location":"vep/vep-16/","title":"VEP-16 Specification of Address Generation","text":"<p>In the Mainnet, the account address is a 21-byte length number (hereinafter referred to Original Address), where the first 20 bytes is address and the last byte represents account type.</p> <p>The first 20 bytes (hereinafter referred to Address Body) come from:</p> <ul> <li>For user account, a 20-byte hash based on the public key of the account.</li> <li>For contract account, a 20-byte hash based on the address of contract creation account, the height of contract creation block, and the hash of the previous account block of contract creation transaction. </li> </ul> <p>The last 1 byte (hereinafter referred to Type Flag)  is:</p> <ul> <li>0 for user account</li> <li>1 for contract account</li> </ul> <p>In practice, a 55-length string is used as Literal Address.</p> <p>Convert original address to literal address:</p> <ul> <li>For user account, use <code>vite_</code> + Hex string of Address Body + Hex string of the checksum of Address Body.</li> <li>For contract account, use <code>vite_</code> + Hex string of Address Body + Hex string of the flipped checksum of Address Body by bit.</li> </ul> <p>Convert literal address to original address:</p> <p>Take characters between 6-45 of Literal Address as the 20-byte Address Body and check:</p> <ul> <li>If the hex string of checksum of Address Body matches the characters from 46 to 55 in Literal Address, set 0 to Type Flag as the address is a user address. </li> <li>If the hex string of flipped checksum of Address Body is the same as the 46th to 55th chars of Literal Address, set 1 to Type Flag as the address is a contract address.</li> </ul> <p>The checksum is calculated by taking a 5-byte hash on the basis of Address Body.</p>"},{"location":"vep/vep-19/","title":"VEP-19: Implement Synchronous Function Calls to Vite Contracts","text":""},{"location":"vep/vep-19/#background","title":"Background","text":""},{"location":"vep/vep-19/#composability","title":"Composability","text":"<p>Composability is one of the core features of a decentralized ecosystem, that is, one smart contract can interact with others in unlimited combinations. So that developers can stack smart contracts on top of one another like Lego.</p> <p>To achieve composability, smart contract programming languages must be designed to make it easier for contracts to talk to each other.</p> <p>Solidity on EVM makes contracts inherently composable through synchronous external function calls and the ABI specification.</p> <p>But for Solidity++ on Vite, things are not that simple. Because Vite is an asynchronous blockchain, calls to smart contracts on Vite are also asynchronous, that is, the return value cannot be obtained immediately after the call.  Therefore, the composability can only be achieved through the callback functions in the early version of Solidity++ (before 0.8.1).</p>"},{"location":"vep/vep-19/#composability-using-callbacks","title":"Composability Using Callbacks","text":"<p>Achieving composability through callbacks is rather painful for developers.</p> <p>Let's start with a simple example: * Contract <code>A</code> has an <code>add()</code> method that returns the sum of two unsigned integers. * Contract <code>B</code> has a <code>test()</code> method that calculates the sum of <code>1</code> and <code>2</code> by calling <code>A.add()</code>, and stores the result in the storage variable <code>data</code>.</p> <p>Straightforward, the implementation in Solidity is as follows:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ncontract A {\n    function add(uint a, uint b) external pure returns(uint) {\n        return a + b;\n    }\n}\n\ncontract B {\n    A contractA;\n    uint public data;\n\n    constructor (address addr) {\n        contractA = A(addr);\n    }\n\n    function test() external {\n        data = contractA.add(1, 2);\n    }\n}\n</code></pre> <p>It can be implemented using callbacks in Solidity++ 0.8.0 as follows:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.0;\n\ncontract A {\n    function add(uint a, uint b, function(uint) external callback) external {\n        if (callback.address != address(0)) {\n            // send callback to return data to the caller\n            callback(a + b);\n        }\n    }\n}\n\ncontract B {\n    A contractA;\n    uint public data;\n\n    constructor (address addr) {\n        contractA = A(addr);\n    }\n\n    function test() external {\n        contractA.add(1, 2, this.callback_onAdd);\n    }\n\n    function callback_onAdd(uint result) external {\n        // receive data from the called contract\n        require(msg.sender == address(contractA));\n        data = result;\n    }\n}\n</code></pre> <p>We add an additional parameter <code>callback</code> of type <code>function(uint) external</code> to <code>A.add()</code>.</p> <p>When contract <code>B</code> calls contract <code>A</code>, it needs to pass the callback function <code>this.callback_onAdd</code> as an argument of <code>A.add()</code>.</p> <p>Contract <code>A</code> can obtain the address of the caller and the selector of the callback function through the <code>callback</code> parameter. It puts the result of <code>a + b</code> in the first argument and initiates a call to the <code>callback</code> function to return data to <code>B</code>.</p> <p>In the callback function <code>callback_onAdd()</code> of contract <code>B</code>, it gets the result of <code>A.add()</code> from the parameter <code>result</code> and assigns it to the storage variable <code>data</code>.</p> <p>It works fine and the code doesn't look too complicated, no pain at all, right? </p> <p>Once the call stack gets deeper, you won't think so anymore.</p>"},{"location":"vep/vep-19/#callback-hell","title":"Callback Hell","text":"<p>Let's expand this example a bit to see what happens.</p> <p>In a more complex example: * We add a <code>sum()</code> method to contract <code>B</code>, that calculates the sum of 3 integers by calling the <code>add()</code> method of contract <code>A</code> twice, and returns the final result to the caller by initiating a callback. * Add another contract <code>C</code> to call contract <code>B</code> to calculate the sum of the integers <code>1</code>, <code>2</code>, and <code>3</code>.</p> <p>In Solidity, implementing such an extension is straightforward.</p> <p>We can initiate two calls to <code>A.add()</code> in sequence in the <code>B.sum()</code> function, and pass the partial result returned from the first call as the argument of the second call.</p> <p>Here is the implementation in Solidity:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ncontract A {\n    function add(uint a, uint b) external pure returns(uint) {\n        return a + b;\n    }\n}\n\ncontract B {\n    A contractA;\n    constructor (address addr) {\n        contractA = A(addr);\n    }\n\n    function sum(uint a, uint b, uint c) external view returns(uint) {\n        uint partialResult = contractA.add(a, b);\n        return contractA.add(partialResult, c);\n    }\n}\n\n\ncontract C {\n    B contractB;\n    uint public data;\n\n    constructor (address addr) {\n        contractB = B(addr);\n    }\n\n    function test() external {\n        data = contractB.sum(1, 2, 3);\n    }\n}\n</code></pre> <p>We can see that the contract <code>A</code> doesn't change anything compared to the previous example.</p> <p>So can contract <code>A</code> also remain unchanged with the implementation using callbacks in Solidity++? </p> <p>Unfortunately, the answer is NO. We have to extend the called contracts to keep them composable in Solidity++ 0.8.0, the code is as follows\uff1a</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.0;\n\ncontract A {\n    function add(uint a, uint b, function(uint, function(uint) external, uint) external callback, function(uint) external origin, uint context) external {\n        if (callback.address != address(0)) {\n            // send callback to return data to the caller\n            callback(a + b, origin, context);\n        }\n    }\n}\n\ncontract B {\n    A contractA;\n\n    constructor (address addr) {\n        contractA = A(addr);\n    }\n\n    function sum(uint a, uint b, uint c, function(uint) external origin) external {\n        // initiate the first call to A.add()\n        contractA.add(a, b, this.callback_onAdd1, origin, c);\n    }\n\n    function callback_onAdd1(uint partialResult, function(uint) external origin, uint context) external {\n        // receive data from the first call\n        require(msg.sender == address(contractA));\n        // initiate the second call to A.add() \n        contractA.add(partialResult, context, this.callback_onAdd2, origin, 0);\n    }\n\n    function callback_onAdd2(uint result, function(uint) external origin, uint) external {\n        // receive data from the second call\n        require(msg.sender == address(contractA));\n        if (origin.address != address(0)) {\n            // send callback to return final result to the caller\n            // the target is contract C rather than contract A\n            origin(result);\n        }\n    }\n}\n\ncontract C {\n    B contractB;\n    uint public data;\n\n    constructor (address addr) {\n        contractB = B(addr);\n    }\n\n    function test() external {\n        contractB.sum(1, 2, 3, this.callback_onSum);\n    }\n\n    function callback_onSum(uint result) external {\n        require(msg.sender == address(contractB));\n        data = result;\n    }\n}\n</code></pre> <p>Let's see what additional work is required to keep the contracts composable in Solidity++ with only callbacks:</p> <ul> <li> <p>We need to add two callback functions to contract <code>B</code>. In the first callback function <code>B.callback_onAdd1()</code>, we receive the partial result of the first call to <code>A.add(a, b)</code>, and use this as an argument to initiate the second call to <code>A.add()</code>. In the second callback function <code>B.callback_onAdd2()</code>, we receive the final result of the second call to <code>A.add(a, b)</code>, and use this to initiate the callback to contract <code>C</code>.</p> </li> <li> <p>In order to initiate a callback request to the original caller <code>C</code> to return the final result, <code>B</code> must record the address of the origin. <code>B</code> can obtain the address of <code>C</code> in the function <code>B.sum()</code>, but cannot pass it to the callback function <code>B.callback_onAdd2()</code>, because the VM context cannot be shared between different functions due to the asynchronous nature of Vite. Therefore, we have to put the address and callback method id in an <code>origin</code> parameter of the <code>A.add()</code> function.</p> </li> <li> <p>Similarly, in order to use the third parameter <code>c</code> of the <code>B.sum()</code> function as the second argument of the second call to <code>A.add()</code>, we need to extend the parameter list of <code>A.add()</code> and <code>B.callback_onAdd1()</code> by adding a <code>context</code> parameter.</p> </li> </ul> <p>As we can see, even for such a simple scenario, the contract code has become cluttered.</p> <p>It comes from the famous problem of Callback Hell: Using low-level callbacks makes code difficult to write and understand. It also increases the difficulty of identifying the control flow for a contract.</p>"},{"location":"vep/vep-19/#composability-using-await-operator","title":"Composability Using Await Operator","text":"<p>In order to make contracts written in Solidity++ as simple and straightforward as those written in Solidity, we need to introduce an <code>await</code> operator as in some modern programming languages such as javascript and C#. </p> <p>Await operator suspends evaluation of the enclosing async function until the asynchronous operation represented by its operand completes. When the asynchronous operation completes, it returns the result of the operation, if any. </p> <p>It helps you write synchronous-looking Solidity++ code that works asynchronously. </p> <p>When the example is implemented in Solidity++ with <code>await</code> operator, the code will be as straightforward and concise as in Solidity:</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp ^0.8.1;\n\ncontract A {\n    function add(uint a, uint b) external pure returns(uint) {\n        return a + b;\n    }\n}\n\ncontract B {\n    A contractA;\n    constructor (address addr) {\n        contractA = A(addr);\n    }\n\n    function sum(uint a, uint b, uint c) external view returns(uint) {\n        uint partialResult = await contractA.add(a, b);\n        return await contractA.add(partialResult, c);\n    }\n}\n\n\ncontract C {\n    B contractB;\n    uint public data;\n\n    constructor (address addr) {\n        contractB = B(addr);\n    }\n\n    function test() external {\n        data = await contractB.sum(1, 2, 3);\n    }\n}\n</code></pre>"},{"location":"vep/vep-19/#implementation","title":"Implementation","text":""},{"location":"vep/vep-19/#objectives","title":"Objectives","text":"<p>To make this happen, the Solidity++ compiler and Vite VM have to do most mechanical works for developers under the hood.</p> <p>Let's dissect the code to see what specific work needs to be done by the compiler and VM:</p> <p></p> <p>In summary, there are the following tasks for the compiler and VM: * To generate callback entries for each synchronous call automatically at compile time. * To initiate a callback request when the result is returned. * To maintain execution context during function invocations and callbacks.</p>"},{"location":"vep/vep-19/#solidity-compiler-and-evm","title":"Solidity Compiler and EVM","text":"<p>Before deciding how to implement it, let's take a look at the output from Solidity compiler for this example.</p> <p>Pseudo assembly code for contract <code>A</code>: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(add)\n    jump(tag_function_add)\nelse\n    fallback()\nstop\n\ntag_function_add:\na, b := abi_decode(calldata)\ntmp := checked_add(a, b)\nret := abi_encode(tmp)\nreturn(ret)\n</code></pre></p> <p>Pseudo assembly code for contract <code>B</code>: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(test)\n    jump(tag_function_test)\nelse\n    fallback()\nstop\n\ntag_function_test:\ncontract_address := contractA\nmethod_id := sig_hash(add)\nparams := abi_encode(1, 2)\ncall(contract_address, method_id, params)\nret := abi_decode(returndata)\ndata = ret\nreturn\n</code></pre></p> <p>To make the control flow clear, let's put these in an anatomy diagram:</p> <p></p> <p>As shown by the red arrows in the diagram, the EVM executes external function calls through the <code>call</code> and <code>return</code> instructions.</p> <p>The Solidity compiler will create a piece of code called function selector for each contract that includes the entries to interface functions of the contract at compile time.</p> <p>When executing a message call to a contract, EVM extracts the first four bytes from calldata and compare against the method id of each function. If there\u2019s a match, then jump to the definition of a corresponding function and keep executing. If there\u2019s no match, then jump to the fallback function either defined by user or automatically created by the compiler.</p> <p>When the <code>call</code> instruction gets executed, the EVM will retrieve the callee's address and load the callee\u2019s code from the address and execute the code in an independent context.</p> <p>When the <code>return</code> instruction gets executed, the EVM will place the result of the execution into the memory and exits from the callee's code, and then keep executing the remaining code of the caller.</p>"},{"location":"vep/vep-19/#solidity-compiler","title":"Solidity++ Compiler","text":"<p>Let's start extending the functionality on the Solidity compiler, introducing the new features mentioned above:</p> <ul> <li>To generate a callback entry, the compiler needs to traverse all <code>await</code> expressions in the contract at compile time, add a tag to each position immediately after the <code>await</code>, and add it to the function selector as a callback entry.</li> <li>To initiate a callback request when the result is returned, we need to reimplement the <code>return</code> instruction in the Vite VM to initiate a send transaction with type of <code>SendCallback</code>.</li> <li>To maintain execution context, two new instructions <code>synccall</code> and <code>callbackdest</code> need to be introduced into the Vite VM. </li> </ul> <p>The compiler places a <code>synccall</code> instruction at each synchronous call. When the VM executes the <code>synccall</code> instruction, it initiates a send transaction with type of <code>SendSyncCall</code> and persists the execution context into the local database.</p> <p>Similarly, the compiler places a <code>callbackdest</code> instruction at each callback. When the VM executes the <code>callbackdest</code> instruction, it restores the execution context from the local database and then resumes execution.</p> <p>This design allows the compiler to generate code that can run on an asynchronous VM for contracts written in a programming language similar to Solidity.</p> <p>The example will be compiled to the following code:</p> <p>Pseudo assembly code for contract <code>A</code>: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(add)\n    jump(tag_function_add)\nelse\n    fallback()\nstop\n\ntag_function_add:\na, b := abi_decode(calldata)\ntmp := checked_add(a, b)\nret := abi_encode(tmp)\nreturn(ret)\n</code></pre></p> <p>Pseudo assembly code for contract <code>B</code>:</p> <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(test)\n    jump(tag_function_test)\nelse if method_id == 0x00000001\n    jump(tag_callback_01)\nelse\n    fallback()\nstop\ntag_function_test:\ncontract_address := contractA\nmethod_id := sig_hash(add)\nparams := abi_encode(1, 2)\ncallback_id := 0x00000001\nsynccall(contract_address, method_id, params, callback_id)\nstop\ntag_callback_01:\ncallbackdest\nret := abi_decode(calldata)\nreturn(ret)</code></pre> <p>Again, let's put these in an anatomy diagram:</p> <p></p> <p>The blue part of the assembly code is generated by the Solidity++ compiler specifically for the Vite VM.</p> <p>The orange and green circles represent the send (request) transaction and receive (response) transaction initiated by the Vite VM, respectively.</p> <p>As we can see, the compiler translates each <code>await</code> expression into a set of instructions in the same pattern: inserting a <code>synccall</code> instruction, a <code>stop</code> instruction, a jump dest tag (a <code>jumpdest</code> instruction), and a <code>callbackdest</code> instruction.</p> <p>Essentially, the Vite VM treats the <code>synccall</code> instruction as an interrupt, which is a request for the VM to interrupt currently executing code, save its context, and initiate an asynchronous request transaction.</p> <p>Correspondingly, before receiving a callback and resuming execution, the execution context needs to be restored by executing the <code>callbackdest</code> instruction.</p> <p>This pattern is known as context switch. In a multi-task system, it refers to the process of storing the system state for a task, so that task can be paused and resumed later.</p>"},{"location":"vep/vep-19/#vite-vm","title":"Vite VM","text":"<p>Vite VM retains the semantics of most EVM instructions, but is not a clone of EVM. Therefore, new instructions such as <code>synccall</code> and <code>callbackdest</code> need to be implemented from scratch, and some EVM instructions such as <code>return</code>, <code>returndatasize</code>, <code>returndatacopy</code> need to be reimplemented to adapt to the Vite protocol.</p>"},{"location":"vep/vep-19/#transaction-types","title":"Transaction Types","text":"<p>Three new transaction types need to be introduced:</p> <ul> <li>SendSyncCall: A send transaction initiated by a synchronous call,</li> <li>SendCallback: A send transaction initiated by a callback that successfully executes and returns a result.</li> <li>SendFailureCallback: A send transaction initiated by a callback that fails to execute and returns an error.</li> </ul>"},{"location":"vep/vep-19/#execution-context","title":"Execution Context","text":"<p>Each transaction with one of the three new types contains an execution context data stored in the database.</p> <p>The execution context is defined as follows:</p> <pre><code>ExecutionContext {\n    referrer types.Hash\n    callback big.Int\n    stack  []big.Int\n    memory []byte\n}\n</code></pre> <p>For a <code>SendSyncCall</code> transaction, its execution context includes: - <code>referrer</code> holds the send transaction hash of the upstream (origin) sync call. - <code>callback</code> holds the 4-bytes method id of the callback function entry. - <code>stack</code> holds a snapshot of the contract stack at the time <code>synccall</code> is executed. - <code>memory</code> holds a snapshot of the contract memory at the time <code>synccall</code> is executed.</p> <p>For a <code>SendCallback</code> or a <code>SendFailureCallback</code> transaction, its execution context only includes a <code>referrer</code> field: - <code>referrer</code> holds the send transaction hash of the latest sync call.</p> <p>If <code>referrer</code> confuses you, see the example below\uff1a</p>"},{"location":"vep/vep-19/#synccall-instruction","title":"SyncCall Instruction","text":"<p>The <code>synccall</code> instruction is implemented in pseudocode as follows:</p> <pre><code>func opSynccall() {\n    callback, toAddress, tokenID, amount, inOffset, inSize := vm.stack.pop(6)\n    calldata := vm.mem.get(inOffset, inSize)\n\n    if vm.Context.originSendBlock == nil {\n        // upstream call\n        origin := this.sendBlock\n    } else {\n        // load origin from VM context, it was saved by previous callbackdest\n        origin := vm.Context.Origin\n    }\n\n    tx := ViteRequestTransaction {\n        from: this.address,\n        to: toAddress,\n        type: SendSyncCall,\n        value: amount,\n        token: tokenID,\n        data: calldata\n        executionContext: ExecutionContext {\n            referrer: origin.Hash,\n            callback: callback,\n            stack: vm.stack,\n            memory: vm.memory,\n        }\n    }\n\n    vite.trigger(tx)\n}\n</code></pre>"},{"location":"vep/vep-19/#return-instruction","title":"Return Instruction","text":"<p>The <code>return</code> instruction is implemented in pseudocode as follows:</p> <pre><code>func opReturn() {\n    offset, size := vm.stack.pop(2)\n    ret := vm.mem.get(offset, size)\n\n    sendType := this.sendBlock.BlockType\n    // need to trigger a callback transaction\n    if sendType == SendSyncCall || sendType == SendCallback || sendType == SendFailureCallback {\n        // get the send-block of the original call\n        if vm.Context.Origin == nil {\n            // the return statement is not in a callback function\n            // so origin is the latest send transaction\n            origin := this.sendBlock\n        } else {\n            // the return statement is in a callback function\n            // load origin from VM context, it was saved by previous callbackdest\n            origin := vm.Context.Origin\n        }\n\n        if origin.BlockType == SendSyncCall {\n            callback := origin.executionContext.callback\n            // calldata of the callback: [callback_id][return_data]\n            data := concat(callback, ret)\n\n            tx := ViteRequestTransaction {\n                from: this.address,\n                to: origin.address,\n                type: SendCallback,\n                data: data,\n                executionContext: ExecutionContext{\n                    referrer: origin.Hash,\n                }\n            }\n\n            vite.trigger(tx)\n        }\n    }\n</code></pre>"},{"location":"vep/vep-19/#callbackdest-instruction","title":"CallbackDest Instruction","text":"<p>The <code>callbackdest</code> instruction is implemented in pseudocode as follows:</p> <pre><code>func opCallbackDest() {\n    sendType := this.sendBlock.BlockType\n    if sendType == SendCallback || sendType == SendFailureCallback {\n        referrer := this.sendBlock.executionContext.referrer\n\n        // validate sync call send block\n        if referrer.address != this.address || referrer.ToAddress != this.sendBlock.address {\n            return nil, error\n        }\n\n        // get upstream origin send block\n        origin := referrer.executionContext.referrer\n\n        // validate origin send block\n        if origin.ToAddress != this.address {\n            return nil, error\n        }\n\n        // save origin send block to VM context\n        vm.Context.Origin = origin\n\n        // restore stack\n        vm.stack = referrer.executionContext.stack\n\n        // push success flag (act as RETURN instruction in EVM)\n        if sendType == SendCallback {\n            // push true\n            stack.push(1)\n        } else { // sendType == SendFailureCallback\n            // push false\n            stack.push(0)\n        }\n\n        // restore memory\n        vm.memory = referrer.executionContext.memory\n    }\n}\n</code></pre>"},{"location":"vep/vep-19/#advanced-example","title":"Advanced example","text":"Show  ### Objectives  ![dissect the code](./assets/know-how-1.png)  ### Solidity Compiler and EVM  Pseudo assembly code for contract `A`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(add)\n    jump(tag_function_add)\nelse\n    fallback()\nstop\n\ntag_function_add:\na, b := abi_decode(calldata)\ntmp := checked_add(a, b)\nret := abi_encode(tmp)\nreturn(ret)\n</code></pre>  Pseudo assembly code for contract `B`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(sum)\n    jump(tag_function_sum)\nelse\n    fallback()\nstop\n\ntag_function_sum:\na, b, c := abi_decode(calldata)\ncontract_address := contractA\nmethod_id := sig_hash(add)\nparams := abi_encode(a, b)\ncall(contract_address, method_id, params)\npartialResult := abi_decode(returndata)\nparams := abi_encode(partialResult, c)\ncall(contract_address, method_id, params)\nret := abi_decode(returndata)\nreturn(ret)\n</code></pre>  Pseudo assembly code for contract `C`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(test)\n    jump(tag_function_test)\nelse\n    fallback()\nstop\n\ntag_function_test:\ncontract_address := contractB\nmethod_id := sig_hash(sum)\nparams := abi_encode(1, 2, 3)\ncall(contract_address, method_id, params)\nret := abi_decode(returndata)\ndata = ret\nreturn\n</code></pre>  ![compiled from solidity](./assets/compiled-solidity.png)  ### Solidity++ Compiler  Pseudo assembly code for contract `A`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(add)\n    jump(tag_function_add)\nelse\n    fallback()\nstop\n\ntag_function_add:\na, b := abi_decode(calldata)\ntmp := checked_add(a, b)\nret := abi_encode(tmp)\nreturn(ret)\n</code></pre>  Pseudo assembly code for contract `B`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(sum)\n    jump(tag_function_sum)\nelse if method_id == 0x00000001\n    jump(tag_callback_01)\nelse if method_id == 0x00000002\n    jump(tag_callback_02)\nelse\n    fallback()\nstop\n\ntag_function_sum:\na, b, c := abi_decode(calldata)\ncontract_address := contractA\nmethod_id := sig_hash(add)\nparams := abi_encode(a, b)\ncallback_id := 0x00000001\nsynccall(contract_address, method_id, params, callback_id)\nstop\n\ntag_callback_01:\ncallbackdest\np := abi_decode(calldata)\ncontract_address := contractA\nmethod_id := sig_hash(add)\nparams := abi_encode(p, c)\ncallback_id := 0x00000002\nsynccall(contract_address, method_id, params, callback_id)\nstop\n\ntag_callback_02:\ncallbackdest\nret := abi_decode(calldata)\nreturn(ret)\n</code></pre>  Pseudo assembly code for contract `C`: <pre><code>function_selector:\nmethod_id := calldata(0, 4)\nif method_id == sig_hash(test)\n    jump(tag_function_test)\nelse if method_id == 0x00000001\n    jump(tag_callback_01)\nelse\n    fallback()\nstop\n\ntag_function_test:\ncontract_address := contractB\nmethod_id := sig_hash(sum)\nparams := abi_encode(1, 2, 3)\ncallback_id := 0x00000001\nsynccall(contract_address, method_id, params, callback_id)\nstop\n\ntag_callback_01:\ncallbackdest\nret := abi_decode(calldata)\nreturn(ret)\n</code></pre>  ![compiled from soliditypp](./assets/compiled-soliditypp.png)  ### Vite VM  ![referrer](./assets/referrer.png)"},{"location":"vep/vep-21/","title":"VEP-21 Reduce Quota Consumption to Allow Big Contract","text":"<p>The maximum quota limit for creating a smart contract on the Vite network is 1,000,000. According to the quota table</p> <ul> <li>$Qm$ = 1000000</li> <li>$QC_{transaction}$ = 31000</li> <li>$QC_{snapshot}$ = 40</li> <li>$QC_{byte}$ = 160</li> </ul> <p>where $Qm$ is the maximum quota allowed for a single account block, $QC_{transaction}$ is the standard quota consumption for a creating contract transaction, $QC_{snapshot}$ defines the quota consumption per snapshot block, where the number of snapshot blocks is measured by ResponseLatency parameter when the contract is deployed. $QC_{byte}$ defines the quota consumption of a single byte of compiled contract code.</p> <p>The quota consumption for creating a smart contract is $$QC=QC_{transaction} + QC_{snapshot} \\times ResponseLatency + QC_{byte} \\times (len(code)+1)$$</p> <p>The additional 1 byte is the contract type.</p> <p>When $Qc &lt; Qm$, the maximum allowed code length is 6055 in byte. (given ResponseLatency = 1)</p> <p>This means any smart contract larger than 6055 bytes cannot be deployed on the network.</p>"},{"location":"vep/vep-21/#improvement","title":"Improvement","text":"<p>We propose to reduce the quota consumption per byte to 16 to allow large contract. In the above case, when $QC_{byte}$ = 16, the maximum allowed compiled code is 60559 bytes, 10x the original size.</p>"},{"location":"vep/vep-3/","title":"VEP 3: Vite Wallet Key Derivation","text":""},{"location":"vep/vep-3/#summary","title":"Summary","text":"<p>VEP 3 defines the private key derivation rules(with multiple curve algorithms) in Vite wallet.</p>"},{"location":"vep/vep-3/#purpose","title":"Purpose","text":"<p>HD wallet(Hierarchical Deterministic Wallet) has the capability of deriving multiple private keys from one single seed, thus making it easy to do wallet backup or upgrade to other compatible wallets such as hardware wallet. </p> <p>HD wallet also supports multiple tokens.</p>"},{"location":"vep/vep-3/#content","title":"Content","text":"<p>The seed is represented by a number of words that is easy to remember or write on paper, called mnemonic phrase. In protocol BIP39 a mnemonic phrase is defined in 12 or 24 words.</p> <p>Based on BIP32, BIP44 allows wallet to store multiple tokens and accounts with one seed.</p> <p>Since Vite adopts ED25519 for signature, other than secp256k1 used in BIP32, we need to find a key derivation method which is compatible with BIP32. The actual signature implementation in Vite is similar to ed25519-bip32.</p>"},{"location":"vep/vep-3/#bip44-compatibility","title":"BIP44 Compatibility","text":"<p>BIP44 defines a BIP32-compatible path patten that supports multiple cryptocurrencies: <pre><code>m / purpose' / coin_type' / account' / change / address_index\n</code></pre> The prefix is always like: <pre><code>m/44'\n</code></pre> We have registered <code>coin_type</code>\b 666666 at SLIP-0044, so a BIP44 Vite path starts with: <pre><code>m/44'/666666'/\n</code></pre> Attached an index <code>x</code>: <pre><code>m/44'/666666'/x'\n</code></pre> * x: Index. Particularly, we define the address associated with <code>m/44'/666666'/0'</code> as Primary Address of the mnemonic.</p>"},{"location":"vep/vep-3/#test-case","title":"Test Case","text":""},{"location":"vep/vep-3/#entropy","title":"Entropy","text":"<pre><code>87ad0e066111ed827dc1f7be4d1bf53b9a7be84021a0950418d3f45ed4d54f1c\n</code></pre>"},{"location":"vep/vep-3/#mnemonic-phrase","title":"Mnemonic Phrase","text":"<pre><code>marble half light season burst scorpion warfare discover salad hand wool jaguar police vintage above cross never camp crunch trim unhappy height detect opinion\n</code></pre>"},{"location":"vep/vep-3/#bip39-seed","title":"BIP39 \b\bSeed","text":"<pre><code>2ba1d8e696d17ac4d75b9f479c527450d439c9acd2b4d542d27e3a7f3418cd241717d2db41f47d8bbae9fc90fe551c4db87f7491104f030f6eceaf1b24f15f4d\n</code></pre>"},{"location":"vep/vep-3/#derived-vite-ed25519-seeds-and-addresses","title":"Derived Vite ED25519 Seeds and Addresses","text":"<pre><code>m/44'/666666'/0' bb369222613ad7b1a646d84d8c749c30cfa5879f5152b7bd7c1f9f6553ce0eb5  vite_da3ca9bac9f05fce8f4eead36610756b6eb48282ff10a81d6d\nm/44'/666666'/1' 529892283122a9a09059a73147cb9feea480bb3feed91e7968243f4b67ccb3ea  vite_e5deb80a64f51593398ba1049af435291e3cb5c69a66755f13\nm/44'/666666'/2' 9ef6f33aaf05fa1cf6e8c396b01a5ea08295a829b595f636759343d363a6a967  vite_fbdd0c038f808560f9637754cbbbfa95ed2e7cdb96113ea7eb\nm/44'/666666'/3' 6da0edd6d81033b4b2d41f376574448876e7b4f841aedd7deaf8bb6d7934b800  vite_2aa258c33a2d16d01da651a9423abc384f6367112c0f73fa5d\nm/44'/666666'/4' 98d2311c78e6407bf0c443ab51593c4b663ce3af3165a48a278ed0a6a2f701f3  vite_b8d401c1c7b3f32bf7d9c7a44c8d594fcdad103bb6775bd016\nm/44'/666666'/5' bd18f1dfc81bc742cda2c3739a42fb622415d62b8fd6035ff8bad2a9b13f26b6  vite_7aba6649b09a43130445dd70857e77bef347e2da2a7b81f608\nm/44'/666666'/6' b1cf0511a4bb7a154cf0f6c416a3186c4d6fe8cd53413c6503e80445918837e8  vite_5ef7da6c7fb79051921d0c6cf7440fb9f1b46d7aaf5607a069\nm/44'/666666'/7' 2b31aa5f86e1207baa4ec93dd397c878ef53255a3ca64cafa970bb6513fb7099  vite_6ebaad8ee67e5368884ae2de652024093453ec13d8f17e0afa\nm/44'/666666'/8' 87210e4ec4776ab5e6bc146255b1e649f6a4f99e754ff31e421e2f43784f2aff  vite_ec84678c2d6f1f12596552a0d676ab233d17249463973f7238\nm/44'/666666'/9' e02109c47903e2f8858660f30642e3698a263f0277ad2f364527bc75275a82ec  vite_1720f21b3a66c30da966ef51dc59c091543da012bcb69ae8a4\n</code></pre>"},{"location":"vep/vep-5/","title":"VEP 5: Remove Explicit Snapshot Hash Reference as Timestamps","text":""},{"location":"vep/vep-5/#background","title":"Background","text":"<p>In Section 6.2.2(Resource Quantification) of Vite White Paper, it mentions</p> <p>Because snapshot chain is equivalent to a global clock, we can use it to quantify the resource usage of an account accurately. In each transaction, the Hash of a snapshot block is quoted, the height of the snapshot block is took as the timestamp of the transaction. Therefore, according to the difference between the two transaction timestamps, we can judge whether the interval between the two transactions is long enough.</p> <p>Figure 1. Explicit Timestamps</p> <p>In Figure 1, each transaction contains an explicit hash reference to snapshot block as transaction creation time. The main purpose of this timestamp is to calculate whether the resource consumption of an account exceeds its quota.</p> <p>In addition to \"explicit\" timestamp, there is another \"implicit\" timestamp in the system. This \"implicit\" timestamp is the latest transaction hash for each account recorded in snapshot block, representing the \"confirmation time\" of a transaction.</p> <p>The two types of timestamp cause two-way dependency between transactions and snapshot chain, as shown in Figure 2:</p> <p>Figure 2. Explicit Timestamps and Implicit Timestamps</p> <p>The red arrows indicate the references from transaction to snapshot block, representing explicit timestamps(the creation time of transaction).</p> <p>The blue arrows indicate the references from snapshot block to transaction, representing implicit timestamps(the confirmation time of transaction).</p>"},{"location":"vep/vep-5/#impact-of-snapshot-chain-fork-on-timestamp","title":"Impact of Snapshot Chain Fork on Timestamp","text":"<p>In structure, snapshot chain is actually a tree due to the possibility of forks.  The newer the snapshot block is, the more likely it could be rolled back. Both types of timestamps will be impacted when rollback occurs.  However, explicit timestamps will receive bigger impact, as explained below:</p> <p>Figure 3. Explicit Timestamps with snapshot chain forks</p> <p>In Figure 3,  the snapshot block #N on the right hand side is rolled back and replaced by another forked snapshot block on the left side.  All transactions referring to this snapshot block must be rolled back as well, including the last transactions in account A and B.  This is because the hash value of snapshot block was involved in signing, as part of the transaction data.  The transactions have to be re-signed and re-sent by the original users since the previously referenced snapshot block is invalid.  However, re-signing transaction is very expensive and therefore should be avoided in practice.  An alternative strategy is to reference an older snapshot block, which means the \"trunk\" part of the snapshot chain. Unfortunately, this approach deviates from the purpose of explicit timestamp as transaction creation time and also is hard to tell which block is most appropriate. </p> <p>A conclusion can be reached now that regardless of their benefit, explicit timestamps have this problem. In contrast, implicit timestamps do not have this problem.</p> <p>Figure 4. Implicit Timestamps with snapshot chain forks</p> <p>Implicit timestamps are simply discarded along with the snapshot block during a rollback. In the example of Figure 4, the second transaction of account A and first transaction of account B will be re-marked as unconfirmed.  A forked snapshot block #N will produce a set of new implicit timestamps, but not necessarily the same as those in the original block.  Since implicit timestamp is reversed reference, transactions in DAG ledger do not have to change.  Therefore, it is not necessary for users to re-sign their transactions any more, making fork resolution simple.</p>"},{"location":"vep/vep-5/#calculate-resource-consumption-with-implicit-timestamps","title":"Calculate Resource Consumption with Implicit Timestamps","text":"<p>So, using implicit timestamps, is it still possible to accurately measure the resource usage of each account and calculate quota consumption? The answer is yes.  As shown in Figure 2, if explicit timestamps are used in the original manner, then in two consecutive time slots from snapshot #N-2 to snapshot #N account A created 4 transactions, and account B created 2.</p> <p>With implicit timestamps, in one time slot between snapshot #N-1 and snapshot #N, 2 transactions were confirmed for account A, and 1 transaction for account B.  In this way, according to the total amount of resources consumed by transactions confirmed in each account within fixed period, average resource consumption can still be accurately measured. This allows discovering whether a new transaction will exceed the account' quota.  Indeed, since the creation and confirmation of transactions are asynchronous in Vite, and because both transaction propagation and account state calculation take time, a small calculation gap may result from this mechanism.</p> <p>However, it is reasonable to reduce the gap by extending statistical cycle, which means calculating average resource consumption for a longer period of time.  In Vite's system, as long as the calculation scheme of resource consumption for different accounts is kept the same, this quota model based on confirmation time is feasible.</p>"},{"location":"vep/vep-5/#conclusions","title":"Conclusions","text":"<p>Based on the discussion above, this proposal suggests to remove all explicit timestamps from Vite's ledger and keep only implicit timestamps.</p> <p>In this proposal, although the exact creation time of transaction is no longer saved on chain and as consequence losing some semantics depending on timestamp, in general the impact is very limited.  Particularly, quota model and related resource consumption calculation can still be implemented with implicit timestamp, aka \"confirmation time\".</p> <p>This proposal can bring the following optimizations:</p> <ul> <li>Remove two-way dependency between DAG ledger and snapshot chain, so they can be constructed asynchronously</li> <li>Simplify rollback processing to increase system throughput</li> <li>Remove the need to re-sign transaction after rollback, and therefore simplifying client processing logic</li> <li>Reduce the size of DAG ledger</li> </ul>"},{"location":"vep/vep-6/","title":"VEP 6: Vite URI Formatting","text":""},{"location":"vep/vep-6/#introduction","title":"Introduction","text":"<p>This specification defines standard URI format used in Vite</p>"},{"location":"vep/vep-6/#syntax","title":"Syntax","text":"<pre><code>request                 = \"vite\" \":\"[target_address] [ \"@\" chain_id ] [ \"/\" function_name ] [ \"?\" parameters ]\ntarget_address          = vite_address\nchain_id                = 1*DIGIT\nfunction_name           = STRING\nvite_address            = ( \"vite_\" 50*HEXDIG ) / VNS_NAME\nparameters              = parameter *( \"&amp;\" parameter )\nparameter               = key \"=\" value\nkey                     = \"tti\" / \"amount\" / \"fee\" / \"data\"\nvalue                   = number / vite_address / token_type_id / STRING\ntoken_type_id           = \"tti_\" 24 *HEXDIG\nnumber                  = [ \"-\" / \"+\" ] *DIGIT [ \".\" 1*DIGIT ] [ ( \"e\" / \"E\" ) [ 1*DIGIT ]\n</code></pre> <p>STRING - A <code>URLEncode</code> string, using % to escape all of delimiters. Delimiters that need to be escaped include @/?&amp;=%:</p> <p>number - A number represented in scientific notation</p> <p>VNS_NAME - Vite name service. Specific standard is being worked out</p>"},{"location":"vep/vep-6/#syntax_1","title":"Syntax","text":"Field Description target_address It indicates transfer address when transferring and refers to contract address when calling smart contract chain_id Identify MainNet, TestNet and private net. This part can be omitted, and then use current network type of client side function_name Function name of calling smart contract, if it's contract calling, there must be '/' mark, if there isn't, the calling is a common transfer. function_name can be an empty string, which indicates default contract method of current address. Attention: currently when we call smart contract, contract method signature and parameter information can be represented by setting data field, thus function_name do not do any analyse work, and you can call smart contract by specifying function_name and contract parameters by then. parameters params, key including \"tti\" / \"amount\" / \"fee\" / \"data\""},{"location":"vep/vep-6/#parameters","title":"Parameters","text":"key value Description Example tti token_type_id Specify transfer Token Id, optional. If it's omitted that means Vite Token is making the transfer. tti=tti_5649544520544f4b454e6e40 amount number Specify transfer amount, unit follows token's basic unit. For instance, transfer 1 VITE equals amount = 1, optional. If it's omitted means amount = 0 amount=1e-3\uff0camount=1000\uff0camount=0.04 fee number Specify Vite volume that need to be destroyed, unit is Vite's common unit, optional. If it's omitted means fee = 0 Same as amount data base64 url safe encode It means remarks when transferring, remarks need to comply with the conventional format in VEP-8, also it represents method signature and parameter information when calling smart contract data=MTIzYWJjZA"},{"location":"vep/vep-6/#examples","title":"Examples","text":"Example Description vite:vite_fa1d81d93bcc36f234f7bccf1403924a0834609f4b2e9856ad Represent account address vite_fa1d81d93bcc36f234f7bccf1403924a0834609f4b2e9856ad vite:vite_fa1d81d93bcc36f234f7bccf1403924a0834609f4b2e9856ad?tti=tti_5649544520544f4b454e6e40&amp;amount=1&amp;data=MTIzYWJjZA Transfer 1 VITE to vite_fa1d81d93bcc36f234f7bccf1403924a0834609f4b2e9856ad with a comment of \u201c123abcd\u201d vite:vite_fa1d81d93bcc36f234f7bccf1403924a0834609f4b2e9856ad/echo?amount=1&amp;data=MTIzYWJjZA Call 'echo' method of contract vite_fa1d81d93bcc36f234f7bccf1403924a0834609f4b2e9856ad"},{"location":"vep/vep-7/","title":"VEP-7: Merge In-Contract Request Calls into Original Response as one Transaction","text":""},{"location":"vep/vep-7/#background","title":"Background","text":"<p>In Section 2.2(Definition of Ledger) of Vite White Paper, it explicitly defines:</p> <p>Transactions are divided into request and response transactions, each of which corresponds to a separate block, each account Ai corresponds to a chain, a transaction pair, and a response transaction referencing the hash of its corresponding request transaction.</p> <p>In Vite, a request call to a smart contract may influence the status of multiple contracts or accounts. At this time, several new request transactions will be created and sent out after the response transaction is complete.</p> <p>Let's see an example. User A sends a request transaction A1 to contract B, which executes business logic in a response transaction B1 and creates two new request transactions B2 and B3.  Here B2 is a transfer transaction to user C while B3 calls contract D. Correspondingly, account C and contract D create related response transactions C1 and D1. In this example, 3 request blocks A1, B2, B3 and 3 response blocks B1, C1, D1 are created all together.</p> <p>Figure 1</p>"},{"location":"vep/vep-7/#pros-and-cons-of-current-design","title":"Pros and Cons of Current Design","text":"<p>As shown in Figure 1, from the perspective of business logic, response transaction B1 and request transactions B2 and B3 can be deemed as one operation. But they are split into 3 blocks in practice.</p> <p>Pros:</p> <ul> <li>Request transaction and response transaction are paired up, resulting in neater ledger structure. It is also convenient to query un-received transactions or transaction status (responded or not).</li> </ul> <p>Cons:</p> <ul> <li> <p>It is difficult to implement ACID semantic for in-contract request calls. In order to verify the response transaction of a contract, all relevant request transactions initiated by the response transaction should be verified at the same time because in-contract request transactions inherit the original response transaction's context and cannot be verified separately.  Meanwhile, since all the transactions must be propagated independently in the network, if a specific node is down after sending out the response before broadcasting the newly-initiated request transactions, the contract chain will become incomplete due to missing blocks.</p> </li> <li> <p>Data redundancy has been caused on chain due to duplicated information stored both in response and requests. This includes block producer, block height, previous block hash and etc.</p> </li> </ul> <p>Tip</p> <p>Currently in TestNet, ACID on contract response-requests is guaranteed by removing signatures on in-contract request transactions, discarding in-contract request transactions received from the network but generating them by each node itself upon verification (the virtual machine will ensure the same transactions are generated on each node). </p>"},{"location":"vep/vep-7/#pros-and-cons-of-proposed-design","title":"Pros and Cons of Proposed Design","text":"<p>In the proposed design, in-contract request block B11 and B12 are merged into B1. As shown in Figure 2, the new design creates 1 request block A1 and 3 response blocks: B1, C1 and D1.</p> <p>Figure 2</p> <p>Pros:</p> <ul> <li> <p>ACID is guaranteed perfectly in nature since the response transaction and in-contract request transactions are written into one block</p> </li> <li> <p>Duplicated data are removed since blocks are merged</p> </li> <li> <p>Request-response pair is retained since independent transaction hash is kept in the request, facilitating queries for un-received transactions or transaction status</p> </li> </ul> <p>Cons:</p> <ul> <li>None</li> </ul>"},{"location":"vep/vep-7/#conclusion","title":"Conclusion","text":"<p>Based on the discussion above, this proposal suggests to merge in-contract request transactions into original response as one transaction, and keep request transaction hash.</p> <p>The merged block may contain a response transaction and multiple request transactions. This will bring following benefits:</p> <ul> <li> <p>ACID compliance on contract response transaction and newly-initiated in-contract request transactions in a graceful way. Easier for verification and transmission</p> </li> <li> <p>Lighter ledger space</p> </li> </ul>"},{"location":"vep/vep-8/","title":"VEP 8: AccountBlock Data Content Type Definition","text":""},{"location":"vep/vep-8/#background","title":"Background","text":"<p>In general, the data field in account block can be used to carry additional information to meet specific demands when sending transaction through <code>tx_sendRawTx</code> API.  This document explains the content definition in details.</p>"},{"location":"vep/vep-8/#implementation","title":"Implementation","text":"<p>We propose to set a 2-byte content type flag at beginning of data field to indicate what type of data is followed. </p> <p>Content type is a <code>uint16</code> number stored in big endian format. Number 1 (0x0001) - 2048 (0x0800) are reserved and should not be used by a third party.</p> <p>Restriction</p> <p>It is known that content type might be occasionally mis-recognized under the situation calling a smart contract, due to messing-up with the first 2 bytes of a hitting method hash.</p>"},{"location":"vep/vep-8/#defined-types","title":"Defined Types","text":""},{"location":"vep/vep-8/#general-type","title":"General Type","text":"Type Type(Hex) Description Binary data 0x0001 Reserved. Not in use."},{"location":"vep/vep-8/#custom-type","title":"Custom Type","text":"Type Type(Hex) Description Vite Grin wallet index 0x8001 Data of Grin transaction index ViteX gateway data 0x0bc3 Data of cross-chain transaction of ViteX gateway"},{"location":"vite-basics/","title":"What Is Vite And What Makes Vite Different","text":"<p>Blockchain is a technology that allows users to trust that the Internet computer programs they interact with will operate \"as is.\" This means the blockchain gives assurance that the programs will be executed according to the associated open source code. This is made possible due to the tamper-resistant nature of the data and code instructions (\"smart contracts\") stored on the blockchain. Any attacker will have a hard time altering said data and smart contracts once they have been added to the blockchain.</p> <p>There are many approaches to designing a blockchain. In general, a practically usable blockchain should have the following features:</p> <ul> <li>Scalability: The chain should be able to process large number of transactions per unit of time to accommodate real-world applications.</li> <li>Fast finality: It doesn't take too long for a transaction to be considered irreversable, otherwise crippling practical commerce.</li> <li>Affordability: The fees for using a blockchain should not be prohibitively expensive.</li> <li>Security: The potential power to reverse transactions should be distributed widely to avoid attacks by a small group of colluders.</li> </ul> <p>Vite was designed to take all the above features into account. In particular, Vite shines in facilitating fast-finality transactions at exactly zero fees. Vite is able to accomplish this with the following designs:</p> <ul> <li>Token locking model: Instead of requiring fees (e.g., gas for Ethereum), Vite users lock VITE tokens to secure the resources needed for transactions.</li> <li>Asynchronous architecture: Allow parallel processing for both payment transactions and smart contract calls. De-couple a send from a receive for payment transactions. De-couple invocation and execution for smart contract calls.</li> <li>Directed Acyclic Graph ledger: Each account has its own blockchain, and transactions are confirmed as they are appended to the respective individual chains.</li> <li>Hierarchical Delegated Proof of Stake: The basic version of Delegated Proof Of Stake (DPOS) lets a set of voted-in validators take turns validating the network. \"Hierarchical\" allows each contract to specify its own group of such validators (aka \"consensus group\"), which defaults to the global consensus group (or snapshot consensus group)</li> </ul> <p>Now that you have a basic idea for what Vite does and how it's different, you may want to learn more about various components of the Vite stack. You can also begin developing on the Vite chain by checking out Solidity++, the front-end, common patterns, and Vite Express.</p>"},{"location":"vite-basics/smart-contract/","title":"Smart Contracts","text":"<p>Smart contracts are immutable programs deployed on the blockchain.</p>"},{"location":"vite-basics/smart-contract/#consensus-groups","title":"Consensus Groups","text":"<p>Each smart contract can have its own group of nodes (\"Delegated Consensus Group\") that take turns confirming the transactions sent/received by said contract.</p> <p>Similar to Snapshot Consensus Group, all delegated nodes will be publicly elected according to the election rules defined in the delegated consensus group. The number of delegated nodes is defined by the group upon creation, and there is no limit to the number of such consensus groups in the network.</p> <p>These delegated consensus groups allow for faster confirmation of transactions, because the nodes are only responsible for executing transactions for the said smart contract, not the entire network.</p> <p>By default, the consensus group for smart contracts is the Snapshot Consensus Group (aka Global Consensus Group).</p>"},{"location":"vite-basics/smart-contract/#response-latency","title":"Response Latency","text":"<p>To throttle response transactions, a smart contract can set up the Response Latency parameter when it is deployed. The response latency parameter specifies, for any incoming request transaction, the number of snapshot blocks that need to be confirmed before the contract responds. That is, the contract will wait at least that many snapshot blocks before producing a response block.</p> <p>The value of this parameter is a number between 0 and 75, inclusive. 0 means there is no waiting period and a response block will be produced immediately. If the contract makes uses of timestamp, snapshot block height or random number, this parameter must be positive.</p> <p>Generally speaking, a bigger response latency means slower contract response, and the response transaction will consume more quota.</p>"},{"location":"vite-basics/smart-contract/#random-degrees","title":"Random Degrees","text":"<p>When deploying a smart contract, the Random Degree parameter specifies the degree of confidence in the randomness being generated. The bigger random degree, the more secure the random number generation process, and the slower the contract producing response block. The value of random degree is between 0 and 75. If your contract uses random numbers, this parameter must be positive. Select a random degree that befits your contract's needs.</p> <p>There are two functions for getting random numbers in Solidity++.</p> <pre><code>// return a random number. The value returned does not change if called within the same transaction\nuint64 random = random64();\n// return a random number. The value returned is different with each call\nuint64 random = nextrandom();\n</code></pre> <p>For any given contract, it must hold $0 \\le RandomDegree \\le ResponseLatency \\le 75$</p> <p>Refer to VEP 12: The Implementation of Random Numbers in Vite for details of random numbers.</p>"},{"location":"vite-basics/smart-contract/#quota-multiplier","title":"Quota Multiplier","text":"<p>Sometimes the deployer of a smart contract may want contract callers to spend more than the usual amount of quota, perhaps for anti-spamming purposes. The Quota Multiplier parameter facilitates this, and is specified at contract deployment. The value ranges from 10 to 100, equivalent to 1-10x quota consumption. For example, 15 means that 1.5x quota will be charged for any address that calls the contract.</p> <p>See here for rules on quota consumption.</p>"},{"location":"vite-basics/smart-contract/#library-linking","title":"Library Linking","text":"<p>Libraries in Solidity++ retain the same syntax and usage as in Solidity. In most cases, libraries are pieces of reusable code that consist of functions used by other contracts. They help prevent code duplication and can effectively reduce the size of code.</p> <p>In the Vite network, libraries are a special form of contracts that:</p> <ul> <li>Are singletons</li> <li>Do not allow any storage or state variables that change</li> <li>Cannot have fallback functions</li> <li>Have no event logs</li> <li>Are stateless</li> <li>Cannot inherit or be inherited</li> </ul> <p>Libraries allow adding functionality to types. For example, one can use the SafeMath library to enhance the functionality of a <code>uint</code> variable in a contract.</p> <pre><code>using SafeMath for uint;\n</code></pre> <p>Using a library in the smart contract is called library linking. The following example shows Contract A using a library L to compute $2\\times a$</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\npragma soliditypp &gt;=0.8.0;\n\nlibrary L { \n    function double(uint self) public returns (uint) { \n        // do something with side effects\n        return 2 * self;\n    }\n}\n\ncontract A {\n    using L for uint;\n    uint public data;\n\n    function f(uint a) public returns (uint) {\n        data = a.double();\n        return data;\n    }\n}\n</code></pre>"},{"location":"vite-basics/token-model/","title":"Token Model","text":"<p>A token is a digital asset created on a blockchain. Below we'll cover a number of operations related to token management, including: minting (creating tokens), burning (destroying tokens), re-issuance (follow-on mintings), and ownership transfers.</p>"},{"location":"vite-basics/token-model/#token-design","title":"Token design","text":"<p>The Vite network allows users to issue tokens natively. This means a user can send a mintage transaction to issue a new token, and token balances are maintained in each Vite address. Token transfers will change balances in respective users' accounts. This is different from Ethereum's popular token design (ERC20), where each token is represented by a smart contract that maintains a holder-amount mapping, and token transfers don't change the status of user's accounts.</p> <p>There are at least four reasons for choosing to design Vite tokens this way: 1. Security: Users control their own assets. There is no danger of accidentally approving malicious third-parties in sending tokens from your account, unlike in ERC20 2. Uniformity: Different assets follow the same protocol and the same algebra. So issues such as over-issuance, underflow or overflow. 3. User-friendliness: No code needs to be written for token issuance, and no contracts need to be deployed, unlike ERC20. 4. Fair-fees: Users pay for storage of their own assets only. In contrast, when a user transfers ERC20 assets to a new address, they will be charged an additional gas fee to create a new balance mapping entry in the contract for that address.</p>"},{"location":"vite-basics/token-model/#token-id","title":"Token ID","text":"<p>The type of token (e.g., \"VITE,\" \"VX,\" \"VCP\") is represented by a Token Type ID (TTI or Token ID), which is a unique 28 chars hex string consisting of three parts:</p> <ul> <li>\"tti_\": 4-char fixed prefix</li> <li>TTI<sub>body</sub>: a 10 bytes array, also called Original Token ID</li> <li>Checksum: a 2-byte BLAKE2b checksum of TTI<sub>body</sub></li> </ul> <p>The TTI<sub>body</sub> or original token id is derived as:</p> <p>$$TTI_{body} = blake2b(IssuerAddress + MintageBlockHeight + PrevBlockHash)$$</p>"},{"location":"vite-basics/token-model/#minting","title":"Minting","text":"<p>Anyone can send a mintage transaction to issue an new token. The sender's address will subsequently receive the new token in an amount equivalent to the specified total supply in said mintage transaction. </p> <p>Issuing a new token will cost 1,000 VITE. These tokens will be burned.</p> <p>Parameters for the mintage transaction: </p> <ul> <li>Token Name: 1-40 characters, including uppercase/lowercase letters, spaces and underscores. Consecutive spaces or starting/ending with space is not allowed.</li> <li>Token Symbol: 1-10 characters, including uppercase/lowercase letters, spaces and underscores. Cannot use <code>VITE</code>, <code>VCP</code> or <code>VX</code>.</li> <li>Total Supply: A number between 0 and 2<sup>256</sup>-1. For re-issuable tokens this is the initial total supply.</li> <li>Decimals: Decimal places. It must hold $10^{Decimals} \\leq TotalSupply$. Enter 0 if the token has no decimal places.</li> <li>ReIssuable Flag: If set, minting additional tokens is possible after the token is issued.</li> <li>Max Supply: Specify the maximum supply of the token. This must hold: $TotalSupply \\leq MaxSupply \\leq 2^{256}-1$. For non-reissuable tokens, this parameter should be set to zero.</li> </ul>"},{"location":"vite-basics/token-model/#burning","title":"Burning","text":"<p>A burn transaction can be initiated to destroy tokens and reduce the total supply accordingly.</p> <p>Parameters for the burn transaction: * Token ID * Burning Amount: the burning amount will be deducted from the address that sends the burn transaction. After the transaction is confirmed, the total supply of the token is reduced.</p> <p>Only re-issuable tokens can be burned.</p>"},{"location":"vite-basics/token-model/#ownership-transfer","title":"Ownership Transfer","text":"<p>Note this ownership transfer refers to a change in certain rights to the token. For instance, only the current owner of a re-issuable token is allowed to mint tokens. This concept of ownership transfer is different from the idea of moving units of tokens from one address to another (e.g., sending 50 VITE to another address).</p> <p>Owner has rights to perform the following operations:</p> <ul> <li>Re-issue</li> <li>Burn</li> <li>Transfer token ownership</li> <li>Disable re-issuance</li> <li>Open new market in ViteX</li> </ul> <p>Only re-issuable tokens can be transferred. To effect the transfer, the current owner should send an ownership transfer transaction. A token can only have one owner.</p> <p>Parameters for the ownership transfer transaction: * Token ID * New Owner: Address of the new owner</p>"},{"location":"vite-basics/token-model/#re-issuance","title":"Re-issuance","text":"<p>After the initial minting, the owner can mint additional units of re-issuable tokens by sending a re-issuance transaction.</p> <p>Parameters for the re-issuance transaction:</p> <ul> <li>Token ID</li> <li>Amount: Additional amount to issue</li> <li>Receive Address: Address to receive newly minted tokens</li> </ul>"},{"location":"vite-basics/token-model/#disabling-re-issuance","title":"Disabling Re-issuance","text":"<p>The owner of a re-issuable token can initiate a transaction to make the token non-reissuable. Note this operation cannot be reversed, and the token's supply will be permanently capped.</p> <p>Parameters for the transaction to disable re-issuance: * Token ID</p>"},{"location":"vite-basics/token-model/#token-index","title":"Token Index","text":"<p>Token can have the same symbol, e.g. \"BTC\". In order to distinguish tokens with the same symbol, a distinct index from <code>000</code> to <code>999</code> is allocated when the token is issued. Token index cannot exceed 999.</p> <p>Built-in tokens VITE, VX and VCP do not have index.</p>"},{"location":"vite-basics/token-model/#built-in-tokens-on-vite","title":"Built-in Tokens on Vite","text":"<p>VITE (Vite's native coin), VX (ViteX Coin -- the token for ViteX, a decentralized exchange on Vite) and VCP (Vite Community Points -- used for purchasing merch at the Vite store) are the initial set of tokens on Vite.</p> Token ID Token Name Token Symbol Total Supply Decimals tti_5649544520544f4b454e6e40 Vite Coin VITE 1 billion (initial) 18 tti_251a3e67a41b5ea2373936c8 Vite Community Point VCP 10 billion 0 tti_564954455820434f494e69b5 ViteX Coin VX 10 million 18"},{"location":"vite-basics/consensus/","title":"Index","text":"<p>order: false parent:     title: Consensus     order: 3</p>"},{"location":"vite-basics/consensus/snapshot-block-producer/","title":"Snapshot Block Producer","text":"<p>Snapshot Block Producer, also known as SBP, is a delegated node in the Vite network. The SBP's primary function is to secure the network. It does so by producing blocks (\"snapshot blocks\") that each stores a snapshot of the ledger. This snapshot includes the balance of the account, the Merkle root of the contract state, and the hash of the last block of each account chain. </p> <p>Definitions: * SBP Name: A string of 1-40 characters, including alphabet characters, numbers, underscores, dots and space. The SBP name must be unique. Consecutive spaces and initial/trailing spaces are not allowed. SBP name must be assigned at registration and cannot be changed afterwards. * A Round: approximately 75 seconds, in which votes of SBPs are re-calculated. Ideally, 75 snapshot blocks are produced in a round. * A Cycle: Equivalent to 1152 rounds, approximately one day. * Registration Address: Also known as SBP Owner. This is the address where the SBP is registered. * Block Creation Address: The address on the SBP node used for producing snapshot blocks. * Reward Withdrawal Address: The SBP owner can designate a separate address eligible for retrieving SBP rewards on the owner's behalf.</p>"},{"location":"vite-basics/consensus/snapshot-block-producer/#sbp-registration","title":"SBP Registration","text":"<p>Registering SBP is a permissionless process. The registration address must stake 1,000,000 VITE, send an SBP Registration transaction, and wait till its confirmation.</p> <p>The 1 million VITE will be locked for 3 months (7776000 snapshot blocks).</p> <p>After the lock-up period expires, the SBP owner (registration address) can cancel the registration and retrieve the locked fund through a Cancel Registration transaction. The canceled SBP will be removed from the list of SBPs after confirmation of the cancel transaction.</p> <p>For safety, SBP owners are advised to use three different Vite addresses for registration, block production and rewards retrieval.</p>"},{"location":"vite-basics/consensus/snapshot-block-producer/#how-an-sbp-works","title":"How an SBP Works","text":"<p>Each SBP is responsible for maintaining consensus of the ledger by recording the ledger state in snapshot blocks. The snapshot blocks are chained together, where each block refers to the hash of the previous snapshot block, forming the Snapshot Chain.</p> <p>In each round of 75 seconds, 25 SBPs are selected to produce new blocks, and each selected SBP will get to produce 3 consecutive blocks.</p> <p>Rules for the selection process: * 23 SBPs are randomly selected from the top 25 SBPs. * 2 SBPs are randomly selected from the SBPs ranking from 26 to 100.</p> <p>The SBPs are ranked by votes from VITE holders. In each round, votes are re-calculated to rank the SBPs for the following round.</p>"},{"location":"vite-basics/consensus/snapshot-block-producer/#sbp-rewards","title":"SBP Rewards","text":"<p>VITE has a fixed annual inflation of 30 million coins. As a percentage of the total supply, the inflation starts at 3% and declines steadily every year. All the inflated amounts are distributed to SBPs as rewards. On the Vite Mainnet, the reward for each snapshot block is ${0.951293759512937595}$ VITE.</p> <p>The rewards are equally split into two parts:</p> <ul> <li> <p>50% goes to SBPs, proportionate to the number of blocks each produced (Block Creation Reward).</p> </li> <li> <p>50% goes to the top 100 SBPs (Candidate Additional Reward), per rules below.</p> </li> </ul> <p>Distributing Candidate Additional Reward:</p> <ul> <li>Distribute proportionately to the votes each SBP received in the last round of the cycle.</li> <li>Rewards are generated daily, precisely in every 1152 rounds.</li> <li>In each cycle, the SBP's up-time is calculated as $\\frac{Total Blocks Produced}{Total Blocks On Target}$.</li> </ul>"},{"location":"vite-basics/consensus/snapshot-block-producer/#rewards-calculation","title":"Rewards Calculation","text":"<p>There are 1152 rounds in a cycle. On the Vite Mainnet, the first cycle started at 04:00 UTC, May 21, 2019.</p> <p>Total eligible rewards for an SBP (S) in one cycle (Q) is calculated as:</p> <p>$$Q = 0.5\\frac{n}{m}\\frac{V}{W}XR + 0.5nR$$</p> <p>Here: * <code>n</code>: the number of blocks produced by the SBP S in one cycle * <code>m</code>: the number of blocks expected to be produced by the SBP S in one cycle. If no SBP successfully produces blocks in a round, m should be reduced by the target number of blocks produced for SBP S in that round. * <code>X</code>: the total number of blocks produced by all the SBPs in one cycle * <code>W</code>: the total votes received by the top 100 SBPs in the last round of a cycle, plus the total staked VITE for registration of all the top 100 SBPs (1M VITE for each SBP in the Mainnet) * <code>V</code>: the votes received by the SBP in the last round of a cycle, plus the staked VITE for registration of this node (1M VITE for each SBP in the Mainnet) * <code>R</code>: Block Creation Reward, 0.951293759512937595 VITE per block.</p> <p>Note:</p> <ul> <li>Per the formula above, if an SBP ranks below top 100 in the last round of a cycle, the reward for that SBP in this cycle is 0</li> <li>There is no reward for the first cycle after the SBP is registered.</li> <li>There is no reward for the last cycle when the SBP is canceled.</li> <li>If all SBPs produced zero block in aggregate in a round, this round will be excluded from reward calculation (total target blocks of this round will be set to zero)</li> </ul>"},{"location":"vite-basics/consensus/snapshot-block-producer/#rewards-withdrawal","title":"Rewards Withdrawal","text":"<p>Rules:</p> <ul> <li>A reward withdrawal transaction must be initiated from the registration address, or a reward withdrawal address (as designated by the registration address).</li> <li>When withdrawing rewards, only blocks generated 48 rounds (1 hour) or earlier is eligible for rewards calculation. Blocks that were generated in the recent 48 rounds will not be included in the calculation. </li> <li>Rewards can be withdrawn to any valid Vite address.</li> </ul>"},{"location":"vite-basics/consensus/snapshot/","title":"Snapshot","text":""},{"location":"vite-basics/consensus/snapshot/#snapshot-block-and-snapshot-chain","title":"Snapshot Block and Snapshot Chain","text":"<p>Per definitions in the Vite whitepaper,</p> <p>A snapshot block stores a snapshot of the ledger's state. This includes the balance of the account, the Merkle root of the contract state, and the hash of the last block in each account chain. The snapshot chain is a chain structure composed of snapshot blocks, and each snapshot block refers to the hash of the previous snapshot block. The state of each user account contains the account balance and the hash of the last block of the account chain. In addition to the aforementioned two fields, the state of a contract account also contains its own Merkle root hash.</p> <p>The structure of account state and snapshot block is as follows: </p> <pre><code>struct AccountState { \n    map&lt;uint32, uint256&gt; balances;\n    optional uint256 storageRoot; \n    uint256 lastTransaction; \n} \n\nstruct SnapshotBlock { \n    uint256 prevHash;\n    map&lt;address, AccountState&gt; snapshot;\n    uint256 signature; \n}\n</code></pre> <p>The first snapshot block in the snapshot chain is called Genesis Snapshot, which saves the initial states of all the accounts on the blockchain. </p>"},{"location":"vite-basics/consensus/snapshot/#snapshot-chain-and-consensus","title":"Snapshot Chain and Consensus","text":"<p>The snapshot chain is a novel blockchain structure composed of snapshot blocks, which are produced by a group of delegated nodes following DPoS consensus algorithm. These nodes are called Snapshot Block Producers (SBP). </p> <p>Since each snapshot block in the snapshot chain corresponds to a particular state of the Vite ledger, one can obtain the post-consensus ledger solely from the relevant snapshot block, as long as there is no fork in the network.</p> <p>When a delegated node sees forks on any account chain, the delegated node will be responsible for selecting the \"correct\" account chain and reach consensus with other delegated nodes.</p> <p>If there is a fork in the snapshot chain, the longest branch will be chosen as the correct chain. As appropriate, the snapshot blocks on the original branch will be discarded, and the transactions in these blocks will be reverted. The snapshot chain is the keystone of Vite's consensus. </p> <p>More information about the snapshot chain here.</p>"},{"location":"vite-basics/consensus/snapshot/#snapshot-compression","title":"Snapshot Compression","text":"<p>Saving account states in every snapshot block may consume considerable storage space, hence the necessity for data compression. </p> <p>The basic approach of compression is an incremental storage scheme, in which a snapshot block only stores state changes for accounts with new transactions since the previous snapshot block. This means that if an account incurs no transactions between snapshot blocks, the later snapshot block won't include that account's state. Thus, when recovering ledger states, one cannot rely on a single snapshot block, but must traverse from the first snapshot block to the current. The longer time needed for ledger recovery is a reasonable tradeoff for storage saving, since ledger recovery is an uncommon operation.</p>"},{"location":"vite-basics/consensus/snapshot/#engineering-implementation","title":"Engineering Implementation","text":"<p>In the implementation of <code>go-vite</code>, we simplify the <code>AccountState</code> into <code>SnapshotData</code> to reduce block size for better network propogation.</p> <pre><code>struct SnapshotData { \n    uint256 height; // account block height\n    uint256 hash; // account block hash\n} \n\nstruct SnapshotBlock { \n    uint256 prevHash;\n    map&lt;address, SnapshotData&gt; snapshot;\n    uint256 signature; \n}\n</code></pre> <p>Note</p> <p>For each snapshotted account, if more than one transaction took place during the snapshot, only the last transaction is included in the snapshot block, while the previous transactions can be fetched through a ledger API.</p>"},{"location":"vite-basics/consensus/voting/","title":"Voting","text":"<p>Definitions: * Voting\uff1aAn on-chain governance behavior by calculating the VITE coins (or other possible tokens) held by voters to elect SBP (or delegate nodes in consensus groups). * Consensus group: A group of nodes that are selected to produce snapshot blocks (Snapshot consensus group), send/receive transactions (Private consensus group) or execute smart contracts (Delegated consensus group) through voting. * SBP\uff1aThe delegate node in snapshot consensus group and eligible for producing snapshot blocks. * Delegate node\uff1aThe node in a consensus group and eligible for producing certain blocks for the consensus group.</p>"},{"location":"vite-basics/consensus/voting/#voting-and-consensus-group","title":"Voting and Consensus Group","text":"<p>There are two kinds of voting on Vite.</p> <ul> <li>Voting for SBP</li> <li>Voting for delegate node in a delegated consensus group</li> </ul> <p>Smart contract may assign a delegated consensus group to execute. One can vote for the node in the group with any token the consensus group has specified.</p> <p>Snapshot consensus group has id \"00000000000000000001\". It consists of the top 100 SBPs. The same SBPs also comprise the default delegated consensus group for all smart contracts that don't assign a consensus group. The default delegated consensus group id is \"00000000000000000002\".</p> <p>The default delegated consensus group is also called global consensus group.</p> <p>Private consensus group doesn't need vote because it is always composed of the node/account itself. </p> <p>Note: The feature of consensus group will be fully opened in a future version</p>"},{"location":"vite-basics/consensus/voting/#voting-rules","title":"Voting Rules","text":"<p>One can * Vote for an SBP at any time * Re-vote for a different SBP at any time * Withdraw vote at any time (voting has no locking period) * Vote for multiple consensus groups at the same time</p> <p>One can NOT * Vote for multiple SBPs at the same time * Vote for multiple delegate nodes in the same consensus group at the same time * Vote for delegate node in global consensus group since they must be the same nodes in snapshot consensus group</p>"},{"location":"vite-basics/consensus/voting/#voting-rewards","title":"Voting Rewards","text":"<p>Voting can or cannot have rewards. Distributing voting rewards to individual voters is not built in Vite's protocol. Thus, it is completely the responsibility of every SBP (or delegate node in delegated consensus group) to decide whether (and how) to distribute voting rewards to the voters.</p> <p>List of SBPs that distribute rewards</p> <p>Vite community maintains a list on which the SBPs distribute voting rewards to supporters. Ask the CM for the list!</p>"},{"location":"vite-basics/cryptography/","title":"Index","text":"<p>order: false parent:     title: Cryptography     order: 4</p>"},{"location":"vite-basics/cryptography/address-derivation/","title":"Address Derivation","text":"<p>A Vite address is a 55-character string with three parts: First, the \"vite_\" prefix; second, a 160-bit BLAKE2b hashed public key of Ed25519 cryptographic elliptic curve from a seed; and third, a 40-bit checksum of the public key's hash. Note that the second and third parts are in Hex encoding.</p> <p>$$Address = vite_ + Hex(PubHash + Checksum(PubHash))$$</p> <p>The public/private keypair is derived in the following steps.</p> <ul> <li>Generate a random BIP-39 encoded 128/256 bits entropy with 12/24 mnemonic phrase.</li> <li>Generate a BIP-39 seed from the mnemonic phrase, with an optional passphrase (default is empty).</li> <li>Generate the master key from the HMAC-SHA512 hashed seed, using key \"ed25519 blake2b seed\".</li> <li>Derive the BIP-44 Ed25519-BLAKE2b keypair from the master key with coin_type 666666. </li> </ul> <p>We modified the Ed25519 signature scheme to use BLAKE2b instead of SHA-2.</p>"},{"location":"vite-basics/cryptography/address-derivation/#derivation-path","title":"Derivation Path","text":"<p>See VEP 3: Vite Wallet Key Derivation for more information about the BIP-32 path pattern of Vite.</p>"},{"location":"vite-basics/cryptography/address-derivation/#original-address","title":"Original Address","text":"<p>We concatenate the 20-byte binary address and an additional 1-byte type flag into the 21-byte Original Address to determine if an address is a smart contract. See VEP-16: Specification of Address Generation for details.</p>"},{"location":"vite-basics/cryptography/address-derivation/#key-derivation-function-and-keystore","title":"Key Derivation Function and Keystore","text":"<p>Key Derivation Function (KDF) derives subkeys from a single master key. The derivation process expands a short string into certain formats via KDF algorithms. KDF is similar to a hash function, but the former involves adding random variables to prevent table-lookup attacks (e.g. rainbow tables). For private key encryption and keystore generation, Vite uses Scrypt, a memory-dependent KDF. Brute-force attacks on KDF are nearly impossible to succeed, as they will consume prohibitive amount of memory.</p> <p>On Vite, the private key is encrypted and stored in the keystore in the following steps:</p> <ul> <li>Encrypt a random keystore/wallet password entered by the user through Scrypt to get a 256bits AES-256-GCM encryption key.</li> <li>Generate the keystore with derived Scrypt parameters.</li> <li>Save the AES-256-GCM encrypted private key into the keystore file.</li> </ul>"},{"location":"vite-basics/cryptography/hash-algorithm/","title":"Hashing Algorithms","text":"<p>In the Vite network, hash function serves many purposes including compression, protection and tamper-proofing of data.</p>"},{"location":"vite-basics/cryptography/hash-algorithm/#hash-algorithm-blake2b","title":"Hash algorithm \u2014 BLAKE2b","text":"<p>Vite uses BLAKE2b for various purposes, including producing blocks, generating keypairs and addresses, and tamper-proofing of data.</p>"},{"location":"vite-basics/cryptography/hash-algorithm/#security","title":"Security","text":"<p>BLAKE2 essentially relies on the same core algorithm as BLAKE, which has been battled-tested since 2008. BLAKE2 was endorsed by NIST (National Institute of Standards and Technology). See NIST's report here.</p> <p>Among variations of BLAKE2, BLAKE2b is optimized for 64-bit platforms.</p>"},{"location":"vite-basics/cryptography/hash-algorithm/#performance","title":"Performance","text":"<p>BLAKE2 is fast because it takes advantage of features of modern CPUs, such as instruction-level parallelism, SIMD instruction set extensions, and multiple cores. BLAKE2 is faster than MD5, SHA-1, SHA-2, and SHA-3. And BLAKE2 beats any other hash algorithm on generic CPUs (X86 ARM, etc). See here for detailed performance data.</p>"},{"location":"vite-basics/cryptography/signing/","title":"Signing","text":"<p>Signature algorithms give proof that signers of messages must be in possession of the relevant private key. The Vite network uses signature algorithms to generate account addresses and create transactions.</p>"},{"location":"vite-basics/cryptography/signing/#digital-signature-algorithm-ed25519","title":"Digital Signature Algorithm \u2014 Ed25519","text":"<p>Vite uses Ed25519 as its signature algorithm. The algorithm is basically EdDSA instantiated over curve Edwards25519.</p> <p>Ed25519 was introduced in 2011 by Bernstein in the paper High-speed high-security signatures. The algorithm's efficiency led to its popularization in modern applications, and its adoption in TLS 1.3, SSH, Tor, ZCash, and messaging protocols based on the Signal protocol such as WhatsApp.</p>"},{"location":"vite-basics/cryptography/signing/#security","title":"Security","text":"<p>Ed25519 remains by far the most popular instantiation of EdDSA. EdDSA is widely considered to provide better resistance to side-channel attacks than alternative schemes. See here for more studies about the provable security of Ed25519.</p> <p>A viable alternative is \"ECDSA over secp256k1,\" used by both Bitcoin and Ethereum. However, reviews by many independents and well-known security professionals conclude that Ed25519 is more secure compared to secp256k1 .</p> <p>In fact, both core developers of Bitcoin and Vitalik Buterin contemplated transitioning their networks to Ed25519. But this didn't happen because the cost of porting was deemed too high. Interestingly, Ripple made such a migration in 2014.</p>"},{"location":"vite-basics/cryptography/signing/#performance","title":"Performance","text":"<p>Verifications on Vite happen frequently since all transactions are broken into two components (\u201cRequest\u201d and \u201cResponse\u201d). As such, the network's performance is tied to the efficiency of the signature verification process. Shorter signatures also ease the load of the network transmission and the storage system.</p> <p>Ed25519 fits our requirements since the signing process is fast and its signatures are short.</p> <p>EdDSA instantiations such as Ed25519 can sign and verify signatures significantly faster than almost all other signatures schemes at similar security levels. For instance, per recent data, Ed25519 is several times faster than ECDSA over secp256k1. </p> <p>Ed25519 has considerably smaller signatures compared to schemes with similar speeds. In Ed25519, signatures are 64 bytes and public keys are 32 bytes. Here, the signature is slightly shorter than that of ECDSA.</p> <p>See here for more detailed performance benchmarking information.</p>"},{"location":"vite-basics/cryptography/signing/#ed25519-blake2b","title":"Ed25519 - BLAKE2b","text":"<p>Instead of the original SHA-2 of Ed25519, Vite uses BLAKE2b, since the latter is faster and has the same security margin as SHA-3.</p>"},{"location":"vite-basics/ledger/","title":"Index","text":"<p>order: false parent:     title: Ledger Model     order: 2</p>"},{"location":"vite-basics/ledger/account-chains/","title":"Account Chains","text":"<p>In Vite, each account ...</p> <p>TODO: Maybe this chapter can be merged with the ledger chapter</p>"},{"location":"vite-basics/ledger/dag-ledger/","title":"Vite's DAG Ledger","text":"<p>The current state of any blockchain is the aggregate result of all transactions that have taken place in the network. The ledger is a record of all these transactions.</p> <p>In a \"typical\" blockchain project, the ledger looks like a chain of blocks, as is the case with Bitcoin and Ethereum. Each later block references the hash of the previous block, and therefore any change to the data in an older block necessitates a change in the content of all subsequently chained blocks. This means anyone trying to change or remove a transaction in the past will need to modify the entire chain since then, and convince others in the network of the legitimacy of the new chain. The difficulty in doing so ensures the immutability of on-chain data.</p> <p>Vite's DAG ledger was inspired by the block-lattice architecture of Nano. Instead of having only one chain recording all transactions, Vite allows each user (and each smart contract) to have its own chain of blocks. Each block contains only one transaction, and each block refers to the hash of a previous block.</p> <p>The benefit of this design is that independent transactions can be recorded on the ledger simultaneously, thereby increasing the throughput of the network.</p> <p>To further boost performance, each transaction is broken into two parts -- a \"send\" and a \"response.\" After a send transaction is initiated, the receive transaction doesn't need to be initiated until the receiver keyholder is online. This will allow more transactions to be sent per second.</p> <p>Note that this separation applies to both a simple payment (above) and a smart contract function call. In the latter case, a request is an invocation, and a response comes in the form of the execution of the code. A response transaction also needs to refer to the hash of the corresponding request transaction. As in the chart below, the ledger looks like a grid made-up of transactions interlinked with one another.</p> <p></p> <p>If an account owner attempts to doublespend, the offending transaction will not be included by the full nodes and the snapshot block producers (SBPs).</p> <p>One might notice an inherent deficiency in security for this architecture. This is because transactions are organized by addresses, and each transaction is only attached to the account chain associated with the relevant address. Transactions generated by other addresses do not become the descendant of the previous transaction. Therefore, for some account chains, the probability to forge blocks won't become smaller with time. To address this issue, Vite invents Snapshot Chain.</p>"},{"location":"vite-basics/ledger/send-receive-transactions/","title":"Sending and Receiving Transactions","text":"<p>TODO</p>"},{"location":"vite-basics/ledger/snapshot-chain/","title":"Snapshot Chain","text":"<p>The Snapshot Chain was invented to address at least two deficiencies in the block-lattice ledger structure:</p> <ul> <li> <p>In general, the security of a chain increases as it grows longer, because for any given transaction, the probability of a successful rollback drops with more and more blocks chained after said transaction. However, in a block-lattice ledger, each account chain stops growing if there are no new transactions involving the account owner.</p> </li> <li> <p>To prevent spamming attacks, the network needs to ration resources for transactions. To do so, the network must understand the amount of resources currently being consumed per account -- that is, the throughput of each account, measured by TPS (transactions-per-second). The block-lattice ledger lacks a global clock, thereby making it impossible to measure said TPS. Now, one way to throttle transactions is making every transaction compute PoW, but this just means every account will have the same quota for throughput. But even with the PoW, spamming can still happen with precomputed PoWs.</p> </li> </ul>"},{"location":"vite-basics/ledger/snapshot-chain/#what-is-snapshot-chain","title":"What is Snapshot Chain","text":"<p>The Snapshot Chain is a chain of blocks (called \"snapshot blocks\"), each recording the balance of all accounts and the hash of the latest block in all account-chains. In a Delegated Proof-Of-Stake (DPoS) consensus algorithm, one node in a delegated nodes group (\"consensus group\") gets randomly selected to produce such a snapshot block in a given time period. This means when the selected node sees forks in any account-chain, it will deem one of the forks as correct and include it in the snapshot block.</p> <p></p>"},{"location":"vite-basics/ledger/snapshot-chain/#transaction-confirmations","title":"Transaction confirmations","text":"<p>A block in the account chains can be considered as confirmed as soon as it gets included in a snapshot block, or \"snapshotted in the Snapshot Chain.\" Once a transaction is confirmed, it won't be rolled back even if the relevant user makes a longer fork on the account chain. When a transaction gets included in x number of blocks in the Snapshot Chain, then this transaction will be considered to have been confirmed x times by the network. The ability to forge blocks after a certain transaction becomes weaker with time. For most transactions, once the number of confirmations exceeds $(2/3 \\times DelegateNodes + 1)$, the transaction can be considered valid and irreversible.</p>"},{"location":"vite-basics/ledger/snapshot-chain/#a-global-clock","title":"A Global Clock","text":"<p>Since the Snapshot Chain provides a global ordering of all transactions, the height of each snapshot block can be effectively used as a timestamp for each transaction.</p> <p></p> <p>As shown in the above figure, the timestamp of T<sub>n-1</sub> is N-2, and the timestamp of T<sub>n</sub> is N. The time elapsed between T<sub>n</sub> and T<sub>n-1</sub> is N-(N-2)=2. So we have a throughput metric for each account. For a transaction with the height of n in the account-chain, the average TPS of the recent 10 transactions is:</p> <p>$$TPS_n=\\frac{10}{S\\times(H_n-H_{n-9}+1)}$$</p> <p>Here H<sub>n</sub> is the height of the snapshot block referenced by transaction T<sub>n</sub>, and S is the interval of two adjacent snapshot blocks, in seconds.</p> <p>Now we can measure the TPS on account chains. As seen in another section, the Quota mechanism is used to throttle transactions. So, the network will reject any transaction that spends more Quota than available.</p>"},{"location":"vite-basics/network/","title":"Index","text":"<p>order: false parent:     title: Network and Node     order: 8</p>"},{"location":"vite-basics/network/configuration/","title":"Node Configurations","text":"<p>This section introduces how to manually configure a node on your machine. However, if you just want to develop locally, it's recommended you get Visual Studio Code Solidity++ Extension which includes a local development node.</p>"},{"location":"vite-basics/network/configuration/#node","title":"Node","text":"<p>When downloading the latest release of go-vite the following <code>node_config.json</code> is included:</p> <p>Warning</p> <p>When writing your own configuration file, you need to remove comments (text starting with \"//\") to make the configuration file valid.</p> <pre><code>{\n  \"Identity\": \"foobar\", // Node name\n  \"NetID\": 1, // Vite network ID. The field is used to connect different networks. Vite Mainnet -&gt; 1. Testnet -&gt; 2. Local/Debug -&gt; 3.\n  \"ListenInterface\": \"0.0.0.0\",\n  \"Port\": 8483, // UDP/TCP port. Default is 8483. Please ensure the port is not occupied by another process\n  \"FilePort\": 8484, // Port used in combination with ListenInterface and FilePublicAddress\n  \"MaxPeers\": 10, // Maximum peers connected\n  \"MinPeers\": 5, // Search for nodes and try to connect until number of peers is larger than threshold\n  \"MaxInboundRatio\": 2, // Maximum inbound ratio\n  \"MaxPendingPeers\": 5, // Maximum peers waiting to connect\n  \"BootSeeds\": [\n    \"https://bootnodes.vite.net/bootmainnet.json\" // URL for a list of bootstrap nodes\n  ],\n  \"Discover\": true, // Indicates whether other nodes in the networks should be discovered. Default is enabled\n  \"RPCEnabled\": true, // Enable RPC access. Default is enabled\n  \"HttpHost\": \"0.0.0.0\", // Http listening address. Do not change unless you must specify a particular network address\n  \"HttpPort\": 48132, // Http listening port. Default is 48132\n  \"WSEnabled\": false, // Enable WebSocket access. Default is enabled\n  \"WSHost\": \"0.0.0.0\", // WebSocket listening address. Do not change unless you must specify a particular network address\n  \"WSPort\": 41420, // WebSocket listening port. Default is 41420\n  \"HttpVirtualHosts\": [],\n  \"IPCEnabled\": true, // Enable local command line console\n  \"PublicModules\": [\n    \"ledger\",\n    \"net\",\n    \"contract\",\n    \"util\",\n    \"debug\",\n    \"sbpstats\",\n    \"dashboard\"\n  ],\n  \"Miner\": false, // Disable mining. This field must be set to true for SBP node, otherwise it can be turned off\n  \"CoinBase\": \"\", // SBP block producing address in the format of index:address\n  \"EntropyStorePath\": \"\", // The name of keystore file. Must conform to above coinbase address and should be stored in wallet directory\n  \"EntropyStorePassword\": \"\", // Keystore password\n  \"LogLevel\": \"info\", // gvite log level. Default is info\n  \"OpenPlugins\": true, // Open or close chain plugins. eg, filter account blocks by token.\n  \"SubscribeEnabled\": true, // Enable the subscribe API\n  \"TxDexEnable\": true, // Enable the DEX\n  \"VmLogAll\": true, // true will save the vmlog of all contracts. By default, vmlog (ie event) is not saved\n  \"DashboardTargetURL\": \"wss://stats.vite.net\", // Full node statistics URL\n  \"RewardAddr\": \"vite_xxxxxxxxxxxxxxxxxx\" // Full node reward receiving address.\n}\n</code></pre> <p>Other configuration options:</p> <ul> <li><code>Single</code>: Indicates a single node (default: false)</li> <li><code>LedgerGc</code>: Enables the ledger garbage collector (default: true)</li> <li><code>PublicAddress</code>: The network address used by other nodes to connect (optional)</li> <li><code>FilePublicAddress</code>: The network address used by other nodes to connect (optional)</li> <li><code>DataDir</code>: The directory for storing p2p data, if empty, memory will be used as database (optional)</li> <li><code>PeerKey</code>: Key to encrypt messages, the corresponding public key for NodeID, MUST NOT be revealed (optional)</li> <li><code>BootNodes</code>: A list of bootstrap UDP node addresses (optional)</li> <li><code>StaticNodes</code>: A list of bootstrap TCP node addresses (optional)</li> <li><code>GenesisFile</code>: Sets the genesis block file path (optional)</li> <li><code>ForwardStrategy</code>: Picks peers to forward new blocks (default: cross)</li> <li><code>AccessControl</code>: Controls the access during the p2p handshake (default: any)</li> <li><code>AccessAllowKeys</code>: A list of NodeIDs or public keys to be allowed in the p2p handshake (optional)</li> <li><code>AccessDenyKeys</code>: A list of NodeIDs or public keys to be denied in the p2p handshake (optional)</li> <li><code>BlackBlockHashList</code>: A list of block hashes to be blacklisted (optional)</li> <li><code>WhiteBlockList</code>: A list of block hashes to be whitelisted (optional)</li> <li><code>VmLogWhiteList</code>: A list of contract addresses which are allowed to save VM logs (optional)</li> </ul> <p>Danger</p> <ul> <li>Don't use same address for both SBP address and SBP registration address</li> <li>Don't use same mnemonics to generate both SBP address and SBP registration address</li> </ul> <p>Default public modules</p> <p>They are enabled by default whether or not added to the <code>PublicModules</code> list.</p> <ul> <li><code>ledger</code>: Block information, chain height, virtual machine logs, transactions</li> <li><code>net</code>: Network synchronization and node information, peers count</li> <li><code>contract</code>: Smart contract information, call off-chain methods, stake, SBP, vote and token information</li> <li><code>util</code>: Calculate a PoW nonce based on the given difficulty</li> <li><code>health</code>: Chain and node health related information</li> </ul> <p>Optional public modules</p> <p>They can be added as needed to the <code>PublicModules</code> list.</p> <ul> <li><code>wallet</code>: Entropy files, mnemonic and entropy store, derive seeds and addresses, sign data</li> <li><code>pow</code>: Proof-of-work (PoW) nonce, cancel PoW</li> <li><code>register</code>: Registration and reward related data</li> <li><code>vote</code>: Vote and cancel votes</li> <li><code>mintage</code>: Mint, issue and burn tokens</li> <li><code>pledge</code>: Retrieve and cancel quota</li> <li><code>dexfund</code>: ViteX account fund, trade pairs, dividend pools</li> <li><code>dextrade</code>: ViteX trades and orders</li> <li><code>dex</code>: ViteX account balance, token and market information, invitations</li> <li><code>private_dex</code>: ViteX fees, operators, market mining</li> <li><code>tx</code>: Send raw transactions, calculate PoW difficulty and required quota</li> <li><code>dashboard</code>: Operating system, process and runtime information, full node statistics</li> <li><code>subscribe</code>: Polling and callback subscriptions</li> <li><code>sbpstats</code>: Hour, period and day SBP statistics</li> <li><code>data</code>: Quota and ViteX paginated data</li> <li><code>ledgerdebug</code>: Debug ledger related methods</li> <li><code>miner</code>: Manually mine a snapshot for debugging and testing purposes</li> </ul> <p>Deprecated public modules</p> <p><code>private_onroad</code>, <code>public_onroad</code>, <code>debug</code>, <code>consensusGroup</code></p> <p>Tip</p> <p>You might find the node_config.json used by our VSCode Solidity++ Extension helpful.</p>"},{"location":"vite-basics/network/configuration/#genesis","title":"Genesis","text":"<p>The genesis block is the start of the blockchain, and the <code>genesis.json</code> is the file that defines it. It is like the \"settings\" for the Vite blockchain and below you can find an example:</p> <ul> <li>Consensus group settings</li> <li>1 snapshot block is produced per second</li> <li>3 consecutive blocks are produced by the same producer in a round</li> <li>1 snapshot block producer is selected in each round</li> <li>2 initial block producers</li> <li>VITE token settings</li> <li>2 initial staking accounts</li> <li>3 initial accounts (including 2 built-in contracts)</li> </ul> <p>Warning</p> <p>You can make your own config based on the example below but remember to remove the text comments following after \"//\".  The purpose of the comments is to explain certain configuration settings but they are not part of the genesis config itself and should always be removed.</p> <pre><code>{\n  \"GenesisAccountAddress\": \"vite_bb6ad02107a4422d6a324fd2e3707ad53cfed9359378a78792\",\n  \"UpgradeCfg\": {\n    \"Level\": \"latest\"\n  },\n  \"GovernanceInfo\": { // Consensus group settings\n    \"ConsensusGroupInfoMap\": {\n      \"00000000000000000001\": { // Consensus group id: \"00000000000000000001\" stands for snapshot consensus group\n        \"NodeCount\": 1, // Number of SBP(s) selected in each round\n        \"Interval\": 1, // Snapshot block interval\n        \"PerCount\": 3, // Number of blocks each SBP produces consecutively in a round\n        \"RandCount\": 0, // Number of SBP(s) selected randomly\n        \"RandRank\": 100, // Supernode ranking to which the random SBP(s) is selected\n        \"Repeat\": 1, // Number of round in which the consensus result takes effect\n        \"CheckLevel\": 0, // Consensus verification level\n        \"CountingTokenId\": \"tti_5649544520544f4b454e6e40\", // Token which is used to calculate the voting power. Default is VITE\n        \"RegisterConditionId\": 1, // Registration type id\n        \"RegisterConditionParam\": {\n          \"StakeAmount\": 500000000000000000000000, // Amount of staking needed to register SBP\n          \"StakeHeight\": 1, // Staking period in number of snapshots\n          \"StakeToken\": \"tti_5649544520544f4b454e6e40\" // Staking token id\n        },\n        \"VoteConditionId\": 1, // Voting type id\n        \"VoteConditionParam\": {},\n        \"Owner\": \"vite_bb6ad02107a4422d6a324fd2e3707ad53cfed9359378a78792\", // Owner of snapshot consensus group\n        \"StakeAmount\": 0, // Amount of staking for this consensus group\n        \"ExpirationHeight\": 1 // Staking period for this consensus group\n      },\n      \"00000000000000000002\": { // Consensus group id: \"00000000000000000002\" stands for delegated consensus group\n        \"NodeCount\": 1,\n        \"Interval\": 3,\n        \"PerCount\": 1,\n        \"RandCount\": 0,\n        \"RandRank\": 100,\n        \"Repeat\": 48,\n        \"CheckLevel\": 1,\n        \"CountingTokenId\": \"tti_5649544520544f4b454e6e40\",\n        \"RegisterConditionId\": 1,\n        \"RegisterConditionParam\": {\n          \"StakeAmount\": 500000000000000000000000,\n          \"StakeToken\": \"tti_5649544520544f4b454e6e40\"\n        },\n        \"VoteConditionId\": 1,\n        \"VoteConditionParam\": {},\n        \"Owner\": \"vite_bb6ad02107a4422d6a324fd2e3707ad53cfed9359378a78792\",\n        \"StakeAmount\": 0,\n        \"ExpirationHeight\": 1\n      }\n    },\n    \"RegistrationInfoMap\": { // SBP settings\n      \"00000000000000000001\": {\n        \"s1\": { // SBP name\n          \"BlockProducingAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n          \"StakeAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n          \"Amount\": 500000000000000000000000,\n          \"ExpirationHeight\": 7776000, // Staking period\n          \"RewardTime\": 1, // Starting block height from which mining rewards are available for retrieval\n          \"RevokeTime\": 0, // Block height at which the SBP can be cancelled and the corresponding staking can be retrieved. 0 means the SBP can be cancelled immediately\n          \"HistoryAddressList\": [ // Historical block producing addresses\n            \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\"\n          ]\n        }\n      },\n      \"00000000000000000002\": {\n        \"s1\": {\n          \"BlockProducingAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n          \"StakeAddress\": \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\",\n          \"Amount\": 500000000000000000000000,\n          \"ExpirationHeight\": 7776000,\n          \"RewardTime\": 1,\n          \"RevokeTime\": 0,\n          \"HistoryAddressList\": [\n            \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\"\n          ]\n        }\n      }\n    }\n  },\n  \"AssetInfo\": { // Token settings\n    \"TokenInfoMap\": {\n      \"tti_5649544520544f4b454e6e40\": { // Token id\n        \"TokenName\": \"Vite Token\",\n        \"TokenSymbol\": \"VITE\",\n        \"TotalSupply\": 1000000000000000000000000000, // Total supply. The total supply of VITE is 1e9 * 1e18\n        \"Decimals\": 18,\n        \"Owner\": \"vite_bb6ad02107a4422d6a324fd2e3707ad53cfed9359378a78792\",\n        \"MaxSupply\": 115792089237316195423570985008687907853269984665640564039457584007913129639935, // Maximum supply\n        \"IsOwnerBurnOnly\": false, // Boolean flag representing if the token can only be burned by token owner. Re-issuable token only\n        \"IsReIssuable\": true // Boolean flag representing if the token is re-issuable or not\n      }\n    },\n    \"LogList\": [\n      {\n        \"Data\": \"\",\n        \"Topics\": [\n          \"3f9dcc00d5e929040142c3fb2b67a3be1b0e91e98dac18d5bc2b7817a4cfecb6\",\n          \"000000000000000000000000000000000000000000005649544520544f4b454e\"\n        ]\n      }\n    ]\n  },\n  \"QuotaInfo\": { // Quota settings\n    \"StakeBeneficialMap\": { // Quota recipient address and staking amount\n      \"vite_bb6ad02107a4422d6a324fd2e3707ad53cfed9359378a78792\": 10000000000000000000000,\n      \"vite_56fd05b23ff26cd7b0a40957fb77bde60c9fd6ebc35f809c23\": 10000000000000000000000\n    },\n    \"StakeInfoMap\": {\n      \"vite_bb6ad02107a4422d6a324fd2e3707ad53cfed9359378a78792\": [ // Staking address\n        {\n          \"Amount\": 10000000000000000000000, // Staking amount\n          \"ExpirationHeight\": 259200, // Staking period\n          \"Beneficiary\": \"vite_bb6ad02107a4422d6a324fd2e3707ad53cfed9359378a78792\" // Quota recipient address\n        }\n      ],\n      \"vite_56fd05b23ff26cd7b0a40957fb77bde60c9fd6ebc35f809c23\": [\n        {\n          \"Amount\": 10000000000000000000000,\n          \"ExpirationHeight\": 259200,\n          \"Beneficiary\": \"vite_56fd05b23ff26cd7b0a40957fb77bde60c9fd6ebc35f809c23\"\n        }\n      ]\n    }\n  },\n  \"AccountBalanceMap\": { // Account settings\n    \"vite_bb6ad02107a4422d6a324fd2e3707ad53cfed9359378a78792\": { // Account address\n      \"tti_5649544520544f4b454e6e40\": 899980000000000000000000000 // Token id and amount\n    },\n    \"vite_56fd05b23ff26cd7b0a40957fb77bde60c9fd6ebc35f809c23\": {\n      \"tti_5649544520544f4b454e6e40\": 100000000000000000000000000\n    },\n    \"vite_e41be57d38c796984952fad618a9bc91637329b5255cb18906\": {\n      \"tti_5649544520544f4b454e6e40\": 0\n    }\n  }\n}\n</code></pre> <p>Tip</p> <p>You might find the default genesis.json of go-vite or the genesis.json used by our VSCode Solidity++ Extension helpful.</p>"},{"location":"vite-basics/network/debug-faq/","title":"Debug / FAQ","text":""},{"location":"vite-basics/network/debug-faq/#common-errors","title":"Common Errors","text":""},{"location":"vite-basics/network/debug-faq/#boot-up-failures","title":"Boot-up failures","text":"<ul> <li><code>new node error</code></li> </ul> <p>JSON Format error in node_config.json or genesis.json.</p> <ul> <li><code>panic: The fork point abcFork can't be nil. the ForkPoints config in genesis.json is not correct, you can remove the ForkPoints key in genesis.json then use the default config of ForkPoints</code></li> </ul> <p>Unconfigured or incorrect fork point in genesis.json. Check <code>ForkPoints</code> in the config file and make sure it is aligned with the upcoming hard fork. For testnet node, the hard fork height can directly be specified in genesis.json.</p> <ul> <li><code>Failed to prepare node, dataDir already used by another process</code></li> </ul> <p>The <code>DataDir</code> has been occupied by another gvite process. Kill the process and try again. </p> <ul> <li><code>Failed to prepare node, stat {datadir}/maindata/wallet/vite_xxx: no such file or directory</code></li> </ul> <p>The keystore file is missing. Check if <code>DataDir</code> is specified in node_config.json and the correct keystore file is in the folder. You can also specify a <code>KeyStoreDir</code> in node_config.json.</p> <ul> <li><code>Failed to prepare node, error decrypt store</code></li> </ul> <p>Unlock account failed, usually caused by a mismatched key store file and password.</p> <ul> <li><code>Failed to start node, no service for name {abc}</code></li> </ul> <p>Module {abc} in <code>PublicModules</code> does not exist. Remove {abc} from node_config.json.</p>"},{"location":"vite-basics/network/debug-faq/#node-is-not-syncing","title":"Node is not syncing","text":"<p>The node boots up successfully but the snapshot block height does not increase in 5 minutes. </p> <p>Follow the below steps to check. * Make sure the node has been upgraded to the latest stable version; * Make sure the time on the node is accurate; * Check connected peers through <code>net_peers</code>. If peerCount=0, make sure port 8483/8484 are exposed, and run <code>curl https://bootnodes.vite.net/bootmainnet.json</code> to check if the node is connected to the internet; <pre><code>curl -X POST \\\n  http://127.0.0.1:48132/ \\\n  -H 'content-type: application/json' \\\n  -d '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"net_peers\",\n        \"params\": null\n      }'\n</code></pre> * If the node has connected to other peers, check sync status through <code>net_syncDetail</code>. If the chunk returned is empty, wait 5 minutes and check again; <pre><code>curl -X POST \\\n  http://127.0.0.1:48132/ \\\n  -H 'content-type: application/json' \\\n  -d '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"net_syncDetail\",\n        \"params\": null\n      }'\n</code></pre> * Reboot gvite, wait for 5 minutes and watch if the snapshot chain height increases; * Examine the status of snapshot chain through <code>debug_poolSnapshot</code> (add <code>debug</code> in <code>PublicModules</code> of node_config.json to enable the debug tool). If there is a difference gap between Head and Tail, and Tail does not change, send the return values together with the latest log under {datadir}/maindata/runlog/ to Vite technical support for investigation. <pre><code>curl -X POST \\\n  http://127.0.0.1:48132/ \\\n  -H 'content-type: application/json' \\\n  -d '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\":\"debug_poolSnapshot\",\n        \"params\":null\n      }'\n</code></pre></p>"},{"location":"vite-basics/network/debug-faq/#sbp-does-not-produce-blocks","title":"SBP does not produce blocks","text":"<p>The SBP node is synced up but does not produce snapshot blocks. </p> <p>Follow the below steps to check. * Make sure the node has been upgraded to the latest stable version; * Make sure the time on the node is accurate; * Make sure the node has 4 CPUs and 8GB RAM installed with 5 Mbit/s internet connection, and there is no other program occupying the CPU, RAM, disk I/O and network bandwidth; * Check node_config.json, make sure <code>Miner</code> is set to true, <code>EntropyStorePath</code> and <code>EntropyStorePassword</code> are correctly configured; * Check the registration information of the SBP on Vite block explorer to make sure the current block creation address matches the address configured in <code>EntropyStorePath</code>; * Check the SBP rank on Vite block explorer. SBP nodes ranked after 25 have a smaller rate to produce blocks. SBP ranked after 100 do not have chance to produce snapshot block; * Restart the node; * If the problem still exists, send the latest log under ~/.gvite/maindata/runlog/ to Vite technical support for further investigation.</p>"},{"location":"vite-basics/network/debug-faq/#sbp-is-missing-blocks","title":"SBP is missing blocks","text":"<p>The SBP node is in sync but missed some blocks. Follow the steps below to check. * Make sure the node has been upgraded to the latest stable version. * Make sure the time on the node is accurate. * Make sure the node has installed 4 CPUs and 8GB RAM with 5 Mbit/s internet connection, and there is no other program occupying the CPU, RAM, disk I/O and network bandwidth. * Restart the node. * If the problem still exists, send the latest log under {datadir}/maindata/runlog/ to Vite technical support for investigation.</p>"},{"location":"vite-basics/network/debug-faq/#node-reports-too-many-open-files","title":"Node reports too many open files","text":"<p>It is a common error in Linux. Increase the maximum number of open files in the system. Follow the steps below to fix.</p> <p>Run <pre><code>sudo vim /etc/security/limits.conf \n</code></pre> Add  <pre><code>* soft nofile 10240  \n* hard nofile 10240\n</code></pre> or  <pre><code>* - nofile 10240\n</code></pre> or (if you have root access) <pre><code>root soft nofile 10240  \nroot hard nofile 10240\n</code></pre> Save and quit</p> <p>Logout and login again</p> <p>Run <pre><code>ulimit -n\n</code></pre> to check the new value is applied</p> <p>You can also run <pre><code>ps -ef | grep gvite\n</code></pre> Get the pid of gvite <pre><code>cat /proc/{pid}/limits | grep open\n</code></pre> Check the value displayed</p>"},{"location":"vite-basics/network/debug-faq/#faq","title":"FAQ","text":""},{"location":"vite-basics/network/debug-faq/#what-is-the-difference-between-sbp-staking-address-and-block-creation-address","title":"What is the difference between SBP staking address and block creation address?","text":"<p>When an SBP is registered, the registration account should stake 1m VITE. The registration address is the staking address and becomes the owner of the SBP. After the staking lock-up period expires, the staking address can cancel the SBP and retain the 1m VITE staked.</p> <p>Once registered, the staking address cannot be changed. This is different with block creation address and reward withdrawal address, both can be updated after registration.</p> <p>The private key of block creation address is saved on the node (corresponding to <code>EntropyStorePath</code> and <code>EntropyStorePassword</code> in node_config.json), and the only purpose of block creation address is to sign snapshot blocks. </p> <p>Reward withdrawal address is used to withdraw SBP rewards. </p> <p>Tip</p> <p>It is highly recommended to separate staking address from block creation address. Do NOT store assets in block creation address.</p>"},{"location":"vite-basics/network/debug-faq/#do-i-need-to-upgrade-my-node-when-there-is-a-new-release","title":"Do I need to upgrade my node when there is a new release?","text":"<p>There are two types of gvite release. For the releases tagged \"Upgrade is required\", you should complete the upgrade within the time in order to be compatible with the hard fork. No worries, you have enough time to finish the upgrade. Announcements will be declared on Vite social channels including Telegram group, Discord channel, Vite block explorer notifications, and Vite forum usually one month ahead of the hard fork. Another type of release is general release, including improved stability and performance, network optimization, new toolkit interface, etc. Upgrade is not required for this kind of release, but recommended.</p> <p>If there are no special instruction in the announcement, to upgrade a node you should just replace the gvite file and restart it. This is convenient because there is no need to modify node_config.json. If there are instructions in the release announcement, follow the instructions.</p> <p>After reboot, watch if the snapshot chain height is increasing (for full node and SBP node) and snapshot blocks are produced normally (for SBP node). If yes, the upgrade is successful.</p> <p>Tip</p> <p>To avoid unnecessary block missing for SBP node during upgrade, replace gvite file first then reboot the node.</p>"},{"location":"vite-basics/network/debug-faq/#how-to-check-sync-status","title":"How to check sync status?","text":"<p>You have two alternatives. * Check through <code>net_syncinfo</code>\uff0c<code>Sync done</code> indicates the node is synced up.  <pre><code>curl -X POST \\\n  http://127.0.0.1:48132/ \\\n  -H 'content-type: application/json' \\\n  -d '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\":\"net_syncinfo\",\n        \"params\":null\n      }'\n</code></pre> * Check through gvite.log or <code>ledger_getSnapshotChainHeight</code> to check the latest snapshot block height on the node and compare with your favourite explorer. <pre><code>curl -X POST \\\n  http://127.0.0.1:48132/ \\\n  -H 'content-type: application/json' \\\n  -d '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\":\"ledger_getSnapshotChainHeight\",\n        \"params\":null\n      }'\n</code></pre></p>"},{"location":"vite-basics/network/debug-faq/#how-is-the-sbp-reward-allocated","title":"How is the SBP reward allocated?","text":"<p>See SBP reward rules. You can download a detailed voting spreadsheet from the SBP details page e.g. https://vitescan.io/sbps. </p>"},{"location":"vite-basics/network/debug-faq/#can-i-copy-the-ledger-files-to-a-new-node","title":"Can I copy the ledger files to a new node?","text":"<p>Copying ledger files to another node is possible. </p> <ol> <li>Stop the node </li> <li>Copy <code>{datadir}/maindata/ledger</code></li> </ol>"},{"location":"vite-basics/network/explorers/","title":"Block Explorers","text":""},{"location":"vite-basics/network/explorers/#vitescanio","title":"ViteScan.io","text":"<ul> <li>Mainnet: https://vitescan.io/</li> <li>Testnet: https://test.vitescan.io/</li> </ul>"},{"location":"vite-basics/network/explorers/#viteviewxyz","title":"ViteView.xyz","text":"<ul> <li>Mainnet: https://viteview.xyz/</li> <li>Testnet: https://buidl.viteview.xyz/</li> </ul>"},{"location":"vite-basics/network/explorers/#vitetxsde","title":"ViteTxs.de","text":"<ul> <li>Mainnet: https://vitetxs.de/</li> </ul>"},{"location":"vite-basics/network/explorers/#vitcscan","title":"VITCScan","text":"<ul> <li>Mainnet: https://vitcscan.com/</li> <li>Testnet: https://testnet.vitcscan.com/</li> </ul>"},{"location":"vite-basics/network/explorers/#vitexplorereu","title":"Vitexplorer.eu","text":"<ul> <li>Mainnet: https://vitexplorer.eu/</li> </ul>"},{"location":"vite-basics/network/introduction/","title":"Overview","text":"<p>Vite is a decentralized network consisting of many nodes run by independent individuals. But what are nodes exactly and why are they needed? First we need to understand the difference between a client and a node. In the computing world, a \"client\" refers to any type of software that is downloaded onto your computer and helps you interact with another type of software or service provided by a server. For example, Thunderbird is a software client that connects to an email server and allows users to send and receive emails.</p> <p>A Vite client is the software needed to allow Vite nodes to process data on the Vite blockchain. The data stored by each node includes transactions (Transaction/AccountBlock), snapshots (SnapshotBlock), account states (AccountState), and virtual machine states (VmState). A \"node\" is the running piece of the client software. In order to run a node, you have to first download a Vite client application. Vite Labs maintains a client written in Go which can be found here.</p>"},{"location":"vite-basics/network/introduction/#nodes","title":"Nodes","text":"<p>A \"node\" is a computer that performs a certain function on the Vite network and runs client software in order to do so. Depending on what your specific needs are, whether it be a decentralized application (dApp) or a wallet, there are two different types of nodes that can be run by the client: full nodes and snapshot block producers. Both node types have different requirements in terms of hardware but also different purposes in the Vite network. You can find a dedicated chapter for each node type:</p> <ul> <li>Full Node</li> <li>Snapshot Block Producer</li> </ul>"},{"location":"vite-basics/network/introduction/#networks","title":"Networks","text":"<p>Since Vite is a protocol, this means there can be multiple independent \"networks\" conforming to this protocol that do not interact with each other.</p> <p>Networks are different Vite environments you can access for development, testing, or production use cases. Your Vite account will work across the different networks but your account balance and transaction history won't carry over. We distinguish between public and private networks. Public networks are accessible to anyone in the world with an internet connection. Anyone can read or create transactions on a public blockchain and validate the transactions being executed. Agreement on transactions and the state of the network is decided by the consensus mechanism. A network is private if its nodes are not connected to a public network (i.e. mainnet or testnet). In this context, private only means reserved or isolated, rather than protected or secure.</p>"},{"location":"vite-basics/network/introduction/#mainnet","title":"Mainnet","text":"<p>Mainnet is the primary public Vite production blockchain, where actual-value transactions occur on the distributed ledger.</p> <p>When people and exchanges discuss $VITE prices, they're talking about Vite mainnet.</p>"},{"location":"vite-basics/network/introduction/#testnet","title":"Testnet","text":"<p>Testnet is a public network for testing purposes. It is used by protocol developers or smart contract developers to test both protocol upgrades as well as potential smart contracts in a production-like environment before deployment to mainnet. </p> <p>$VITE on testnet has no real value but you still need it to actually interact with the network. To get testnet $VITE you can use the <code>testnet-faucet</code> channel in our Discord or message the bot <code>faucet#9018</code> directly by writing <code>!send vite_...</code>.</p>"},{"location":"vite-basics/network/introduction/#canary","title":"Canary","text":"<p>First piloted by the Polkadot team with the Kusama network, a canary network is a stand-alone public network whose primary function is to serve as a testing network. Unlike a traditional testnet, a canary network has real value and projects can be tested and launched on top of it.</p> <p>Although the canary network is not live yet, in the future it might be used for high-stakes applications that require extensive testing for security e.g. ViteBridge.</p>"},{"location":"vite-basics/network/introduction/#local","title":"Local","text":"<p>To develop a Vite application, you'll want to run it on a private network to see how it works before deploying it. Similar to how you create a local server on your computer for web development, you can create a local blockchain instance to test your dapp. This allows for much faster iteration than on a public testnet.</p> <p>There are projects and tools dedicated to assist with this. Learn more about Visual Studio Code Solidity++ Extension.</p>"},{"location":"vite-basics/network/nodes/","title":"Node Types","text":""},{"location":"vite-basics/network/nodes/#full-node","title":"Full Node","text":"<p>In Vite network, a full node is responsible for maintaining a complete copy of ledger, sending or receiving transactions, and verifying all transactions in the network. Full nodes can also participate in SBP election and voting. A full node can expose HTTP/WebSocket APIs externally and has a command line interface locally.</p>"},{"location":"vite-basics/network/nodes/#registration","title":"Registration","text":"<p>Registering a full node is permission-less. The registration address shall have 10,000 VITE for staking, then send a registration transaction and wait until the transaction is confirmed.</p> <p>The 10k VITE will be locked up for 30 days (2592000 snapshot blocks).</p> <p>After the lock-up period expires, the node owner (registration address) can cancel the registration and retrieve the locked fund through a Cancel Registration transaction. The cancelled full node will be removed from the network list after the transaction is confirmed. </p> <p>For safety purpose, node owners are recommended to use 2 separate Vite addresses for registration and withdrawing rewards respectively.</p> <p></p>"},{"location":"vite-basics/network/nodes/#snapshot-block-producer","title":"Snapshot Block Producer","text":"<p>A Snapshot Block Producer (SBP) is a delegated node in the Vite network. The primary function of SBP is to secure the network by producing snapshot blocks that store a state snapshot of the Vite ledger. This includes the balance of the account, the Merkle root of the contract state, and the hash of the last block of each account chain. To find out how an SBP works, please refer to Consensus.</p> <p>Tip</p> <p>Before continue reading, please see the setup guide on how to install gvite.</p>"},{"location":"vite-basics/network/nodes/#terminology-of-sbp-addresses","title":"Terminology of SBP Addresses","text":"<p>There are three addresses associated with the operation of an SBP.</p> <ul> <li>Block Creation Address: The SBP will be signing blocks from this address.</li> <li>Staking Address: Each SBP is required to stake 1M (1,000,000) VITE to be eligible for producing blocks and earning rewards.</li> <li>Reward Withdraw Address: Block rewards can be retrieved at this address.</li> </ul> <p>Theoretically, all three addresses can be one and the same. But it is STRONGLY RECOMMENDED that the Block Creation Address be different from the Staking Address.</p> <p>Also, the owner of the Block Creation Address and the owner of the Staking Address can be different. This means the operator of the SBP can ask someone else to stake the 1M VITE on their behalf. The staking process (aka registration process) is described in a later section.</p>"},{"location":"vite-basics/network/nodes/#configuration","title":"Configuration","text":"<p>To reate the Block Creation Address, follow instructions here. Take the output from the wallet creation process and append the below 4 properties in node_config.json:</p> <ul> <li>Set <code>Miner</code> as <code>true</code></li> <li>Set <code>CoinBase</code> to the Block Creation Address, in the format of <code>index:address</code>. For example: <code>0:vite_f1c2d944b1e5b8cbfcd5f90f94a0e877beafeced1f331d9acf</code>.</li> <li>Set <code>EntropyStorePath</code> to the Block Creation Address. For example: <code>vite_f1c2d944b1e5b8cbfcd5f90f94a0e877beafeced1f331d9acf</code>.</li> <li>Set <code>EntropyStorePassword</code> as the password you used to generate the Block Creation Address</li> <li>Note: This password is sometimes referred to as the \"keystore password\" corresponding to the Block Creation Address.</li> <li>Note: This password, when combined with <code>EntropyStorePath</code>, can derive the SBP's private key for signing blocks produced</li> </ul>"},{"location":"vite-basics/network/nodes/#registration_1","title":"Registration","text":"<p>Tip</p> <p>Registering a new SBP requires staking 1M (1,000,000) VITE. Please make sure you have at least this amount in your account.</p> <p>Log in Vite Web Wallet and navigate to SBP Registration page.</p> <p>Fill in Node Name and Block Creation Address. </p> <p>Please note that Block Creation Address is the CoinBase address you configured above and is only responsible for producing new blocks. Do NOT use your Staking Address as Block Creation Address.</p> <p></p> <p>After registration of the SBP, you may change the Reward Withdraw Address (as well as the Block Creation Address) via the following screens.</p> <p> </p> <p>SBP Name</p> <p>Please choose your SBP name carefully. Once registered the SBP name cannot be changed anymore. Use an interesting name to gain recognition from the community and draw votes.</p> <p>SBP Ranking List</p> <p>Visit https://vitescan.io/sbps for the ranking list.</p>"},{"location":"vite-basics/network/rpc-ipc/","title":"RPC / IPC","text":"<p>An interface is required to communicate with a node. For this purpose, the client provides a set of RPC/IPC methods that can be invoked.</p> <p>Definitions of Terms</p> RPC <p>Remote Procedure Call: A type of communication that can occur on a single machine or across a network between machines.</p> IPC <p>Inter-Process Communication: A general term for communication between different processes, usually on a single machine.</p>"},{"location":"vite-basics/network/rpc-ipc/#getting-started","title":"Getting Started","text":"<ul> <li>Start a full node as instructed here.</li> <li>Navigate to the installation directory and execute one of the following commands.</li> </ul> <p>Tip</p> <p>The file <code>gvite.ipc</code> will only exist while the node is running and <code>IPCEnabled</code> is set to <code>true</code> in the <code>node_config.json</code> file.</p>"},{"location":"vite-basics/network/rpc-ipc/#wallet-management","title":"Wallet Management","text":"<p>Tip</p> <p>Ensure that the <code>wallet</code> module is added to the <code>PublicModules</code> list in the <code>node_config.json</code> before starting the node. Otherwise, the following command will fail with: <code>The method wallet_createEntropyFile does not exist/is not available</code>.</p> <p>Tip</p> <p>For security reasons, remove the <code>wallet</code> module from <code>PublicModules</code> after completing the setup.</p>"},{"location":"vite-basics/network/rpc-ipc/#creating-a-wallet","title":"Creating a Wallet","text":"<p>Run the following command:</p> <pre><code>./gvite rpc ~/.gvite/maindata/gvite.ipc wallet_createEntropyFile '[\"Your_Password\"]'\n</code></pre> <p>This will produce output similar to the following:</p> <pre><code>{\n   \"jsonrpc\": \"2.0\",\n   \"id\": 1,\n   \"result\": {\n      \"mnemonics\":\"shoot notice glow maze repair outdoor swallow lounge tunnel gym tuition illness fault hill giggle possible enhance ecology interest interest rice inspire awful boil\",\n      \"primaryAddress\":\"vite_525cabb6d3acd6a583747e7b916a18726828e1171551dbc09a\",\n      \"filePath\":\"/home/anon/.gvite/maindata/wallet/vite_525cabb6d3acd6a583747e7b916a18726828e1171551dbc09a\"\n   }\n}\n</code></pre> <ul> <li><code>mnemonics</code>: The mnemonic phrase. Keep it secure.</li> <li><code>primaryAddress</code>: The Vite address at index 0 corresponding to the mnemonic.</li> <li><code>filePath</code>: The location of the keystore file.</li> </ul>"},{"location":"vite-basics/network/rpc-ipc/#recovering-a-wallet-from-a-mnemonic","title":"Recovering a Wallet from a Mnemonic","text":"<p>Run the following command:</p> <pre><code>./gvite rpc ~/.gvite/maindata/gvite.ipc wallet_recoverEntropyFile '[\"Your_Mnemonic\", \"Your_Password\"]'\ne.g.\n./gvite rpc ~/.gvite/maindata/gvite.ipc wallet_recoverEntropyFile '[\"utility client point estate auction region jump hat sick blast tomorrow pottery detect mixture clog able person matrix blast volume decide april congress resource\", \"123456\"]'\n</code></pre> <p>This will produce output similar to the following:</p> <pre><code>{\n   \"jsonrpc\": \"2.0\",\n   \"id\": 1,\n   \"result\": {\n      \"mnemonics\": \"utility client point estate auction region jump hat sick blast tomorrow pottery detect mixture clog able person matrix blast volume decide april congress resource\",\n      \"primaryAddress\": \"vite_981bca7a348de85bd431b842d4b6c17044335f71e5f3da59c0\",\n      \"filePath\": \"/home/anon/.gvite/maindata/wallet/vite_981bca7a348de85bd431b842d4b6c17044335f71e5f3da59c0\"\n   }\n}\n</code></pre> <p>The keystore file \"vite_981bca7a348de85bd431b842d4b6c17044335f71e5f3da59c0\" will now be regenerated under <code>~/.gvite/maindata/wallet/</code>.</p>"},{"location":"vite-basics/network/rpc-ipc/#recover-mnemonic-from-wallet","title":"Recover Mnemonic from Wallet","text":"<p>Run the following command:</p> <pre><code>./gvite rpc ~/.gvite/maindata/gvite.ipc wallet_extractMnemonic '[\"Your_Address\", \"Your_Password\"]'\ne.g.\n./gvite rpc ~/.gvite/maindata/gvite.ipc wallet_extractMnemonic '[\"vite_981bca7a348de85bd431b842d4b6c17044335f71e5f3da59c0\", \"123456\"]'\n</code></pre> <p>This will produce output similar to the following:</p> <pre><code>{\n   \"jsonrpc\": \"2.0\",\n   \"id\": 1,\n   \"result\": \"utility client point estate auction region jump hat sick blast tomorrow pottery detect mixture clog able person matrix blast volume decide april congress resource\"\n}\n</code></pre>"},{"location":"vite-basics/network/rpc-ipc/#monitoring","title":"Monitoring","text":""},{"location":"vite-basics/network/rpc-ipc/#querying-snapshot-block-height","title":"Querying Snapshot Block Height","text":"<p>For Linux/Unix: <pre><code>./gvite rpc ~/.gvite/maindata/gvite.ipc ledger_getSnapshotChainHeight\n</code></pre></p> <p>For Windows: <pre><code>gvite-windows-amd64.exe rpc \\\\.\\pipe\\gvite.ipc ledger_getSnapshotChainHeight\n</code></pre></p> <p>The following result will be displayed: <pre><code>{\n   \"jsonrpc\":\"2.0\",\n   \"id\":1,\n   \"result\":\"1021388\"\n}\n</code></pre> Here, <code>1021388</code> is the current snapshot block height.</p>"},{"location":"vite-basics/network/setup/","title":"Node Setup","text":""},{"location":"vite-basics/network/setup/#recommended-specifications","title":"Recommended Specifications","text":"<ul> <li>SBP (Snapshot Block Producer / Supernode) - 2 CPUs / 8 GB RAM</li> <li>Full Node - 1 CPU / 4 GB RAM</li> </ul> <p>A stable internet connection with a minimum speed of 5 Mbit/s is required.</p>"},{"location":"vite-basics/network/setup/#minimal-installation","title":"Minimal Installation","text":"<p>You can quickly start a full node on the Vite mainnet by following the steps below. While this is a convenient way to verify that everything is functioning correctly, you should customize the default configuration to suit your needs. All configuration options are described here.</p> <ol> <li>Download and extract the latest release of go-vite.</li> <li>Open a terminal and navigate to the installation directory.</li> <li>Run <code>./gvite</code> to start the full node with the default configuration.</li> </ol> <p>The following message should appear: <pre><code>Vite RPC service started successfully!\n</code></pre></p> <p>It may take some time for the node to start syncing the distributed ledger. Eventually, you should see output similar to the following: <pre><code>[Snapshot Stats] Height:10001, Hash:ec543ff3f7397876b6c67a41a170c0e1f97ac637fee4c4db3d1903087f42312e, Timestamp:2019-05-22 01:20:13 +0000 UTC, Producer:vite_dff5ee13c87ed2f205ef87d820b3cd8e97c181b1bb6781c602, Time:2022-05-29 12:16:09.19895974 +0000 UTC m=+51.489945950\n</code></pre></p> <p>To estimate the time required to sync the entire ledger, check the current height using one of the available explorers and compare it to the height shown above.</p>"},{"location":"vite-basics/network/setup/#directory-structure","title":"Directory Structure","text":""},{"location":"vite-basics/network/setup/#installation-directory","title":"Installation Directory","text":"<p>This refers to the folder where the <code>gvite</code> executable and configuration files are located. For example, <code>~/gvite-${version}-${os}</code> is an installation directory.</p> <ul> <li><code>gvite</code>: The Gvite executable file.</li> <li><code>bootstrap</code>: An optional boot script to start the node.</li> <li><code>node_config.json</code>: The configuration file.</li> </ul>"},{"location":"vite-basics/network/setup/#working-directory","title":"Working Directory","text":"<p>The working directory contains subdirectories and files such as \"ledger\", \"ledger_files\", \"LOCK\", \"net\", \"rpclog\", \"runlog\", and \"wallet\".</p> <pre><code>cd ~/.gvite/maindata\n</code></pre> <ul> <li><code>ledger</code>: Directory for storing transactions and snapshot blocks.</li> <li><code>rpclog</code>: Directory for storing RPC logs.</li> <li><code>runlog</code>: Directory for storing runtime logs.</li> <li><code>wallet</code>: Wallet keystore directory for storing keystore files that secure private keys. </li> </ul> <p>Danger</p> <p>Keep your private key safe.</p>"},{"location":"vite-basics/network/setup/#stopping-or-rebooting-the-node","title":"Stopping or Rebooting the Node","text":"<p>If you started the node using the <code>./bootstrap</code> script, follow these instructions to stop or reboot your node.</p> <p>Run the following command to obtain the <code>gvite</code> process ID: <pre><code>ps -ef | grep gvite\n</code></pre></p> <p>Example output: <pre><code>ubuntu   27268     1 99 16:00 ?        01:54:56 ./gvite -pprof \n</code></pre></p> <p>Kill the process using: <pre><code>kill -9 27268\n</code></pre></p> <p>Then reboot the node: <pre><code>./bootstrap\n</code></pre></p> <p>To verify that <code>gvite</code> has restarted successfully, run: <pre><code>ps -ef | grep gvite\n</code></pre></p>"},{"location":"vite-basics/quota/","title":"Index","text":"<p>order: false parent:     title: Quota and Fee     order: 7</p>"},{"location":"vite-basics/quota/fee/","title":"Fees","text":""},{"location":"vite-basics/quota/fee/#contract-creation-fee","title":"Contract Creation Fee","text":"<p>Creating new contract consumes VITE tokens. On the Vite Mainnet, a base fee of 10 VITE is charged for deploying a contract.</p> <p>The contract creation fee will be burned.</p>"},{"location":"vite-basics/quota/fee/#contract-suspension","title":"Contract Suspension","text":"<p>Contract execution consumes quota instead of VITE tokens. Calling a contract, aka the request transaction, will cost quota from the caller's address. However, unlike Ethereum and other smart contract platforms, the contract execution, aka the response transaction, costs quota from the contract address. </p> <p>Tip</p> <p>NEVER forget to supply quota for your smart contract.</p> <p>If the contract runs out of quota, it will stop accepting requests until the quota is restored.</p> <p>If the quota of a contract is insufficient for generating a response transaction, the execution will exhaust the remaining quota and generate a panic exception. If the requested transaction includes a token transfer, the token will be returned to the caller's address. A panic due to insufficient quota will cause the contract to be suspended for 75 snapshots (about 75 seconds).</p>"},{"location":"vite-basics/quota/quota/","title":"Quota","text":""},{"location":"vite-basics/quota/quota/#what-is-quota","title":"What is Quota","text":"<p>Before we dive into the world of Vite, it's important to first take a look at how Ethereum works. Ethereum in its current state is still a proof of work blockchain. In order to have transaction executed quickly, users usually need to offer miners competitive gas fees. The higher the fee, the faster a transaction will be executed. This is a typical bidding model, where system's processing capacity and pending transaction amounts are balanced by the cost of gas price. However, this model does not make it easy for a user to gauge what price is reasonable at a given time. Too low or too high a gas price will cause market failure. Moreover, Ethereum's gas is associated with transactions, there is no measurement to allocate computational resources efficiently at account level.</p> <p>The Vite network does not charge gas fees in the form of its native currency. Instead, all transactions on the Vite chain consume Quota. This includes sending/receiving tokens, deploying smart contract, calling smart contract, issuing token, registering SBP, withdrawing SBP rewards, voting, and staking. A unique Quota generation and consumption model is implemented on the Vite network.</p> <p>To get Quota for an address, one can choose one of the following: </p> <ul> <li>Obtain one-time Quota by calculating a Proof-of-Work (PoW) puzzle upon sending transactions. </li> <li>Lock the native currency VITE.</li> </ul> <p>Note: Obtaining Quota through PoW doesn't apply to smart contract address. </p>"},{"location":"vite-basics/quota/quota/#quota-consumption-rules","title":"Quota Consumption Rules","text":"<p>Transactions on Vite consume different amount of Quota. The following table lists the Quota consumption of common transactions on Vite:</p> <p>Please note that the Minimum Locking Amount for VITE at the end of the column does not ensure the Quota amount one gets upon locking.</p> Transaction Type Raw Quota Consumed In Unit Quota (Quota) Minimum Lock Amount\uff08VITE\uff09 Send Transaction without Comment 21000 1 134 Receive Transaction 21000 1 134 Create Smart Contract 31000 1.4762 267 Register SBP 168000 8 1067 Update Block Creation Address 168000 8 1067 Update SBP Reward Withdrawal Address 168000 8 1067 Cancel SBP Registration 126000 6 534 Withdraw SBP Rewards 147000 7 934 Vote 84000 4 534 Cancel Vote 52500 2.5 400 Stake for Quota 105000 5 667 Cancel Stake 105000 5 667 Stake for Quota with Callback 115500 5.5 800 Cancel Stake with Callback 115500 5.5 800 Issue New Token 189000 9 1200 Re-Issue (Mint) Token 126000 6 800 Burn Token 115500 5.5 800 Transfer Token Ownership 136500 6.5 934 Change Token Type 115500 5.5 800 Get Token Info 31500 1.5 267 ViteX Place Order 25200 1.2 267 ViteX Cancel Order 15200 0.7238 134 ViteX Deposit Fund 10500 0.5 134 ViteX Withdraw Fund 10500 0.5 134 ViteX Internal Transfer 10500 0.5 134 <p>In addition, each byte in the transaction's comment will cost 28 raw Quota.</p> <p>For example, performing a send transaction with a comment of '0x0001' (two bytes) will consume ${\\it Q} = 21000 + 28 * 2 = 21056$ raw Quota, which translates to 1.0027 Quota.</p>"},{"location":"vite-basics/quota/quota/#additional-quota-cost","title":"Additional Quota Cost","text":"<ul> <li>Due to the implementation of VEP-8, a 2-bytes prefix will be added in front of the original comment when sending a transaction from the Vite official wallet. This will cost additional 56 raw Quota.</li> <li>If Response Latency is assigned when creating a smart contract, an additional raw Quota of $40 \\times ResponseLatency$ will be charged for each response transaction of the contract. </li> </ul> <p>Response latency is a positive integer that specifies after how many snapshot blocks the contract will produce the response transaction upon request.</p>"},{"location":"vite-basics/quota/quota/#epoch","title":"Epoch","text":"<p>An epoch on Vite refers to continuous 75 snapshot blocks, approximately 75 seconds. Epoch is used to measure available Quota and transaction processing capacity for an address.</p> <p>Epoch v.s Round</p> <p>A Round is precisely 75 seconds, and it reflects the timeframe how often the SBPs are selected, while an Epoch stands for 75 snapshot blocks, it could be longer than 75 seconds if one or more of the SBPs misses to produce the block.</p>"},{"location":"vite-basics/quota/quota/#quota-calculation","title":"Quota Calculation","text":"<p>Quota is received according to the following formulas:</p> <p>$$Q_{PoW}=Qm \\times (1- \\frac{2}{1+e^{Qc \\times \\xi d \\times \\rho d}})$$ $$Q_{Lock}=Qm \\times (1- \\frac{2}{1+e^{Qc \\times \\xi s \\times \\rho s}})$$</p> <ul> <li>$Q_{PoW}$: One-time Quota obtained through PoW. Works only for the current transaction</li> <li>$Q_{Lock}$: Quota obtained through locking VITE. This Quota is replenished every snapshot block, and, if not used, it's able to accumulate for up to 75 snapshot blocks (an epoch).</li> <li>$Qm$: Quota cap for transaction. The maximum Quota that an address can use for a single transaction. </li> <li>$Qc$: Quota factor, related to the total Quota consumed in the last 74 snapshot blocks</li> <li>$\\xi d$: Difficulty of PoW puzzle that has been resolved</li> <li>$\\rho d$: Calculation weight of PoW</li> <li>$\\xi s$: Locked VITE amount for an address</li> <li>$\\rho s$: Calculation weight of locking VITE</li> </ul> <p>On the Vite network, Quota cap and calculation weights are following constants:</p> <ul> <li>$Qm$ = 1000000</li> <li>$\\rho d$ = 6.259408129e-10</li> <li>$\\rho s$ = 4.201037667e-24</li> </ul> <p>Quota factor is calculated by the following formula:</p> <p>$$ Qc = \\begin{cases}      1, &amp; \\text{for } g \\leq 1050000 \\      2-e^{8.260667775706495e-09 \\times (g - 1050000)}, &amp; \\text{for } 1050000 &lt; g \\leq 2100000 \\      e^{1.6949794096275418e-10 \\times (2100000-g)}-0.9, &amp; \\text{for } g &gt; 2100000 \\ \\end{cases} $$</p> <ul> <li>$g$: Average Quota consumed in the last 74 snapshot blocks</li> </ul> <p>UTPS: Unit transactions per second, referring to the number of basic transactions (consuming 21000 raw Quota or 1 Quota) that an address can send in every snapshot block. </p> <p>$$UTPS=\\frac{Q_{Lock}}{21000}$$</p> <p>UTPE: Unit transactions per epoch, referring to the number of basic transactions (consuming 21000 raw Quota or 1 Quota) that an address can send in every 75 snapshot blocks</p> <p>$$UTPE=UTPS \\times 75$$</p> <p>The Available Quota of an address is determined by UTPS, Quota consumption during the last 74 snapshot blocks, and PoW. For example, Address<sub>A</sub> locked 10000 VITE and obtains 1 UTPS Quota (non-accumulated), and if the address has no transaction in the last 74 snapshot blocks, the Available Quota for Address<sub>A</sub> is 75 Quota. Similarly, Address<sub>B</sub> locked 10000 VITE and obtains 1 UTPS Quota (non-accumulated), and there is no transaction for the address in the last 74 snapshot blocks, meanwhile it also calculated a PoW that is equivalent to 2 Quota. In this case, the available Quota of Address<sub>B</sub> is 77 Quota.</p> <p>Quota Cap for a Single Transaction</p> <p>For a single transaction, the maximum quota it can consume is $\\frac{Qm}{21000}\\approx47.62$ Quota</p> <p>For practical use, we calculated $(\\xi d \\times \\rho d)$ or $(\\xi s \\times \\rho s)$ under different parameters and mapped the values to Quota, UTPS and UTPE, as displayed in the following table:</p> $(\\xi d \\times \\rho d)$ or $(\\xi s \\times \\rho s)$ Raw Quota UTPS UTPE Approximately equivalent to how much VITE locked without calculating PoW Approximately equivalent to how difficult the PoW solved without locking 0.0 0 0 0 0 0 $(0, 0.0005600000146345639]$ 280 1/75 1 134 894654 $(0.0005600000146345639, 0.0011200001170773874]$ 560 2/75 2 267 1789307 $(0.0011200001170773874, 0.0016800003951362111]$ 840 3/75 3 400 2683961 $(0.0016800003951362111, 0.002240000936619286]$ 1120 4/75 4 534 3578615 $(0.002240000936619286, 0.002800001829335484]$ 1400 5/75 5 667 4473270 $(0.002800001829335484, 0.003360003161093523]$ 1680 6/75 6 800 5367925 $(0.003360003161093523, 0.003920005019702078]$ 1960 7/75 7 934 6262581 $(0.003920005019702078, 0.004480007492972107]$ 2240 8/75 8 1067 7157239 $(0.004480007492972107, 0.0050400106687125265]$ 2520 9/75 9 1200 8051897 $(0.0050400106687125265, 0.005600014634735637]$ 2800 10/75 10 1334 8946557 $(0.005600014634735637, 0.006160019478852362]$ 3080 11/75 11 1467 9841218 $(0.006160019478852362, 0.006720025288875452]$ 3360 12/75 12 1600 10735880 $(0.006720025288875452, 0.0072800321526182606]$ 3640 13/75 13 1733 11630544 $(0.0072800321526182606, 0.007840040157895736]$ 3920 14/75 14 1867 12525211 $(0.007840040157895736, 0.008400049392522762]$ 4200 15/75 15 2000 13419879 $(0.008400049392522762, 0.008960059944316465]$ 4480 16/75 16 2133 14314549 $(0.008960059944316465, 0.009520071901094992]$ 4760 17/75 17 2267 15209221 $(0.009520071901094992, 0.01008008535067674]$ 5040 18/75 18 2400 16103896 $(0.01008008535067674, 0.010640100380883094]$ 5320 19/75 19 2533 16998573 $(0.010640100380883094, 0.011200117079536328]$ 5600 20/75 20 2667 17893253 $(0.011200117079536328, 0.011760135534459705]$ 5880 21/75 21 2800 18787936 $(0.011760135534459705, 0.012320155833478902]$ 6160 22/75 22 2933 19682622 $(0.012320155833478902, 0.012880178064420343]$ 6440 23/75 23 3066 20577310 $(0.012880178064420343, 0.013440202315113498]$ 6720 24/75 24 3200 21472002 $(0.013440202315113498, 0.01400022867338966]$ 7000 25/75 25 3333 22366698 $(0.01400022867338966, 0.01456025722708073]$ 7280 26/75 26 3466 23261397 $(0.01456025722708073, 0.015120288064022377]$ 7560 27/75 27 3600 24156099 $(0.015120288064022377, 0.015680321272051077]$ 7840 28/75 28 3733 25050806 $(0.015680321272051077, 0.01624035693900638]$ 8120 29/75 29 3866 25945516 $(0.01624035693900638, 0.016800395152729273]$ 8400 30/75 30 4000 26840230 $(0.016800395152729273, 0.017360436001064444]$ 8680 31/75 31 4133 27734949 $(0.017360436001064444, 0.01792047957185776]$ 8960 32/75 32 4266 28629672 $(0.01792047957185776, 0.018480525952958973]$ 9240 33/75 33 4400 29524399 $(0.018480525952958973, 0.019040575232219203]$ 9520 34/75 34 4533 30419131 $(0.019040575232219203, 0.019600627497492765]$ 9800 35/75 35 4666 31313868 $(0.019600627497492765, 0.020160682836636825]$ 10080 36/75 36 4799 32208609 $(0.020160682836636825, 0.020720741337511922]$ 10360 37/75 37 4933 33103356 $(0.020720741337511922, 0.021280803087980315]$ 10640 38/75 38 5066 33998108 $(0.021280803087980315, 0.021840868175909127]$ 10920 39/75 39 5199 34892865 $(0.021840868175909127, 0.022400936689166498]$ 11200 40/75 40 5333 35787628 $(0.022400936689166498, 0.022961008715626032]$ 11480 41/75 41 5466 36682396 $(0.022961008715626032, 0.02352108434316254]$ 11760 42/75 42 5599 37577171 $(0.02352108434316254, 0.024081163659656016]$ 12040 43/75 43 5733 38471951 $(0.024081163659656016, 0.02464124675298827]$ 12320 44/75 44 5866 39366737 $(0.02464124675298827, 0.025201333711046034]$ 12600 45/75 45 5999 40261529 $(0.025201333711046034, 0.025761424621719303]$ 12880 46/75 46 6133 41156327 $(0.025761424621719303, 0.02632151957290144]$ 13160 47/75 47 6266 42051132 $(0.02632151957290144, 0.026881618652489236]$ 13440 48/75 48 6399 42945944 $(0.026881618652489236, 0.027441721948384734]$ 13720 49/75 49 6533 43840762 $(0.027441721948384734, 0.028001829548493135]$ 14000 50/75 50 6666 44735587 $(0.028001829548493135, 0.02856194154072289]$ 14280 51/75 51 6799 45630419 $(0.02856194154072289, 0.02912205801298835]$ 14560 52/75 52 6933 46525259 $(0.02912205801298835, 0.029682179053206414]$ 14840 53/75 53 7066 47420105 $(0.029682179053206414, 0.030242304749299606]$ 15120 54/75 54 7199 48314960 $(0.030242304749299606, 0.030802435189193574]$ 15400 55/75 55 7333 49209821 $(0.030802435189193574, 0.03136257046081975]$ 15680 56/75 56 7466 50104691 $(0.03136257046081975, 0.03192271065211283]$ 15960 57/75 57 7599 50999568 $(0.03192271065211283, 0.03248285585101344]$ 16240 58/75 58 7733 51894453 $(0.03248285585101344, 0.03304300614546563]$ 16520 59/75 59 7866 52789346 $(0.03304300614546563, 0.033603161623419094]$ 16800 60/75 60 7999 53684248 $(0.033603161623419094, 0.03416332237282837]$ 17080 61/75 61 8133 54579158 $(0.03416332237282837, 0.03472348848165249]$ 17360 62/75 62 8266 55474077 $(0.03472348848165249, 0.03528366003785593]$ 17640 63/75 63 8399 56369004 $(0.03528366003785593, 0.03584383712940819]$ 17920 64/75 64 8533 57263940 $(0.03584383712940819, 0.036404019844283514]$ 18200 65/75 65 8666 58158886 $(0.036404019844283514, 0.036964208270462595]$ 18480 66/75 66 8799 59053840 $(0.036964208270462595, 0.037524402495930566]$ 18760 67/75 67 8933 59948804 $(0.037524402495930566, 0.038084602608677874]$ 19040 68/75 68 9066 60843776 $(0.038084602608677874, 0.03864480869670122]$ 19320 69/75 69 9199 61738759 $(0.03864480869670122, 0.03920502084800278]$ 19600 70/75 70 9333 62633751 $(0.03920502084800278, 0.039765239150590236]$ 19880 71/75 71 9466 63528753 $(0.039765239150590236, 0.04032546369247644]$ 20160 72/75 72 9599 64423765 $(0.04032546369247644, 0.04088569456168163]$ 20440 73/75 73 9733 65318787 $(0.04088569456168163, 0.04144593184623087]$ 20720 74/75 74 9866 66213820 $(0, 0.042006175634155006]$ 21000 1 75 10000 67108863 $(0.042006175634155006, 0.08404944434245186]$ 42000 2 150 20007 134276984 $(0.08404944434245186, 0.1261670961035256]$ 63000 3 225 30033 201563940 $(0.1261670961035256, 0.16839681732546105]$ 84000 4 300 40085 269029937 $(0.16839681732546105, 0.2107768956769977]$ 105000 5 375 50173 336736144 $(0.2107768956769977, 0.25334643304410037]$ 126000 6 450 60306 404745030 $(0.25334643304410037, 0.2961455696376917]$ 147000 7 525 70494 473120723 $(0.2961455696376917, 0.3392157225669637]$ 168000 8 600 80746 541929390 $(0.3392157225669637, 0.382599842575369]$ 189000 9 675 91073 611239649 $(0.382599842575369, 0.4263426931297194]$ 210000 10 750 101486 681123015 $(0.4263426931297194, 0.4704911566788094]$ 231000 11 825 111995 751654385 $(0.4704911566788094, 0.5150945736855665]$ 252000 12 900 122612 822912588 $(0.5150945736855665, 0.5602051210238872]$ 273000 13 975 133350 894980979 $(0.5602051210238872, 0.605878237567604]$ 294000 14 1050 144222 967948128 $(0.605878237567604, 0.6521731063496397]$ 315000 15 1125 155241 1041908585 $(0.6521731063496397, 0.6991532046201573]$ 336000 16 1200 166424 1116963762 $(0.6991532046201573, 0.7468869355972497]$ 357000 17 1275 177787 1193222938 $(0.7468869355972497, 0.7954483588344243]$ 378000 18 1350 189346 1270804432 $(0.7954483588344243, 0.8449180401302736]$ 399000 19 1425 201122 1349836954 $(0.8449180401302736, 0.8953840470548413]$ 420000 20 1500 213135 1430461202 $(0.8953840470548413, 0.9469431228444231]$ 441000 21 1575 225407 1512831730 $(0.9469431228444231, 0.9997020801479394]$ 462000 22 1650 237966 1597119184 $(0.9997020801479394, 1.053779467629503]$ 483000 23 1725 250838 1683512956 $(1.053779467629503, 1.1093075777848576]$ 504000 24 1800 264056 1772224394 $(1.1093075777848576, 1.1664348850068706]$ 525000 25 1875 277654 1863490703 $(1.1664348850068706, 1.2253290311060194]$ 546000 26 1950 291673 1957579704 $(1.2253290311060194, 1.286180514353531]$ 567000 27 2025 306158 2054795738 $(1.286180514353531, 1.3492072924575544]$ 588000 28 2100 321161 2155487012 $(1.3492072924575544, 1.4146605870070175]$ 609000 29 2175 336741 2260054878 $(1.4146605870070175, 1.4828322881625378]$ 630000 30 2250 352969 2368965656 $(1.4828322881625378, 1.554064521717701]$ 651000 31 2325 369924 2482765926 $(1.554064521717701, 1.6287621852605034]$ 672000 32 2400 387705 2602102550 $(1.6287621852605034, 1.707409634545938]$ 693000 33 2475 406426 2727749333 $(1.707409634545938, 1.7905932883378723]$ 714000 34 2550 426227 2860643134 $(1.7905932883378723, 1.8790328663947373]$ 735000 35 2625 447279 3001933774 $(1.8790328663947373, 1.97362554890186]$ 756000 36 2700 469795 3153054584 $(1.97362554890186, 2.0755100566945326]$ 777000 37 2775 494048 3315824778 $(2.0755100566945326, 2.186162517630361]$ 798000 38 2850 520387 3492602612 $(2.186162517630361, 2.3075451472522963]$ 819000 39 2925 549280 3686522911 $(2.3075451472522963, 2.4423470353692043]$ 840000 40 3000 581368 3901881752 $(2.4423470353692043, 2.594395323511559]$ 861000 41 3075 617561 4144793358 $(2.594395323511559, 2.7694056956796604]$ 882000 42 3150 659220 4424389078 $(2.7694056956796604, 2.976475888792767]$ 903000 43 3225 708510 4755203412 $(2.976475888792767, 3.2314282909393213]$ 924000 44 3300 769198 5162514130 $(3.2314282909393213, 3.5656840708200748]$ 945000 45 3375 848763 5696519539 $(3.5656840708200748, 4.057395776090949]$ 966000 46 3450 965808 6482075769 $(4.057395776090949, 5.029431885090279]$ 987000 47 3525 1197189 8034995932 <p>According to the table, regardless of PoW, locking 10000 VITE will receive 1 Quota, equivalent to 1 UTPS or 75 UTPE, while locking 20007 VITE will receive 2 Quota, equivalent to 2 UTPS or 150 UTPE. In addition, locking 134 VITE is able to send a transaction without comment after waiting for 74 snapshot blocks (assuming no transactions during the time), which translates to 1 UTPE.</p>"},{"location":"vite-basics/quota/quota/#dynamic-quota-consumption","title":"Dynamic Quota Consumption","text":"<p>To prevent from network congestion, a scheme called Dynamic Quota Consumption is implemented on the Vite network. When Dynamic Quota kicks in, the total Quota consumed in last 74 snapshot blocks is referenced to measure the congestion in order to adjust Quota consumption accordingly. The higher congestion the network is in, the more VITE locked or more difficult PoW is required to perform transactions.</p> <p>Factor $Qc$ in the Quota calculation formula is specifically for this purpose.</p> <p>The following table shows the minimum required amount of VITE locked to perform a send transaction without comment under different congestion situations. </p> Average Quota Consumption during last 74 snapshot blocks (Quota) Congestion Factor The Minimum Locking Amount (VITE) 0-50 1 134 51 0.987079620361328125 135 52 0.97399139404296875 137 53 0.960735321044921875 139 54 0.947307586669921875 141 55 0.93370819091796875 143 56 0.919933319091796875 145 57 0.905979156494140625 147 58 0.891841888427734375 150 59 0.877529144287109375 152 60 0.8630218505859375 155 61 0.84833526611328125 157 62 0.833454132080078125 160 63 0.81838226318359375 163 64 0.8031158447265625 166 65 0.787654876708984375 170 66 0.771991729736328125 173 67 0.756122589111328125 177 68 0.740055084228515625 181 69 0.72377777099609375 185 70 0.707286834716796875 189 71 0.690586090087890625 194 72 0.67366790771484375 198 73 0.656536102294921875 204 74 0.6391754150390625 209 75 0.621593475341796875 215 76 0.603786468505859375 221 77 0.58574676513671875 228 78 0.567474365234375 236 79 0.548969268798828125 244 80 0.53022003173828125 252 81 0.51123046875 262 82 0.491994857788085938 272 83 0.472513198852539062 283 84 0.452777862548828125 295 85 0.432788848876953125 309 86 0.412540435791015625 324 87 0.392030715942382812 341 88 0.371255874633789062 360 89 0.350214004516601562 382 90 0.328899383544921875 407 91 0.307306289672851562 436 92 0.28543853759765625 469 93 0.263286590576171875 508 94 0.240848541259765625 556 95 0.218120574951171875 614 96 0.195098876953125 686 97 0.171779632568359375 780 98 0.148159980773925781 904 99 0.124234199523925781 1078 100 0.0999999046325683594 1339 101 0.0997366905212402344 1343 102 0.0994729995727539062 1347 103 0.0992097854614257812 1350 104 0.0989465713500976562 1354 105 0.0986838340759277344 1357 106 0.0984206199645996094 1361 107 0.0981578826904296875 1365 108 0.0978946685791015625 1368 109 0.0976319313049316406 1372 110 0.0973691940307617188 1376 111 0.0971064567565917969 1379 112 0.0968441963195800781 1383 113 0.0965814590454101562 1387 114 0.0963191986083984375 1391 115 0.0960564613342285156 1395 116 0.0957942008972167969 1398 117 0.0955319404602050781 1402 118 0.0952696800231933594 1406 119 0.0950074195861816406 1410 120 0.0947461128234863281 1414 121 0.0944838523864746094 1418 122 0.0942220687866210938 1422 123 0.093959808349609375 1426 124 0.0936980247497558594 1430 125 0.0934362411499023438 1434 126 0.0931744575500488281 1438 127 0.0929136276245117188 1442 128 0.0926518440246582031 1446 129 0.0923900604248046875 1450 130 0.0921292304992675781 1454 131 0.0918679237365722656 1458 132 0.09160614013671875 1462 133 0.0913453102111816406 1466 134 0.0910844802856445312 1471 135 0.0908231735229492188 1475 136 0.0905623435974121094 1479 137 0.090301513671875 1483 138 0.0900406837463378906 1488 139 0.0897798538208007812 1492 140 0.089519500732421875 1496 141 0.0892586708068847656 1501 142 0.0889983177185058594 1505 143 0.08873748779296875 1510 144 0.0884771347045898438 1514 145 0.0882167816162109375 1518 146 0.0879564285278320312 1523 147 0.0876965522766113281 1527 148 0.0874361991882324219 1532 149 0.0871763229370117188 1537 150 0.0869164466857910156 1541 151 0.0866560935974121094 1546 152 0.0863962173461914062 1550 153 0.0861368179321289062 1555 154 0.0858774185180664062 1560 155 0.0856170654296875 1565 156 0.085357666015625 1569 157 0.0850982666015625 1574 158 0.0848388671875 1579 159 0.0845794677734375 1584 160 0.0843205451965332031 1589 161 0.0840606689453125 1594 162 0.0838017463684082031 1599 163 0.0835423469543457031 1603 164 0.0832834243774414062 1608 165 0.0830245018005371094 1613 166 0.0827655792236328125 1619 167 0.0825066566467285156 1624 168 0.0822482109069824219 1629 169 0.081989288330078125 1634 170 0.0817308425903320312 1639 171 0.0814719200134277344 1644 172 0.0812134742736816406 1649 173 0.08095550537109375 1655 174 0.0806970596313476562 1660 175 0.0804386138916015625 1665 176 0.0801806449890136719 1671 177 0.0799221992492675781 1676 178 0.0796642303466796875 1682 179 0.0794062614440917969 1687 180 0.0791482925415039062 1693 181 0.0788903236389160156 1698 182 0.078632354736328125 1704 183 0.0783748626708984375 1709 184 0.07811737060546875 1715 185 0.0778594017028808594 1721 186 0.077602386474609375 1726 187 0.0773444175720214844 1732 188 0.07708740234375 1738 189 0.0768299102783203125 1744 190 0.076572418212890625 1749 191 0.0763154029846191406 1755 192 0.0760583877563476562 1761 193 0.0758013725280761719 1767 194 0.0755443572998046875 1773 195 0.0752873420715332031 1779 196 0.0750308036804199219 1785 197 0.0747737884521484375 1792 198 0.0745172500610351562 1798 199 0.0742602348327636719 1804 200 0.0740036964416503906 1810 201 0.0737476348876953125 1817 202 0.0734906196594238281 1823 203 0.07323455810546875 1829 204 0.0729784965515136719 1836 205 0.0727214813232421875 1842 206 0.0724658966064453125 1849 207 0.0722098350524902344 1855 208 0.0719537734985351562 1862 209 0.0716977119445800781 1868 210 0.071441650390625 1875 211 0.071186065673828125 1882 212 0.0709300041198730469 1889 213 0.0706744194030761719 1896 214 0.0704188346862792969 1902 215 0.0701632499694824219 1909 216 0.0699076652526855469 1916 217 0.0696520805358886719 1923 218 0.0693964958190917969 1930 219 0.069141387939453125 1938 220 0.0688862800598144531 1945 221 0.0686311721801757812 1952 222 0.0683760643005371094 1959 223 0.0681209564208984375 1967 224 0.0678658485412597656 1974 225 0.0676112174987792969 1981 226 0.067356109619140625 1989 227 0.0671014785766601562 1996 228 0.0668468475341796875 2004 229 0.0665922164916992188 2012 230 0.06633758544921875 2019 231 0.0660829544067382812 2027 232 0.0658283233642578125 2035 233 0.0655741691589355469 2043 234 0.0653200149536132812 2051 235 0.0650658607482910156 2059 236 0.0648112297058105469 2067 237 0.0645575523376464844 2075 238 0.0643033981323242188 2083 239 0.0640497207641601562 2092 240 0.0637955665588378906 2100 241 0.0635418891906738281 2108 242 0.0632882118225097656 2117 243 0.0630345344543457031 2125 244 0.0627808570861816406 2134 245 0.0625271797180175781 2143 246 0.0622735023498535156 2151 247 0.0620200634002685547 2160 248 0.0617668628692626953 2169 249 0.0615134239196777344 2178 250 0.061260223388671875 2187 251 0.0610070228576660156 2196 252 0.0607540607452392578 2205 253 0.0605010986328125 2214 254 0.0602478981018066406 2224 255 0.0599949359893798828 2233 256 0.0597424507141113281 2242 257 0.0594894886016845703 2252 258 0.0592370033264160156 2262 259 0.0589842796325683594 2271 260 0.0587317943572998047 2281 261 0.0584790706634521484 2291 262 0.0582268238067626953 2301 263 0.0579743385314941406 2311 264 0.0577220916748046875 2321 265 0.0574698448181152344 2331 266 0.0572175979614257812 2341 267 0.0569655895233154297 2352 268 0.0567135810852050781 2362 269 0.0564615726470947266 2373 270 0.0562098026275634766 2383 271 0.0559580326080322266 2394 272 0.055706024169921875 2405 273 0.055454254150390625 2416 274 0.0552027225494384766 2427 275 0.0549514293670654297 2438 276 0.0546998977661132812 2449 277 0.0544483661651611328 2461 278 0.0541968345642089844 2472 279 0.0539455413818359375 2483 280 0.0536942481994628906 2495 281 0.0534429550170898438 2507 282 0.053192138671875 2519 283 0.0529410839080810547 2531 284 0.0526902675628662109 2543 285 0.0524392127990722656 2555 286 0.0521881580352783203 2567 287 0.0519375801086425781 2580 288 0.0516867637634277344 2592 289 0.0514361858367919922 2605 290 0.0511858463287353516 2617 291 0.0509350299835205078 2630 292 0.0506846904754638672 2643 293 0.0504343509674072266 2656 294 0.0501840114593505859 2670 295 0.0499336719512939453 2683 296 0.0496835708618164062 2697 297 0.0494334697723388672 2710 298 0.0491833686828613281 2724 299 0.0489335060119628906 2738 300 0.0486836433410644531 2752 301 0.0484337806701660156 2766 302 0.0481839179992675781 2781 303 0.0479342937469482422 2795 304 0.0476844310760498047 2810 305 0.0474348068237304688 2824 306 0.0471854209899902344 2839 307 0.0469357967376708984 2854 308 0.0466866493225097656 2870 309 0.0464372634887695312 2885 310 0.0461878776550292969 2901 311 0.0459389686584472656 2916 312 0.0456895828247070312 2932 313 0.0454404354095458984 2948 314 0.0451915264129638672 2965 315 0.0449428558349609375 2981 316 0.0446937084197998047 2998 317 0.044445037841796875 3014 318 0.0441961288452148438 3031 319 0.0439476966857910156 3049 320 0.0436990261077880859 3066 321 0.0434503555297851562 3083 322 0.0432019233703613281 3101 323 0.0429534912109375 3119 324 0.0427052974700927734 3137 325 0.0424571037292480469 3156 326 0.0422089099884033203 3174 327 0.0419607162475585938 3193 328 0.0417127609252929688 3212 329 0.0414645671844482422 3231 330 0.0412166118621826172 3251 331 0.0409686565399169922 3270 332 0.0407209396362304688 3290 333 0.0404732227325439453 3310 334 0.0402252674102783203 3331 335 0.03997802734375 3351 336 0.0397303104400634766 3372 337 0.0394828319549560547 3393 338 0.0392353534698486328 3415 339 0.0389881134033203125 3436 340 0.0387406349182128906 3458 341 0.0384936332702636719 3481 342 0.03824615478515625 3503 343 0.0379991531372070312 3526 344 0.0377521514892578125 3549 345 0.0375051498413085938 3572 346 0.0372583866119384766 3596 347 0.0370113849639892578 3620 348 0.0367646217346191406 3644 349 0.036518096923828125 3669 350 0.0362710952758789062 3694 351 0.0360248088836669922 3719 352 0.0357782840728759766 3745 353 0.0355317592620849609 3771 354 0.0352852344512939453 3797 355 0.0350389480590820312 3824 356 0.0347926616668701172 3851 357 0.0345466136932373047 3878 358 0.0343005657196044922 3906 359 0.0340545177459716797 3934 360 0.0338084697723388672 3963 361 0.0335624217987060547 3992 362 0.0333166122436523438 4022 363 0.0330708026885986328 4051 364 0.0328249931335449219 4082 365 0.0325794219970703125 4113 366 0.0323338508605957031 4144 367 0.0320882797241210938 4175 368 0.0318427085876464844 4208 369 0.0315973758697509766 4240 370 0.0313520431518554688 4274 371 0.0311067104339599609 4307 372 0.0308614969253540039 4341 373 0.0306162834167480469 4376 374 0.0303711891174316406 4412 375 0.0301262140274047852 4447 376 0.0298812389373779297 4484 377 0.029636383056640625 4521 378 0.0293915271759033203 4559 379 0.0291467905044555664 4597 380 0.0289020538330078125 4636 381 0.0286573171615600586 4675 382 0.0284128189086914062 4716 383 0.0281683206558227539 4757 384 0.0279238224029541016 4798 385 0.027679443359375 4841 386 0.0274350643157958984 4884 387 0.0271909236907958984 4928 388 0.0269467830657958984 4972 389 0.0267025232315063477 5018 390 0.0264585018157958984 5064 391 0.0262144804000854492 5111 392 0.0259705781936645508 5159 393 0.0257267951965332031 5208 394 0.0254828929901123047 5258 395 0.0252392292022705078 5309 396 0.0249955654144287109 5360 397 0.0247519016265869141 5413 398 0.024508357048034668 5467 399 0.0242649316787719727 5522 400 0.0240213871002197266 5578 401 0.0237782001495361328 5635 402 0.0235348939895629883 5693 403 0.0232915878295898438 5753 404 0.0230485200881958008 5813 405 0.022805333137512207 5875 406 0.0225623846054077148 5939 407 0.0223193168640136719 6003 408 0.0220763683319091797 6069 409 0.0218335390090942383 6137 410 0.0215908288955688477 6206 411 0.021348118782043457 6276 412 0.0211054086685180664 6349 413 0.0208628177642822266 6422 414 0.0206203460693359375 6498 415 0.0203778743743896484 6575 416 0.0201355218887329102 6654 417 0.0198931694030761719 6735 418 0.0196508169174194336 6819 419 0.0194087028503417969 6904 420 0.0191664695739746094 6991 421 0.0189244747161865234 7080 422 0.0186824798583984375 7172 423 0.0184404850006103516 7266 424 0.0181984901428222656 7363 425 0.0179567337036132812 7462 426 0.0177149772644042969 7564 427 0.0174733400344848633 7668 428 0.0172317028045654297 7776 429 0.0169900655746459961 7886 430 0.0167486667633056641 8000 431 0.016507267951965332 8117 432 0.0162657499313354492 8238 433 0.0160245895385742188 8362 434 0.0157833099365234375 8489 435 0.0155420303344726562 8621 436 0.0153009295463562012 8757 437 0.0150599479675292969 8897 438 0.0148189067840576172 9042 439 0.0145779848098754883 9191 440 0.0143371224403381348 9346 441 0.0140962600708007812 9506 442 0.0138555169105529785 9671 443 0.0136148929595947266 9842 444 0.0133742094039916992 10019 445 0.013133704662322998 10202 446 0.0128931999206542969 10393 447 0.0126528143882751465 10590 448 0.0124124288558959961 10795 449 0.0121721029281616211 11008 450 0.0119318962097167969 11230 451 0.0116916894912719727 11461 452 0.0114516019821166992 11701 453 0.0112115740776062012 11951 454 0.0109716057777404785 12213 455 0.0107316970825195312 12486 456 0.0104918479919433594 12771 457 0.0102520585060119629 13070 458 0.0100123286247253418 13383 459 0.00977265834808349609 13711 460 0.00953304767608642578 14056 461 0.00929355621337890625 14418 462 0.00905406475067138672 14800 463 0.00881463289260864258 15201 464 0.00857526063919067383 15626 465 0.00833594799041748047 16074 466 0.00809675455093383789 16549 467 0.0078576207160949707 17053 468 0.00761851668357849121 17588 469 0.00737947225570678711 18158 470 0.0071404874324798584 18766 471 0.00690159201622009277 19415 472 0.00666275620460510254 20111 473 0.0064239501953125 20859 474 0.00618523359298706055 21664 475 0.00594660639762878418 22533 476 0.00570800900459289551 23475 477 0.00546944141387939453 24499 478 0.00523099303245544434 25616 479 0.00499257445335388184 26839 480 0.00475424528121948242 28185 481 0.0045159757137298584 29672 482 0.00427773594856262207 31324 483 0.00403958559036254883 33171 484 0.00380147993564605713 35249 485 0.00356346368789672852 37603 486 0.00332550704479217529 40294 487 0.00308759510517120361 43399 488 0.00284975767135620117 47021 489 0.00261196494102478027 51302 490 0.00237426161766052246 56438 491 0.00213660299777984619 62716 492 0.00189901143312454224 70562 493 0.00166147947311401367 80650 494 0.00142402201890945435 94099 495 0.00118660926818847656 112926 496 0.000949271023273468018 141160 497 0.000711996108293533325 188203 498 0.000474780797958374023 282235 499 0.000237626954913139343 563908 500 5.36001607542857528e-07 249999999"},{"location":"vite-basics/quota/quota/#two-ways-to-obtain-quota","title":"Two Ways to Obtain Quota","text":""},{"location":"vite-basics/quota/quota/#locking-vite","title":"Locking VITE","text":"<p>Quota can be obtained through locking VITE. The beneficiary address will receive the corresponding Quota after the locking transaction is successful.</p> <ul> <li>Locking amount: The minimum locking amount is 134 VITE</li> <li>Address of the Quota beneficiary: The address that receives Quota. This is can be any valid Vite address. In other words, you can lock for yourself or others.</li> </ul> <p>The locked VITE coins will be deducted from user's balance and stay in the built-in contract during the whole locking period. The locking address is able to retrieve the full amount after 259,200 snapshot blocks (about 3 days) by sending a cancel transaction.</p>"},{"location":"vite-basics/quota/quota/#calculating-pow-puzzle","title":"Calculating PoW Puzzle","text":"<p>Users can obtain one-time Quota by calculating a PoW puzzle upon sending transactions.  For example, the difficulty required for performing a send transaction without comment through PoW is <code>0x3FFFFFF</code>.</p> <p>Calculation Steps</p> <ol> <li>Convert $difficulty$ to $target$ according to the following equation:</li> </ol> <p>$$target=\\frac{2^{256}}{1+\\frac{1}{difficulty}}$$</p> <ul> <li>$difficulty$: a 256-bit number, padding 0 in front if the number is less than 256 bits length</li> <li>$target$: a 256-bit number, usually the first bit is 1.</li> </ul> <p>For example, given $difficulty$ = 0x3FFFFFF, we can get $target$ = 0xFFFFFFC000000000.</p> <ol> <li>Calculate $nonce$ based on transaction's data. In this step, a wide range of random numbers are assigned to $nonce$ until the following condition is satisfied:</li> </ol> <p>$$blake2b(blake2b(address+prevHash) + nonce) &gt; target$$</p> <ul> <li>$blake2b$: BLAKE2b hash function</li> <li>$address$: user's Vite address</li> <li>$prevHash$: the hash of previous account block</li> </ul>"},{"location":"vite-express/","title":"Buy Me a Coffee","text":"<p>In this chapter, we will guide you to develop an entry-level dapp step by step using Vite Express - the official Vite dapp template.</p>"},{"location":"vite-express/#project-overview","title":"Project Overview","text":"<p>The dapp is used to give people a way to express gratitude to someone else by \"buying\" them a coffee in the form of sending them VITE.</p> <p>The dapp's main page will look like this:</p> <p></p>"},{"location":"vite-express/#running-the-dapp-from-scratch","title":"Running the Dapp From Scratch","text":"<p>In this section, we will show you how to set up the environment and build the dapp from existing code.</p>"},{"location":"vite-express/#install-nodejs","title":"Install Node.js","text":"<p>Node.js is a cross-platform, JavaScript runtime environment.</p> <pre><code>node -v // check node.js version\n</code></pre> <p>The node.js version used for this project is v14.18.1. We recommend using <code>nvm</code> to install and manage the node.js environment. </p> <p>Install <code>nvm</code> from https://github.com/nvm-sh/nvm.</p> <pre><code>curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\n</code></pre> <p>Now close the current terminal and start a new one</p> <pre><code>command -v nvm  // Check if the installation is successful\nnvm ls-remote // Check available node.js versions \nnvm list // Check installed node.js versions \nnvm install v14.18.1 // Install node.js v14.18.1\n</code></pre>"},{"location":"vite-express/#get-the-source-code","title":"Get the Source Code","text":"<p>Get the source code with Git.</p> <pre><code>git clone https://github.com/vitelabs/vite-express\n</code></pre>"},{"location":"vite-express/#install-dependencies","title":"Install Dependencies","text":"<p>This will install all dependencies according to <code>vite-express/package.json</code>.</p> <pre><code>cd vite-express\nnpm install \n</code></pre>"},{"location":"vite-express/#test-contract-with-vuilder-kit","title":"Test Contract with <code>Vuilder Kit</code>.","text":"<p>Vuilder is a Solidity++ smart contract development kit designed for easy contract compilation, testing, and deployment in JavaScript. Refer to Vuilder Kit for details.</p> <p>Run the test with the following command:</p> <pre><code>npx vuilder test\n</code></pre>"},{"location":"vite-express/#set-up-wallet","title":"Set Up Wallet","text":"<p>Before deploying your contract, create a testnet wallet and supply your address with quota.</p> <p></p> <p>Go to the Vite Discord \ud83d\udeb0\u2502testnet-faucet channel and send the following message to receive 10,000 Vite on testnet.</p> <pre><code>!send &lt;vite_walletAddress&gt;\n</code></pre> <p>Then lock 1000 VITE on testnet for your wallet address to get Quota</p> <p>Note: Quota is required for deploying contracts. Insufficient quota in the address will cause the contract deployment to fail. </p> <p></p>"},{"location":"vite-express/#deploy-the-contract","title":"Deploy the Contract","text":"<p>Now let's deploy the contract to testnet.</p> <p>Modify <code>scripts/deploy.config.json</code> to use your testnet wallet's mnemonic  phrase obtained. </p> <pre><code>{\n  \"http\": \"https://buidl.vite.net/gvite\",\n  \"mnemonic\": \"&lt;your_mnemonic_phrase&gt;\"\n}\n</code></pre> <p>Run the following command to deploy the contract:</p> <pre><code>npx ts-node scripts/deploy.ts\n</code></pre> <p>You will get the contract address after the step is complete. Next, we will lock 1000 VITE for the contract address to obtain Quota.</p> <p>Rule of thumb: always supply your contract with quota. Unlike Ethereum, Vite's smart contract will consume quota to operate. Insufficient quota may cause the contract to hang up (i.e. stop processing transactions).</p> <p></p>"},{"location":"vite-express/#run-the-dapp","title":"Run the Dapp","text":"<p>The frontend is made with TypeScript, React, ViteJS, and Tailwind CSS. Modify <code>frontend/src/contracts/Cafe.ts</code> by updating your contract address.</p> <pre><code>const Cafe = {\n    address: {\n        mainnet: '',\n        testnet: '&lt;vite_contract_address&gt;',\n        localnet: '',\n    },\n  // ...\n}\n</code></pre> <p>Execute the following commands to launch the dapp:</p> <pre><code>cd frontend\nnpm install\nnpm run dev\n</code></pre> <p>A new browser window (http://localhost:3000/) should open and by clicking \"Launch App\", it will take you to this page:</p> <p></p>"},{"location":"vite-express/#vite-wallet-app","title":"Vite Wallet App","text":"<p>To start using the dapp, you will need your Vite Wallet app (iOS / Android) ready. Then switch the node setting of your to testnet. </p>"},{"location":"vite-express/#vite-passport-browser-extension","title":"Vite Passport Browser Extension","text":"<p>Alternatively, you can use the Vite Passport browser extension. Be sure to switch the network to Testnet after creating a wallet for this tutorial.</p>"},{"location":"vite-express/#buy-a-coffee","title":"Buy a Coffee","text":"<p>This section will show you how to use the dapp to \"buy\" a coffee for someone.</p> <p>First, connect to the dapp by clicking \"Connect Wallet\". Then scan the QR code with your Vite Wallet app. </p> <p>Type in the recipient's Vite address and Vite amount in the inputs or optionally add them to the URL like this:</p> <pre><code>http://localhost:3000/app?address=recipient_address&amp;amount=amount\n</code></pre> <p></p> <p>Next, click \"Buy Coffee\" and confirm the transaction on your connected Vite Wallet app; the tokens should have transferred to the recipient's address!</p> <p>You will see this when the transaction hasn't been confirmed yet: </p> <p>When you confirm the transaction, a toast is shown at the top and the inputs are reset: </p>"},{"location":"vite-express/#coffee-history","title":"Coffee History","text":"<p>To view past coffee transactions, click \"History\" in the header to go to http://localhost:3000/history. </p> <p></p> <p>That covers all the major features of the dapp! Of course, the recipient does not receive a real cup of coffee, but this is a good starting point for cafes thinking about accepting orders through their website :)</p> <p>In the next section, we will look at the code to learn how the dapp is built.</p>"},{"location":"vite-express/#develop-the-dapp","title":"Develop the Dapp","text":"<p>In general, there are four steps in building a complete dapp: initializing the project, writing the smart contracts, using Vuilder to test/deploy the contracts, and developing a frontend to interact with the contracts.</p>"},{"location":"vite-express/#initialize-the-project","title":"Initialize the Project","text":"<p>To get started in the right direction for building Vite dapps, clone Vite Express and use it as a starter kit to build off of.</p>"},{"location":"vite-express/#write-contract","title":"Write Contract","text":"<p>It's recommended to write the smart contract with the VSCode Solidity++ Extension. In Vite Express, there is one contract in <code>contracts/Cafe.solpp</code>.</p> <pre><code>// SPDX-License-Identifier: GPL-3.0\n// buy me a coffee\n\npragma soliditypp &gt;=0.8.0;\n\ncontract Cafe {\n\n  uint256 public price = 10**18;\n\n  vitetoken public constant VITE = \"tti_5649544520544f4b454e6e40\";\n\n  event Buy(address from, address to, uint256 num);\n\n   constructor() payable {}\n\n   // Receive Token function\n   receive() external payable {}\n\n   function buyCoffee(address payable to, uint256 numOfCups) payable external {\n      require(msg.token == VITE, \"require vite\");\n      require(msg.value &gt;= price*numOfCups, \"enough to buy coffee\");\n\n      // send VITE to `to`\n      to.transfer(VITE, price * numOfCups);\n\n      emit Buy(msg.sender, to, numOfCups);\n   }\n}\n</code></pre>"},{"location":"vite-express/#compile-contract","title":"Compile Contract","text":"<pre><code>npx vuilder compile Cafe.solpp\n</code></pre> <p>Note: You should execute the command under <code>/vite-express</code> rather than <code>/vite-express/contracts</code>. Otherwise Vuilder will report the following message: Error: ENOENT: no such file or directory, open './contracts/Cafe.solpp'.</p>"},{"location":"vite-express/#test-contract","title":"Test Contract","text":"<p>In <code>test/vite.config.json</code>, your settings should look like the following and not be modified due to the mnemonic phrase for the local network has been set up by default.</p> <pre><code>{\n  \"networks\": {\n    \"local\": {\n      \"http\": \"http://127.0.0.1:23456/\",\n      \"ws\": \"http://127.0.0.1:23457/\",\n      \"mnemonic\": \"record deliver increase organ subject whisper private tourist final athlete unit jacket arrow trick sweet chuckle direct print master post senior pluck whale taxi\"\n    }\n  }\n}\n</code></pre>"},{"location":"vite-express/#write-unit-tests","title":"Write Unit Tests","text":"<p>The <code>test</code> folder contains all the unit tests. Vite Express currently only has one at <code>test/Cafe.spec.ts</code></p> <pre><code>import { describe } from \"mocha\";\nimport { expect } from \"chai\";\nimport * as vuilder from \"@vite/vuilder\";\nimport config from \"./vite.config.json\";\n\nlet provider: any;\nlet deployer: vuilder.UserAccount;\n\ndescribe(\"test Cafe\", () =&gt; {\n  before(async function() {\n    provider = vuilder.newProvider(config.networks.local.http);\n    console.log(await provider.request(\"ledger_getSnapshotChainHeight\"));\n    deployer = vuilder.newAccount(config.networks.local.mnemonic, 0, provider);\n    console.log('deployer', deployer.address);\n  });\n\n  it(\"test buy coffee\", async () =&gt; {\n    // compile\n    const compiledContracts = await vuilder.compile(\"Cafe.solpp\");\n    expect(compiledContracts).to.have.property(\"Cafe\");\n\n    // deploy\n    let cafe = compiledContracts.Cafe;\n    cafe.setDeployer(deployer).setProvider(provider);\n    await cafe.deploy({});\n    expect(cafe.address).to.be.a(\"string\");\n    console.log(cafe.address);\n\n    // check default balance\n    expect(await cafe.balance()).to.be.equal('0');\n    // check default value of data\n    let result = await cafe.query(\"price\", []);\n    console.log(\"return\", result);\n    expect(result)\n      .to.be.an(\"array\")\n      .with.lengthOf(1);\n    expect(result![0]).to.be.equal(\"1000000000000000000\");\n\n    // call Cafe.buyCoffee(to, numOfCups);\n    const block = await cafe.call(\n      \"buyCoffee\",\n      [\"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\", 2],\n      { amount: \"2000000000000000000\" }\n    );\n\n    const events = await cafe.getPastEvents('Buy', {fromHeight: block.height, toHeight: block.height});\n    expect(events)\n      .to.be.an(\"array\")\n      .with.lengthOf(1);\n    expect(events[0]?.returnValues?.from).to.be.equal(deployer.address);\n    expect(events[0]?.returnValues?.to).to.be.equal(\n      \"vite_3345524abf6bbe1809449224b5972c41790b6cf2e22fcb5caf\"\n    );\n    expect(events[0]?.returnValues?.num).to.be.equal(\"2\");\n\n    expect(await cafe.balance()).to.be.equal('0');\n  });\n});\n</code></pre>"},{"location":"vite-express/#run-unit-tests","title":"Run Unit Tests","text":"<p>Run your tests on the local debug network like this:</p> <pre><code>npx vuilder test\n</code></pre> <p>Note: You can specify another network in <code>test/vite.config.json</code>. However we strongly recommend you use the local network for testing purposes.</p>"},{"location":"vite-express/#deploy-contract","title":"Deploy Contract","text":""},{"location":"vite-express/#specify-the-network-and-wallet-for-deployment","title":"Specify the Network and Wallet for Deployment","text":"<p>In <code>scripts/deploy.config.json</code>, modify it to use your testnet wallet's mnemonic phrase. </p> <pre><code>{\n  \"http\": \"https://buidl.vite.net/gvite\",\n  \"mnemonic\": \"your mnemonic phrase\"\n}\n</code></pre> <p>Note: You can deploy the contract to the testnet or mainnet. For testnet the http endpoint is <code>https://buidl.vite.net/gvite</code>. For mainnet, it is <code>https://node.vite.net/gvite</code>.</p>"},{"location":"vite-express/#deploy-script","title":"Deploy Script","text":"<p>The script to deploy your contract is in <code>scripts/deploy.ts</code>.</p> <pre><code>import { expect } from \"chai\";\nimport * as vuilder from \"@vite/vuilder\";\nimport config from \"./deploy.config.json\";\n\nasync function run(): Promise&lt;void&gt; {\n  const provider = vuilder.newProvider(config.http);\n  console.log(await provider.request(\"ledger_getSnapshotChainHeight\"));\n  const deployer = vuilder.newAccount(config.mnemonic, 0, provider);\n\n  // compile\n  const compiledContracts = await vuilder.compile(\"Cafe.solpp\");\n  expect(compiledContracts).to.have.property(\"Cafe\");\n\n  // deploy\n  let cafe = compiledContracts.Cafe;\n  cafe.setDeployer(deployer).setProvider(provider);\n  await cafe.deploy({});\n  expect(cafe.address).to.be.a(\"string\");\n  console.log(cafe.address);\n\n  // stake quota\n  await deployer.stakeForQuota({beneficiaryAddress: cafe.address, amount:\"2001000000000000000000\"});\n\n  return;\n}\n\nrun().then(() =&gt; {\n  console.log(\"done\");\n});\n</code></pre>"},{"location":"vite-express/#run-deploy-script","title":"Run Deploy Script","text":"<pre><code>npx ts-node scripts/deploy.ts\n</code></pre> <p>Note: Once the contract is deployed on the blockchain, don't forget to supply quota for the contract address.</p>"},{"location":"vite-express/#frontend-architecture","title":"Frontend Architecture","text":"<p>The default frontend for Vite Express has many React components and helper files, This section will explain the files you will need to familiarize yourself with the most to start building on top of Vite Express.</p> <p>The file structure of the frontend is as follows:</p> <p></p> <p>The frontend app is rendered with <code>frontend/index.html</code> and <code>frontend/src/main.tsx</code> <code>frontend/index.html</code>: <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\" /&gt;\n        &lt;link rel=\"icon\" href=\"/favicon.png\" /&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n        &lt;title&gt;Vite Express&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"root\"&gt;&lt;/div&gt;\n        &lt;div id=\"modal\"&gt;&lt;/div&gt;\n        &lt;div id=\"toast\"&gt;&lt;/div&gt;\n        &lt;script type=\"module\" src=\"/src/main.tsx\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <p><code>frontend/src/main.tsx</code>: <pre><code>import ReactDOM from 'react-dom/client';\nimport App from './components/App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);\nroot.render(&lt;App /&gt;);\n</code></pre></p>"},{"location":"vite-express/#app-component","title":"App Component","text":"<p>The <code>App</code> component is the root of the app and wraps the entire app with the <code>Provider</code> component, a global context which acts as the global state that any child component can connect to. Before rendering anything, it first uses your browser's <code>localStorage</code> to determine the initial app state; this includes: - <code>vcInstance</code> - An instance of the <code>VC</code> class defined in <code>frontend/src/utils/viteConnect.ts</code> which helps you manage the Vite Wallet app connected via ViteConnect - <code>vpAddress</code> - The address of the Vite Passport wallet if it is connected - <code>activeNetworkIndex</code> - The index of the active network in <code>networkList</code> in <code>frontend/src/utils/constants.ts</code> - <code>languageType</code> - Initially only English, but you can add your own translations in the <code>frontend/src/i18n</code> folder - <code>activeAddress</code> - The address from the connected Vite Passport or App wallet (Both shouldn't be able to connect at the same time)</p> <p><code>frontend/src/App.tsx</code>: <pre><code>const App = () =&gt; {\n    const [initialState, initialStateSet] = useState&lt;object&gt;();\n    useEffect(() =&gt; {\n        (async () =&gt; {\n            const vcSession = getValidVCSession();\n            const vcInstance = vcSession ? initViteConnect(vcSession) : undefined;\n            let vpAddress: undefined | string;\n            let activeNetworkIndex: undefined | number;\n\n            if (window?.vitePassport) {\n                vpAddress = await window.vitePassport.getConnectedAddress();\n                if (vpAddress) {\n                    const activeNetwork = await window.vitePassport.getNetwork();\n                    activeNetworkIndex = networkList.findIndex((n) =&gt; n.rpcUrl === activeNetwork.rpcUrl);\n                }\n            }\n            if (activeNetworkIndex === undefined || activeNetworkIndex === -1) {\n                activeNetworkIndex = localStorage.activeNetworkIndex || 0;\n            }\n\n            const state: Partial&lt;State&gt; = {\n                vcInstance,\n                vpAddress,\n                activeNetworkIndex,\n                languageType: localStorage.languageType || 'en',\n                activeAddress: vpAddress || vcInstance?.accounts?.[0],\n            };\n            initialStateSet(state);\n        })();\n    }, []);\n\n    return initialState ? (\n        &lt;Provider initialState={initialState}&gt;\n            &lt;Router /&gt;\n        &lt;/Provider&gt;\n    ) : null;\n};\n</code></pre></p>"},{"location":"vite-express/#router-component","title":"Router Component","text":"<p>The <code>Router</code> component uses React Router v6 to enable client-side routing. Every component used for a <code>Route</code>'s <code>element</code> prop is put in the <code>pages</code> folder and all the <code>Route</code>s are wrapped with the <code>PageContainer</code> component.</p> <p><code>frontend/src/Router.ts</code>: <pre><code>return (\n  &lt;BrowserRouter&gt;\n    &lt;PageContainer&gt;\n      &lt;Routes&gt;\n        &lt;Route path=\"/\" element={&lt;Landing /&gt;} /&gt;\n        &lt;Route path=\"/app\" element={&lt;AppHome /&gt;} /&gt;\n        &lt;Route path=\"/history\" element={&lt;History /&gt;} /&gt;\n        &lt;Route path=\"*\" element={&lt;Navigate to=\"/\" /&gt;} /&gt;\n      &lt;/Routes&gt;\n    &lt;/PageContainer&gt;\n    &lt;Toast /&gt;\n  &lt;/BrowserRouter&gt;\n);\n</code></pre></p>"},{"location":"vite-express/#pagecontainer-component","title":"PageContainer Component","text":"<p>The <code>PageContainer</code> component adds the header and footer to its <code>children</code> prop. It's also in the <code>containers</code> folder which means it's connected to the global state. To connect a component to the global state, simply wrap the component with the <code>connect</code> higher-order component.</p> <p><code>frontend/src/containers/PageContainer.tsx</code>: <pre><code>type Props = State &amp; { // `State` is the type of the global state, so only containers (i.e. connected components) should use it in their prop types.\n    noPadding?: boolean;\n    children: ReactNode;\n};\n\nconst PageContainer = ({\n    noPadding,\n    activeNetworkIndex,\n    languageType,\n    i18n,\n    setState,\n    children,\n    vpAddress,\n    activeAddress,\n}: Props) =&gt; {\n    const [theme, themeSet] = useState(localStorage.theme);\n\n    useEffect(() =&gt; {\n        import(`../i18n/${languageType}.ts`).then((translation) =&gt; {\n            setState({ i18n: translation.default });\n        });\n    }, [setState, languageType]);\n\n    const languages = [\n        ['English', 'en'],\n    ];\n\n    const themes: [typeof SunIcon, string][] = [\n        [SunIcon, i18n?.light],\n        [MoonIcon, i18n?.dark],\n        [DesktopComputerIcon, i18n?.system],\n    ];\n\n    useEffect(() =&gt; {\n        let unsubscribe = () =&gt; {};\n        if (window?.vitePassport &amp;&amp; vpAddress &amp;&amp; vpAddress === activeAddress) {\n            unsubscribe = window.vitePassport.on('networkChange', (payload) =&gt; {\n                let activeNetworkIndex = networkList.findIndex(\n                    (n) =&gt; n.rpcUrl === payload.activeNetwork.rpcUrl\n                );\n                if (activeNetworkIndex === -1) {\n                    setState({ toast: i18n.vitePassportNetworkDoesNotMatchDappNetworkUrl });\n                    activeNetworkIndex = 0;\n                }\n                setState({ activeNetworkIndex });\n            });\n        }\n        return unsubscribe;\n    }, [setState, vpAddress, activeAddress, i18n]);\n\n    useEffect(() =&gt; {\n        let unsubscribe = () =&gt; {};\n        if (window?.vitePassport) {\n            unsubscribe = window.vitePassport.on('accountChange', (payload) =&gt; {\n                setState({ vpAddress: payload.activeAddress });\n            });\n        }\n        return unsubscribe;\n    }, [setState]);\n\n    return !i18n ? null : (\n        &lt;div className=\"h-0 min-h-screen relative flex flex-col\"&gt;\n            &lt;header className=\"fx px-2 h-12 justify-between top-[1px] w-full fixed z-50\"&gt;\n                {/* header links/buttons */}\n            &lt;/header&gt;\n            &lt;main className={`flex-1 ${noPadding ? '' : 'px-4 pt-14'}`}&gt;{children}&lt;/main&gt;\n            &lt;div className=\"fx justify-end gap-2 mx-4 my-3 text-skin-muted text-sm\"&gt;\n                {/* footer links */}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n};\n\nexport default connect(PageContainer);\n</code></pre></p>"},{"location":"vite-express/#global-state","title":"Global State","text":"<p>As mentioned previously, the <code>Provider</code> component is a React context that acts as the frontend's global state and <code>connect</code> is the higher-order component used to connect to the global state.</p> <p>Additional details about the <code>Provider</code> component include: - The initial app state can be optionally be set via the <code>initialState</code> prop - The <code>onSetState</code> prop is called every time the state changes (i.e. <code>setState</code> is called) with the new state and optional <code>options</code> arguments passed to <code>setState</code>. - The initial global state is set in App.tsx Additional details about the <code>connect</code> higher-order component include: - All <code>connect</code>ed components are passed the global state fields and a <code>setState</code> function as props. - The <code>setState</code> method is used for mutating the global state.   - The first parameter is an object and its properties will be shallow merged with the current global state.     - e.g. <code>setState({ networkType: network })</code> will update the all containers that use the <code>networkType</code> prop.   - To deep merge, pass an optional second meta object argument to <code>setState</code> with <code>{ deepMerge: true }</code>.       <pre><code>setState({ a: { b: 'c' } }, { deepMerge: true })\n// { a: { d: 3 } } =&gt; { a: { d: 3, b: 'c' } }\n</code></pre> - Components that use <code>connect</code> are known as connected components or containers and go in the <code>frontend/src/containers</code> folder.</p> <p><code>frontend/src/utils/globalContext.tsx</code>: <pre><code>import React, { useCallback, useState } from 'react';\nimport { State } from './types';\n\n// https://stackoverflow.com/a/51365037/13442719\ntype RecursivePartial&lt;T&gt; = {\n    [P in keyof T]?: T[P] extends (infer U)[]\n        ? RecursivePartial&lt;U&gt;[]\n        : T[P] extends object\n        ? RecursivePartial&lt;T[P]&gt;\n        : T[P];\n};\n\nexport type setStateType = (state: RecursivePartial&lt;State&gt;, meta?: { deepMerge?: boolean }) =&gt; void;\n\ntype HOCProps = {\n    state: Partial&lt;State&gt;;\n    setState: setStateType;\n};\n\n// https://stackoverflow.com/a/58405003/13442719\nconst GlobalContext = React.createContext&lt;HOCProps&gt;(undefined!);\n\ntype ProviderProps = {\n    children: React.ReactNode;\n    initialState?: Partial&lt;State&gt;;\n};\n\nexport const Provider = ({ children, initialState = {} }: ProviderProps) =&gt; {\n    const [state, setState] = useState(initialState);\n    const setStateFunc = useCallback(\n        (stateChanges: object, options: { deepMerge?: boolean } = {}) =&gt; {\n            setState((prevState) =&gt; {\n                const newState = options.deepMerge\n                    ? deepMerge({ ...prevState }, stateChanges)\n                    : { ...prevState, ...stateChanges };\n                return newState;\n            });\n        },\n        []\n    );\n\n    return (\n        &lt;GlobalContext.Provider\n            value={{\n                state,\n                setState: setStateFunc,\n            }}\n        &gt;\n            {children}\n        &lt;/GlobalContext.Provider&gt;\n    );\n};\n\nexport const deepMerge = (target: { [key: string]: any }, source: { [key: string]: any }) =&gt; {\n    if (target &amp;&amp; source) {\n        for (const key in source) {\n            if (\n                source[key] instanceof Object &amp;&amp;\n                !Array.isArray(source[key]) // NB: DOES NOT DEEP MERGE ARRAYS\n            ) {\n                Object.assign(source[key], deepMerge(target[key] || {}, source[key]));\n            }\n        }\n        Object.assign(target, source);\n        return target;\n    }\n    return target || source;\n};\n\n// https://stackoverflow.com/a/56989122/13442719\nexport const connect = &lt;T,&gt;(Component: React.ComponentType&lt;T&gt;) =&gt; {\n    // eslint-disable-next-line react/display-name\n    return (props: Omit&lt;T, keyof State&gt;) =&gt; (\n        &lt;GlobalContext.Consumer&gt;\n            {(value: HOCProps) =&gt; (\n                // @ts-ignore\n                &lt;Component {...props} {...value.state} setState={value.setState} /&gt;\n            )}\n        &lt;/GlobalContext.Consumer&gt;\n    );\n};\n</code></pre></p>"},{"location":"vite-express/#lightdarksystem-theme","title":"Light/Dark/System theme","text":"<p>Vite Express has 3 theme settings: light, dark, and system (changes according to the theme of your computer's light/dark theme). This is achieved with Tailwind CSS' native dark mode support. In <code>theme.ts</code> the initial theme is set based on <code>localStorage.theme</code> and in <code>PageContainer.tsx</code>, dark mode is toggled manually.</p> <p><code>frontend/src/styles/theme.ts</code>: <pre><code>if (!localStorage.theme) {\n    localStorage.theme = 'system';\n}\n\nif (\n    localStorage.theme === 'dark' ||\n    (localStorage.theme === 'system' &amp;&amp; prefersDarkTheme)\n) {\n    document.documentElement.classList.add('dark');\n} else {\n    document.documentElement.classList.remove('dark');\n}\n\n// does not exist on older browsers\nif (window?.matchMedia('(prefers-color-scheme: dark)')?.addEventListener) {\n    window\n        ?.matchMedia('(prefers-color-scheme: dark)')\n        ?.addEventListener('change', (e) =&gt; {\n            if (localStorage.theme === 'system') {\n                if (e.matches) {\n                    document.documentElement.classList.add('dark');\n                } else {\n                    document.documentElement.classList.remove('dark');\n                }\n            }\n        });\n}\n</code></pre></p> <p><code>frontend/src/containers/PageContainer.tsx</code>: <pre><code>&lt;DropdownButton\n  buttonJsx={\n    &lt;div className=\"w-8 h-8 xy\"&gt;\n      &lt;div\n        className={`w-7 h-7 ${\n          theme === 'system'\n            ? 'text-skin-muted'\n            : 'text-skin-highlight'\n        }`}\n      &gt;\n        &lt;SunIcon className=\"block dark:hidden\" /&gt;\n        &lt;MoonIcon className=\"hidden dark:block\" /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  }\n  dropdownJsx={\n    &lt;&gt;\n      {themes.map(([Icon, label]) =&gt; {\n        const active = localStorage.theme === label;\n        return (\n          &lt;button\n            key={label}\n            className=\"fx px-2 py-0.5 h-7 gap-2 w-full bg-skin-foreground brightness-button\"\n            onMouseDown={(e) =&gt; e.preventDefault()}\n            onClick={() =&gt; {\n              localStorage.theme = label;\n              themeSet(label);\n              if (label === 'light' || !prefersDarkTheme()) {\n                document.documentElement.classList.remove('dark');\n              } else if (label === 'dark' || prefersDarkTheme()) {\n                document.documentElement.classList.add('dark');\n              }\n            }}\n          &gt;\n            &lt;Icon\n              className={`h-full ${\n                active ? 'text-skin-highlight' : 'text-skin-secondary'\n              }`}\n            /&gt;\n            &lt;p\n              className={`font-semibold ${\n                active ? 'text-skin-highlight' : ''\n              }`}\n            &gt;\n              {label[0].toUpperCase() + label.substring(1)}\n            &lt;/p&gt;\n          &lt;/button&gt;\n        );\n      })}\n    &lt;/&gt;\n  }\n/&gt;\n</code></pre></p>"},{"location":"vite-express/#internalization-i18n","title":"Internalization (i18n)","text":"<p>Throughout Vite Express, you will see <code>i18n</code> being passed as props to connected components. <code>i18n</code> is an object that contains all of the text for a particular transaction. By default, there is only English, but more languages can be added to the <code>frontend/src/i18n</code> folder. If you do this, make sure to add it as an option to the <code>languages</code> array where the first element in the nested array is the label, and the second is the filename without the <code>.ts</code> extension. From there, when the <code>DropdownButton</code> in <code>PageContainer.tsx</code> is used to select a new language, the global state's <code>languageType</code> will change, which triggers a <code>useEffect</code> to replace the current <code>i18n</code> translation with the new one.</p> <p><code>frontend/src/containers/PageContainer.tsx</code>: <pre><code>const languages = [\n  ['English', 'en'],\n  // ['English', 'en'],\n];\n// ...\nuseEffect(() =&gt; {\n  if (!i18n) {\n    import(`../i18n/${languageType}.ts`).then((translation) =&gt; {\n      setState({ i18n: translation.default });\n    });\n  }\n}, [setState, i18n, languageType]);\n// ...\n&lt;DropdownButton\n  buttonJsx={\n    &lt;div className=\"w-8 h-8 xy\"&gt;\n      &lt;TranslateIcon className=\"text-skin-muted w-7 h-7\" /&gt;\n    &lt;/div&gt;\n  }\n  dropdownJsx={\n    &lt;&gt;\n      {languages.map(([language, shorthand]) =&gt; {\n        const active =\n          localStorage.languageType === shorthand ||\n          (!localStorage.languageType &amp;&amp; shorthand === 'en');\n        return (\n          &lt;button\n            key={language}\n            className={`fx px-2 w-full h-7 bg-skin-foreground brightness-button ${\n              active ? 'text-skin-highlight' : ''\n            }`}\n            onMouseDown={(e) =&gt; e.preventDefault()}\n            onClick={() =&gt; {\n              localStorage.languageType = shorthand;\n              setState({ languageType: shorthand });\n            }}\n          &gt;\n            {language}\n          &lt;/button&gt;\n        );\n      })}\n    &lt;/&gt;\n  }\n/&gt;\n</code></pre></p>"},{"location":"vite-express/#a-component","title":"A Component","text":"<p>The <code>A</code> component is used for both internal and external links. If you pass it a <code>to</code> prop, clicking the link will navigate to the route specified in <code>Router.tsx</code>. If you pass it an <code>href</code> prop, clicking it will open the URL in a new tab.</p>"},{"location":"vite-express/#modal-component","title":"Modal Component","text":"<p>The <code>Modal</code> component is used for presenting components on top of the main app (e.g. when showing the QR code for ViteConnect or prompting the user to sign a transaction). To use it, you need to create a state variable (locally with <code>useState</code> or globally with <code>connect</code>, it doesn't matter) that determines if the modal is visible or not. Once you have the \"switch\" variable, use it to open and close the modal like in the <code>AppHome</code> component.</p> <p><code>frontend/src/pages/AppHome.tsx</code>: <pre><code>const [promptTxConfirmation, promptTxConfirmationSet] = useState(false);\n// ...\npromptTxConfirmationSet(true); // In a button's onClick event that shows the modal\n// ...\n{!!promptTxConfirmation &amp;&amp; (\n    &lt;Modal onClose={() =&gt; promptTxConfirmationSet(false)}&gt;\n        &lt;p className=\"text-center text-lg font-semibold\"&gt;\n            {vpAddress\n                ? i18n.confirmTransactionOnVitePassport\n                : i18n.confirmTransactionOnYourViteWalletApp}\n        &lt;/p&gt;\n    &lt;/Modal&gt;\n)}\n</code></pre></p>"},{"location":"vite-express/#textinput-component","title":"TextInput Component","text":"<p>The <code>TextInput</code> component is self-explanatory. It has many props for changing how it looks and behaves. However its most useful feature is validating their inputs when submitting forms. To use it, you need to create references for each <code>TextInput</code> and pass it to the corresponding <code>_ref</code> prop. To validate multiple <code>TextInput</code>s, pass them as an array to <code>validateInputs</code> which when called will return <code>true</code> if all the input refs are valid - else false.</p> <p>The two props that alter how <code>TextInput</code>s are validated are <code>optional</code> (meaning it can be empty, else it is implicitly required) and <code>getIssue</code> where it is passed the current trimmed value and it can return a string if there are any errors.</p> <p>The <code>AppHome</code> shows an example of this in action.</p> <p><code>frontend/src/pages/AppHome.tsx</code>: <pre><code>const beneficiaryAddressRef = useRef&lt;TextInputRefObject&gt;();\nconst amountRef = useRef&lt;TextInputRefObject&gt;();\n// ...\n&lt;TextInput\n  _ref={addressRef}\n  label={i18n.beneficiaryAddress}\n  initialValue={searchParams.get('address')}\n  getIssue={(v) =&gt; {\n    if (!wallet.isValidAddress(v)) {\n      return i18n.invalidAddress;\n    }\n  }}\n/&gt;\n&lt;TextInput\n  numeric\n  _ref={amountRef}\n  label={i18n.amount}\n  initialValue={searchParams.get('amount')}\n  getIssue={(v) =&gt; {\n    if (+v &lt;= 0) {\n      return i18n.amountMustBePositive;\n    }\n  }}\n/&gt;\n&lt;button\n  className={`${\n    vcInstance ? 'bg-skin-medlight brightness-button' : 'bg-gray-400'\n  } h-8 px-3 rounded-md font-semibold text-white shadow`}\n  disabled={!vcInstance}\n  onClick={async () =&gt; {\n    if (validateInputs([beneficiaryAddressRef, amountRef])) {\n      // The inputs are valid according to their getIssue prop and inputs without the `optional` prop have a truthy input value.\n            // Do stuff with `addressRef.value` and `amountRef.value`\n    }\n  }}\n&gt;\n  {i18n.buyCoffee}\n&lt;/button&gt;\n</code></pre></p>"},{"location":"vite-express/#toast-component","title":"Toast Component","text":"<p>The <code>Toast</code> component renders a small ephemeral notification at the top of the screen. It should not be rendered more than once and by default it's already rendered in <code>Router.tsx</code>. To display a toast message, you must call <code>setState({ toast: '&lt;toast_message&gt;' })</code> like in <code>AppHome.tsx</code>.</p> <p><code>frontend/src/pages/AppHome.tsx</code>: <pre><code>&lt;button\n  className={`${\n    vcInstance ? 'bg-skin-medlight brightness-button' : 'bg-gray-400'\n  } h-8 px-3 rounded-md font-semibold text-white shadow`}\n  disabled={!vcInstance}\n  onClick={async () =&gt; {\n    if (validateInputs([beneficiaryAddressRef, amountRef])) {\n      promptTxConfirmationSet(true);\n      await callContract(\n        CafeContract,\n        'buyCoffee',\n        [beneficiaryAddress, amount],\n        constant.Vite_TokenId,\n        toSmallestUnit(amount, constant.Vite_Token_Info.decimals)\n      );\n      setState({ toast: i18n.transactionConfirmed });\n      beneficiaryAddressSet('');\n      amountSet('');\n      promptTxConfirmationSet(false);\n    }\n  }}\n&gt;\n  {i18n.buyCoffee}\n&lt;/button&gt;\n</code></pre></p>"},{"location":"vite-express/#connectwalletbutton-component","title":"ConnectWalletButton Component","text":"<p>The <code>ConnectWalletButton</code> component will show a \"Connect Wallet\" button if a Vite Wallet app or Vite Passport wallet isn't connected. If either one of those wallets is connected, the connected address will be displayed instead.</p> <p>If you disconnect from the frontend by logging out, the connected wallet (whether it is the app or extension) will also disconnect. If you disconnect from the frontend via the Vite Wallet app or Vite Passport, the frontend will log out for you (i.e. the address button changes back to the \"Connect Wallet\" button).</p> <p>If a Vite Wallet app is connected and the frontend is refreshed or otherwise exited and opened within a few minutes, the ViteConnect session will persist via <code>getValidVCSession</code> in <code>viteConnect.ts</code>. Dapps connected with Vite Passport will persist indefinitely until the user or dapp programmatically disconnects.</p> <p><code>frontend/src/utils/viteConnect.ts</code>: <pre><code>export class VC extends Connector {\n    // ...\n  // createSession and signAndSendTx are the only two methods of the VC class that are used externally\n    async createSession() {\n        await super.createSession();\n        return this.uri;\n    }\n\n    async signAndSendTx(params: object[]) {\n        return new Promise((resolve, reject) =&gt; {\n            this.sendCustomRequest({ method: 'vite_signAndSendTx', params })\n                .then((result: object) =&gt; {\n                    this.saveSession();\n                    resolve(result);\n                })\n                .catch((e: Error) =&gt; reject(e));\n        });\n    }\n}\n\nexport function getValidVCSession() {\n    // This function returns a ViteConnect session stored in localStorage if it exists\n}\n\nexport function initViteConnect(session: object) {\n  // The constructor of the VC class saves the newly created session in localStorage\n    return new VC({\n        session,\n        bridge: 'wss://biforst.vite.net',\n    });\n}\n</code></pre></p> <p><code>frontend/src/containers/ConnectWalletButton.tsx</code>: <pre><code>const ConnectWalletButton = ({ setState, i18n, activeAddress, vcInstance, vpAddress }: Props) =&gt; {\n    const [connectURI, connectURISet] = useState('');\n\n    useEffect(() =&gt; {\n        if (vcInstance) {\n            vcInstance.on('disconnect', () =&gt; setState({ vcInstance: undefined }));\n        }\n    }, [setState, vcInstance]);\n\n    useEffect(() =&gt; {\n        if (activeAddress) {\n            connectURISet('');\n        }\n    }, [activeAddress]);\n\n    return activeAddress ? (\n        &lt;DropdownButton\n            buttonJsx={&lt;p&gt;{shortenAddress(activeAddress)}&lt;/p&gt;}\n            dropdownJsx={\n                &lt;button\n                    className=\"fx px-2 py-0.5 h-7 gap-2\"\n                    onClick={() =&gt; {\n                        if (vpAddress &amp;&amp; window?.vitePassport) {\n                            setState({ vpAddress: undefined });\n                            window.vitePassport.disconnectWallet();\n                        } else {\n                            vcInstance!.killSession();\n                        }\n                    }}\n                    onMouseDown={(e) =&gt; e.preventDefault()}\n                &gt;\n                    &lt;LogoutIcon className=\"h-full text-skin-muted\" /&gt;\n                    &lt;p className=\"font-semibold\"&gt;{i18n.logOut}&lt;/p&gt;\n                &lt;/button&gt;\n            }\n        /&gt;\n    ) : (\n        &lt;&gt;\n            &lt;button\n                className=\"bg-skin-medlight h-8 px-3 rounded-md brightness-button font-semibold text-white shadow\"\n                onClick={async () =&gt; {\n                    vcInstance = initViteConnect();\n                    connectURISet(await vcInstance.createSession());\n                    vcInstance.on('connect', () =&gt; setState({ vcInstance }));\n                }}\n            &gt;\n                &lt;p&gt;{i18n.connectWallet}&lt;/p&gt;\n            &lt;/button&gt;\n            {!!connectURI &amp;&amp; (\n                &lt;Modal onClose={() =&gt; connectURISet('')}&gt;\n                    &lt;p className=\"text-center text-lg mb-3 font-semibold\"&gt;{i18n.scanWithYourViteWalletApp}&lt;/p&gt;\n                    &lt;div className=\"xy\"&gt;\n                        &lt;QR data={connectURI} /&gt;\n                    &lt;/div&gt;\n                    &lt;p className=\"text-center text-lg my-3 font-semibold\"&gt;{i18n.or}&lt;/p&gt;\n                    &lt;button\n                        className=\"bg-skin-medlight h-8 w-full rounded-md brightness-button font-semibold text-white shadow\"\n                        onClick={async () =&gt; {\n                            if (window?.vitePassport) {\n                                try {\n                                    await window.vitePassport.connectWallet();\n                                    const activeNetwork = await window.vitePassport.getNetwork();\n                                    setState({\n                                        activeNetworkIndex: networkList.findIndex(\n                                            (n) =&gt; n.rpcUrl === activeNetwork.rpcUrl\n                                        ),\n                                    });\n                                } catch (error) {\n                                    setState({ toast: error });\n                                }\n                            } else {\n                                setState({ toast: i18n.vitePassportNotDetected });\n                            }\n                        }}\n                    &gt;\n                        {i18n.connectWithVitePassport}\n                    &lt;/button&gt;\n                &lt;/Modal&gt;\n            )}\n        &lt;/&gt;\n    );\n};\n\nexport default connect(ConnectWalletButton);\n</code></pre></p>"},{"location":"vite-express/#contract-configuration","title":"Contract Configuration","text":"<p>All contracts should be put in the <code>contracts</code> folder with this structure.</p> <p>Note: Use the Solpp debugger extension or run <code>npx vuilder compile Cafe.solpp</code> to get contract ABI.</p> <p><code>frontend/src/contracts/Cafe.ts</code>: <pre><code>const Cafe = {\n    address: {\n        mainnet: '',\n        testnet: '&lt;your_contract_address&gt;',\n        localnet: '',\n    },\n    abi: [\n        { inputs: [], stateMutability: 'payable', type: 'constructor' },\n        // ...\n    ],\n};\n\nexport default Cafe;\n</code></pre></p>"},{"location":"vite-express/#contract-interaction","title":"Contract Interaction","text":"<p>Once a ViteConnect instance is created and contracts are configured, you can interact with a contract with the <code>callContract</code> method which is part of the global state and updated in <code>Router.tsx</code>. Calling the <code>callContract</code> method will return a <code>Promise</code>, so you may want to use it with <code>async</code>/<code>await</code> where you prompt the user to confirm the transaction before blocking the code execution with <code>await</code>.</p> <p><code>frontend/src/components/Router.tsx</code>: <pre><code>const callContract = useCallback(\n  (\n    contract: typeof CafeContract,\n    methodName: string,\n    params: any[] = [],\n    tokenId?: string,\n    amount?: string\n  ) =&gt; {\n    if (!vcInstance) {\n      return;\n    }\n    const methodAbi = contract.abi.find(\n      (x: any) =&gt; x.name === methodName &amp;&amp; x.type === 'function'\n    );\n    if (!methodAbi) {\n      throw new Error(`method not found: ${methodName}`);\n    }\n    const toAddress = contract.address[networkType];\n    if (!toAddress) {\n      throw new Error(`${networkType} contract address not found`);\n    }\n    const block = accountBlock.createAccountBlock('callContract', {\n      address: connectedAccount,\n      abi: methodAbi,\n      toAddress,\n      params,\n      tokenId,\n      amount,\n    }).accountBlock;\n    return vcInstance.signAndSendTx([{ block }]);\n  },\n  [connectedAccount, networkType, vcInstance]\n);\nuseEffect(() =&gt; {\n  setState({ callContract });\n}, [setState, callContract]);\n</code></pre></p> <p><code>frontend/src/pages/AppHome.tsx</code>: <pre><code>&lt;button\n  className={`${\n    vcInstance ? 'bg-skin-medlight brightness-button' : 'bg-gray-400'\n  } h-8 px-3 rounded-md font-semibold text-white shadow`}\n  disabled={!vcInstance}\n  onClick={async () =&gt; {\n    if (validateInputs([beneficiaryAddressRef, amountRef])) {\n      promptTxConfirmationSet(true);\n      await callContract(\n        CafeContract,\n        'buyCoffee',\n        [beneficiaryAddress, amount],\n        constant.Vite_TokenId,\n        toSmallestUnit(amount, constant.Vite_Token_Info.decimals)\n      );\n      setState({ toast: i18n.transactionConfirmed });\n      beneficiaryAddressSet('');\n      amountSet('');\n      promptTxConfirmationSet(false);\n    }\n  }}\n&gt;\n  {i18n.buyCoffee}\n&lt;/button&gt;\n</code></pre></p>"}]}